Index: Permissions.cs
===================================================================
--- Permissions.cs	(revision 2445)
+++ Permissions.cs	(working copy)
@@ -1,161 +1,162 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using OpenMetaverse.StructuredData;
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    [Flags]
-    public enum PermissionMask : uint
-    {
-        None        = 0,
-        Transfer    = 1 << 13,
-        Modify      = 1 << 14,
-        Copy        = 1 << 15,
-        //[Obsolete]
-        //EnterParcel = 1 << 16,
-        //[Obsolete]
-        //Terraform   = 1 << 17,
-        //[Obsolete]
-        //OwnerDebit  = 1 << 18,
-        Move        = 1 << 19,
-        Damage      = 1 << 20,
-        All         = 0x7FFFFFFF
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    [Flags]
-    public enum PermissionWho : byte
-    {
-        /// <summary></summary>
-        Base = 0x01,
-        /// <summary></summary>
-        Owner = 0x02,
-        /// <summary></summary>
-        Group = 0x04,
-        /// <summary></summary>
-        Everyone = 0x08,
-        /// <summary></summary>
-        NextOwner = 0x10,
-        /// <summary></summary>
-        All = 0x1F
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public struct Permissions
-    {
-        public PermissionMask BaseMask;
-        public PermissionMask EveryoneMask;
-        public PermissionMask GroupMask;
-        public PermissionMask NextOwnerMask;
-        public PermissionMask OwnerMask;
-
-        public Permissions(uint baseMask, uint everyoneMask, uint groupMask, uint nextOwnerMask, uint ownerMask)
-        {
-            BaseMask = (PermissionMask)baseMask;
-            EveryoneMask = (PermissionMask)everyoneMask;
-            GroupMask = (PermissionMask)groupMask;
-            NextOwnerMask = (PermissionMask)nextOwnerMask;
-            OwnerMask = (PermissionMask)ownerMask;
-        }
-
-        public OSD GetOSD()
-        {
-            OSDMap permissions = new OSDMap(5);
-            permissions["BaseMask"] = OSD.FromUInteger((uint)BaseMask);
-            permissions["EveryoneMask"] = OSD.FromUInteger((uint)EveryoneMask);
-            permissions["GroupMask"] = OSD.FromUInteger((uint)GroupMask);
-            permissions["NextOwnerMask"] = OSD.FromUInteger((uint)NextOwnerMask);
-            permissions["OwnerMask"] = OSD.FromUInteger((uint)OwnerMask);
-            return permissions;
-        }
-
-        public static Permissions FromOSD(OSD llsd)
-        {
-            Permissions permissions = new Permissions();
-            OSDMap map = (OSDMap)llsd;
-
-            byte[] bytes = map["BaseMask"].AsBinary();
-            permissions.BaseMask = (PermissionMask)Utils.BytesToUInt(bytes);
-            bytes = map["EveryoneMask"].AsBinary();
-            permissions.EveryoneMask = (PermissionMask)Utils.BytesToUInt(bytes);
-            bytes = map["GroupMask"].AsBinary();
-            permissions.GroupMask = (PermissionMask)Utils.BytesToUInt(bytes);
-            bytes = map["NextOwnerMask"].AsBinary();
-            permissions.NextOwnerMask = (PermissionMask)Utils.BytesToUInt(bytes);
-            bytes = map["OwnerMask"].AsBinary();
-            permissions.OwnerMask = (PermissionMask)Utils.BytesToUInt(bytes);
-
-            return permissions;
-        }
-
-        public override string ToString()
-        {
-            return String.Format("Base: {0}, Everyone: {1}, Group: {2}, NextOwner: {3}, Owner: {4}",
-                BaseMask, EveryoneMask, GroupMask, NextOwnerMask, OwnerMask);
-        }
-
-        public override int GetHashCode()
-        {
-            return BaseMask.GetHashCode() ^ EveryoneMask.GetHashCode() ^ GroupMask.GetHashCode() ^
-                NextOwnerMask.GetHashCode() ^ OwnerMask.GetHashCode();
-        }
-
-        public override bool Equals(object obj)
-        {
-            return (obj is Permissions) ? this == (Permissions)obj : false;
-        }
-
-        public bool Equals(Permissions other)
-        {
-            return this == other;
-        }
-
-        public static bool operator ==(Permissions lhs, Permissions rhs)
-        {
-            return (lhs.BaseMask == rhs.BaseMask) && (lhs.EveryoneMask == rhs.EveryoneMask) &&
-                (lhs.GroupMask == rhs.GroupMask) && (lhs.NextOwnerMask == rhs.NextOwnerMask) &&
-                (lhs.OwnerMask == rhs.OwnerMask);
-        }
-
-        public static bool operator !=(Permissions lhs, Permissions rhs)
-        {
-            return !(lhs == rhs);
-        }
-
-        public static readonly Permissions NoPermissions = new Permissions();
-        public static readonly Permissions FullPermissions = new Permissions(UInt32.MaxValue, UInt32.MaxValue,
-            UInt32.MaxValue, UInt32.MaxValue, UInt32.MaxValue);
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using OpenMetaverse.StructuredData;
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// 
+    /// </summary>
+    [Flags]
+    public enum PermissionMask : uint
+    {
+        None        = 0,
+        Transfer    = 1 << 13,
+        Modify      = 1 << 14,
+        Copy        = 1 << 15,
+        //[Obsolete]
+        //EnterParcel = 1 << 16,
+        //[Obsolete]
+        //Terraform   = 1 << 17,
+        //[Obsolete]
+        //OwnerDebit  = 1 << 18,
+        Move        = 1 << 19,
+        Damage      = 1 << 20,
+        All         = 0x7FFFFFFF
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    [Flags]
+    public enum PermissionWho : byte
+    {
+        /// <summary></summary>
+        Base = 0x01,
+        /// <summary></summary>
+        Owner = 0x02,
+        /// <summary></summary>
+        Group = 0x04,
+        /// <summary></summary>
+        Everyone = 0x08,
+        /// <summary></summary>
+        NextOwner = 0x10,
+        /// <summary></summary>
+        All = 0x1F
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    [Serializable()]
+    public struct Permissions
+    {
+        public PermissionMask BaseMask;
+        public PermissionMask EveryoneMask;
+        public PermissionMask GroupMask;
+        public PermissionMask NextOwnerMask;
+        public PermissionMask OwnerMask;
+
+        public Permissions(uint baseMask, uint everyoneMask, uint groupMask, uint nextOwnerMask, uint ownerMask)
+        {
+            BaseMask = (PermissionMask)baseMask;
+            EveryoneMask = (PermissionMask)everyoneMask;
+            GroupMask = (PermissionMask)groupMask;
+            NextOwnerMask = (PermissionMask)nextOwnerMask;
+            OwnerMask = (PermissionMask)ownerMask;
+        }
+
+        public OSD GetOSD()
+        {
+            OSDMap permissions = new OSDMap(5);
+            permissions["BaseMask"] = OSD.FromUInteger((uint)BaseMask);
+            permissions["EveryoneMask"] = OSD.FromUInteger((uint)EveryoneMask);
+            permissions["GroupMask"] = OSD.FromUInteger((uint)GroupMask);
+            permissions["NextOwnerMask"] = OSD.FromUInteger((uint)NextOwnerMask);
+            permissions["OwnerMask"] = OSD.FromUInteger((uint)OwnerMask);
+            return permissions;
+        }
+
+        public static Permissions FromOSD(OSD llsd)
+        {
+            Permissions permissions = new Permissions();
+            OSDMap map = (OSDMap)llsd;
+
+            byte[] bytes = map["BaseMask"].AsBinary();
+            permissions.BaseMask = (PermissionMask)Utils.BytesToUInt(bytes);
+            bytes = map["EveryoneMask"].AsBinary();
+            permissions.EveryoneMask = (PermissionMask)Utils.BytesToUInt(bytes);
+            bytes = map["GroupMask"].AsBinary();
+            permissions.GroupMask = (PermissionMask)Utils.BytesToUInt(bytes);
+            bytes = map["NextOwnerMask"].AsBinary();
+            permissions.NextOwnerMask = (PermissionMask)Utils.BytesToUInt(bytes);
+            bytes = map["OwnerMask"].AsBinary();
+            permissions.OwnerMask = (PermissionMask)Utils.BytesToUInt(bytes);
+
+            return permissions;
+        }
+
+        public override string ToString()
+        {
+            return String.Format("Base: {0}, Everyone: {1}, Group: {2}, NextOwner: {3}, Owner: {4}",
+                BaseMask, EveryoneMask, GroupMask, NextOwnerMask, OwnerMask);
+        }
+
+        public override int GetHashCode()
+        {
+            return BaseMask.GetHashCode() ^ EveryoneMask.GetHashCode() ^ GroupMask.GetHashCode() ^
+                NextOwnerMask.GetHashCode() ^ OwnerMask.GetHashCode();
+        }
+
+        public override bool Equals(object obj)
+        {
+            return (obj is Permissions) ? this == (Permissions)obj : false;
+        }
+
+        public bool Equals(Permissions other)
+        {
+            return this == other;
+        }
+
+        public static bool operator ==(Permissions lhs, Permissions rhs)
+        {
+            return (lhs.BaseMask == rhs.BaseMask) && (lhs.EveryoneMask == rhs.EveryoneMask) &&
+                (lhs.GroupMask == rhs.GroupMask) && (lhs.NextOwnerMask == rhs.NextOwnerMask) &&
+                (lhs.OwnerMask == rhs.OwnerMask);
+        }
+
+        public static bool operator !=(Permissions lhs, Permissions rhs)
+        {
+            return !(lhs == rhs);
+        }
+
+        public static readonly Permissions NoPermissions = new Permissions();
+        public static readonly Permissions FullPermissions = new Permissions(UInt32.MaxValue, UInt32.MaxValue,
+            UInt32.MaxValue, UInt32.MaxValue, UInt32.MaxValue);
+    }
+}
Index: Logger.cs
===================================================================
--- Logger.cs	(revision 2445)
+++ Logger.cs	(working copy)
@@ -1,187 +1,187 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using log4net;
-using log4net.Config;
-
-[assembly: log4net.Config.XmlConfigurator(Watch = true)]
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// Singleton logging class for the entire library
-    /// </summary>
-    public static class Logger
-    {
-        /// <summary>
-        /// Callback used for client apps to receive log messages from
-        /// the library
-        /// </summary>
-        /// <param name="message">Data being logged</param>
-        /// <param name="level">The severity of the log entry from <seealso cref="Helpers.LogLevel"/></param>
-        public delegate void LogCallback(object message, Helpers.LogLevel level);
-
-        /// <summary>Triggered whenever a message is logged. If this is left
-        /// null, log messages will go to the console</summary>
-        public static event LogCallback OnLogMessage;
-
-        /// <summary>log4net logging engine</summary>
-        public static ILog LogInstance;
-
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        static Logger()
-        {
-            LogInstance = LogManager.GetLogger("OpenMetaverse");
-
-            // If error level reporting isn't enabled we assume no logger is configured and initialize a default
-            // ConsoleAppender
-            if (!LogInstance.Logger.IsEnabledFor(log4net.Core.Level.Error))
-            {
-                log4net.Appender.ConsoleAppender appender = new log4net.Appender.ConsoleAppender();
-                appender.Layout = new log4net.Layout.PatternLayout("%timestamp [%thread] %-5level - %message%newline");
-                BasicConfigurator.Configure(appender);
-
-                if(Settings.LOG_LEVEL != Helpers.LogLevel.None)
-                    LogInstance.Info("No log configuration found, defaulting to console logging");
-            }
-        }
-
-        /// <summary>
-        /// Send a log message to the logging engine
-        /// </summary>
-        /// <param name="message">The log message</param>
-        /// <param name="level">The severity of the log entry</param>
-        public static void Log(object message, Helpers.LogLevel level)
-        {
-            Log(message, level, null, null);
-        }
-
-        /// <summary>
-        /// Send a log message to the logging engine
-        /// </summary>
-        /// <param name="message">The log message</param>
-        /// <param name="level">The severity of the log entry</param>
-        /// <param name="client">Instance of the client</param>
-        public static void Log(object message, Helpers.LogLevel level, GridClient client)
-        {
-            Log(message, level, client, null);
-        }
-
-        /// <summary>
-        /// Send a log message to the logging engine
-        /// </summary>
-        /// <param name="message">The log message</param>
-        /// <param name="level">The severity of the log entry</param>
-        /// <param name="exception">Exception that was raised</param>
-        public static void Log(object message, Helpers.LogLevel level, Exception exception)
-        {
-            Log(message, level, null, exception);
-        }
-
-        /// <summary>
-        /// Send a log message to the logging engine
-        /// </summary>
-        /// <param name="message">The log message</param>
-        /// <param name="level">The severity of the log entry</param>
-        /// <param name="client">Instance of the client</param>
-        /// <param name="exception">Exception that was raised</param>
-        public static void Log(object message, Helpers.LogLevel level, GridClient client, Exception exception)
-        {
-            if (client != null && client.Settings.LOG_NAMES)
-                message = String.Format("<{0}>: {1}", client.Self.Name, message);
-
-            if (OnLogMessage != null)
-                OnLogMessage(message, level);
-
-            switch (level)
-            {
-                case Helpers.LogLevel.Debug:
-                    if (Settings.LOG_LEVEL == Helpers.LogLevel.Debug)
-                        LogInstance.Debug(message, exception);
-                    break;
-                case Helpers.LogLevel.Info:
-                    if (Settings.LOG_LEVEL == Helpers.LogLevel.Debug
-                        || Settings.LOG_LEVEL == Helpers.LogLevel.Info)
-                        LogInstance.Info(message, exception);
-                    break;
-                case Helpers.LogLevel.Warning:
-                    if (Settings.LOG_LEVEL == Helpers.LogLevel.Debug
-                        || Settings.LOG_LEVEL == Helpers.LogLevel.Info
-                        || Settings.LOG_LEVEL == Helpers.LogLevel.Warning)
-                        LogInstance.Warn(message, exception);
-                    break;
-                case Helpers.LogLevel.Error:
-                    if (Settings.LOG_LEVEL == Helpers.LogLevel.Debug
-                        || Settings.LOG_LEVEL == Helpers.LogLevel.Info
-                        || Settings.LOG_LEVEL == Helpers.LogLevel.Warning
-                        || Settings.LOG_LEVEL == Helpers.LogLevel.Error)
-                        LogInstance.Error(message, exception);
-                    break;
-                default:
-                    break;
-            } 
-        }
-
-        /// <summary>
-        /// If the library is compiled with DEBUG defined, an event will be
-        /// fired if an <code>OnLogMessage</code> handler is registered and the
-        /// message will be sent to the logging engine
-        /// </summary>
-        /// <param name="message">The message to log at the DEBUG level to the
-        /// current logging engine</param>
-        public static void DebugLog(object message)
-        {
-            DebugLog(message, null);
-        }
-
-        /// <summary>
-        /// If the library is compiled with DEBUG defined and
-        /// <code>GridClient.Settings.DEBUG</code> is true, an event will be
-        /// fired if an <code>OnLogMessage</code> handler is registered and the
-        /// message will be sent to the logging engine
-        /// </summary>
-        /// <param name="message">The message to log at the DEBUG level to the
-        /// current logging engine</param>
-        /// <param name="client">Instance of the client</param>
-        [System.Diagnostics.Conditional("DEBUG")]
-        public static void DebugLog(object message, GridClient client)
-        {
-            if (Settings.LOG_LEVEL == Helpers.LogLevel.Debug)
-            {
-                if (client != null && client.Settings.LOG_NAMES)
-                    message = String.Format("<{0}>: {1}", client.Self.Name, message);
-
-                if (OnLogMessage != null)
-                    OnLogMessage(message, Helpers.LogLevel.Debug);
-
-                LogInstance.Debug(message);
-            }
-        }
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using log4net;
+using log4net.Config;
+
+[assembly: log4net.Config.XmlConfigurator(Watch = true)]
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// Singleton logging class for the entire library
+    /// </summary>
+    public static class Logger
+    {
+        /// <summary>
+        /// Callback used for client apps to receive log messages from
+        /// the library
+        /// </summary>
+        /// <param name="message">Data being logged</param>
+        /// <param name="level">The severity of the log entry from <seealso cref="Helpers.LogLevel"/></param>
+        public delegate void LogCallback(object message, Helpers.LogLevel level);
+
+        /// <summary>Triggered whenever a message is logged. If this is left
+        /// null, log messages will go to the console</summary>
+        public static event LogCallback OnLogMessage;
+
+        /// <summary>log4net logging engine</summary>
+        public static ILog LogInstance;
+
+        /// <summary>
+        /// Default constructor
+        /// </summary>
+        static Logger()
+        {
+            LogInstance = LogManager.GetLogger("OpenMetaverse");
+
+            // If error level reporting isn't enabled we assume no logger is configured and initialize a default
+            // ConsoleAppender
+            if (!LogInstance.Logger.IsEnabledFor(log4net.Core.Level.Error))
+            {
+                log4net.Appender.ConsoleAppender appender = new log4net.Appender.ConsoleAppender();
+                appender.Layout = new log4net.Layout.PatternLayout("%timestamp [%thread] %-5level - %message%newline");
+                BasicConfigurator.Configure(appender);
+
+                if(Settings.LOG_LEVEL != Helpers.LogLevel.None)
+                    LogInstance.Info("No log configuration found, defaulting to console logging");
+            }
+        }
+
+        /// <summary>
+        /// Send a log message to the logging engine
+        /// </summary>
+        /// <param name="message">The log message</param>
+        /// <param name="level">The severity of the log entry</param>
+        public static void Log(object message, Helpers.LogLevel level)
+        {
+            Log(message, level, null, null);
+        }
+
+        /// <summary>
+        /// Send a log message to the logging engine
+        /// </summary>
+        /// <param name="message">The log message</param>
+        /// <param name="level">The severity of the log entry</param>
+        /// <param name="client">Instance of the client</param>
+        public static void Log(object message, Helpers.LogLevel level, GridClient client)
+        {
+            Log(message, level, client, null);
+        }
+
+        /// <summary>
+        /// Send a log message to the logging engine
+        /// </summary>
+        /// <param name="message">The log message</param>
+        /// <param name="level">The severity of the log entry</param>
+        /// <param name="exception">Exception that was raised</param>
+        public static void Log(object message, Helpers.LogLevel level, Exception exception)
+        {
+            Log(message, level, null, exception);
+        }
+
+        /// <summary>
+        /// Send a log message to the logging engine
+        /// </summary>
+        /// <param name="message">The log message</param>
+        /// <param name="level">The severity of the log entry</param>
+        /// <param name="client">Instance of the client</param>
+        /// <param name="exception">Exception that was raised</param>
+        public static void Log(object message, Helpers.LogLevel level, GridClient client, Exception exception)
+        {
+            if (client != null && client.Settings.LOG_NAMES)
+                message = String.Format("<{0}>: {1}", client.Self.Name, message);
+
+            if (OnLogMessage != null)
+                OnLogMessage(message, level);
+
+            switch (level)
+            {
+                case Helpers.LogLevel.Debug:
+                    if (Settings.LOG_LEVEL == Helpers.LogLevel.Debug)
+                        LogInstance.Debug(message, exception);
+                    break;
+                case Helpers.LogLevel.Info:
+                    if (Settings.LOG_LEVEL == Helpers.LogLevel.Debug
+                        || Settings.LOG_LEVEL == Helpers.LogLevel.Info)
+                        LogInstance.Info(message, exception);
+                    break;
+                case Helpers.LogLevel.Warning:
+                    if (Settings.LOG_LEVEL == Helpers.LogLevel.Debug
+                        || Settings.LOG_LEVEL == Helpers.LogLevel.Info
+                        || Settings.LOG_LEVEL == Helpers.LogLevel.Warning)
+                        LogInstance.Warn(message, exception);
+                    break;
+                case Helpers.LogLevel.Error:
+                    if (Settings.LOG_LEVEL == Helpers.LogLevel.Debug
+                        || Settings.LOG_LEVEL == Helpers.LogLevel.Info
+                        || Settings.LOG_LEVEL == Helpers.LogLevel.Warning
+                        || Settings.LOG_LEVEL == Helpers.LogLevel.Error)
+                        LogInstance.Error(message, exception);
+                    break;
+                default:
+                    break;
+            } 
+        }
+
+        /// <summary>
+        /// If the library is compiled with DEBUG defined, an event will be
+        /// fired if an <code>OnLogMessage</code> handler is registered and the
+        /// message will be sent to the logging engine
+        /// </summary>
+        /// <param name="message">The message to log at the DEBUG level to the
+        /// current logging engine</param>
+        public static void DebugLog(object message)
+        {
+            DebugLog(message, null);
+        }
+
+        /// <summary>
+        /// If the library is compiled with DEBUG defined and
+        /// <code>GridClient.Settings.DEBUG</code> is true, an event will be
+        /// fired if an <code>OnLogMessage</code> handler is registered and the
+        /// message will be sent to the logging engine
+        /// </summary>
+        /// <param name="message">The message to log at the DEBUG level to the
+        /// current logging engine</param>
+        /// <param name="client">Instance of the client</param>
+        // [System.Diagnostics.Conditional("DEBUG")]
+        public static void DebugLog(object message, GridClient client)
+        {
+            if (Settings.LOG_LEVEL == Helpers.LogLevel.Debug)
+            {
+                if (client != null && client.Settings.LOG_NAMES)
+                    message = String.Format("<{0}>: {1}", client.Self.Name, message);
+
+                if (OnLogMessage != null)
+                    OnLogMessage(message, Helpers.LogLevel.Debug);
+
+                LogInstance.Debug(message);
+            }
+        }
+    }
+}
Index: SoundManager.cs
===================================================================
--- SoundManager.cs	(revision 2445)
+++ SoundManager.cs	(working copy)
@@ -1,181 +1,181 @@
-/*
- * Copyright (c) 2006-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using OpenMetaverse.Packets;
-
-namespace OpenMetaverse
-{
-    public class SoundManager
-    {
-        public readonly GridClient Client;
-
-        public delegate void AttachSoundCallback(UUID soundID, UUID ownerID, UUID objectID, float gain, byte flags);
-        public delegate void AttachedSoundGainChangeCallback(UUID objectID, float gain);
-        public delegate void SoundTriggerCallback(UUID soundID, UUID ownerID, UUID objectID, UUID parentID, float gain, ulong regionHandle, Vector3 position);
-        public delegate void PreloadSoundCallback(UUID soundID, UUID ownerID, UUID objectID);
-
-        public event AttachSoundCallback OnAttachSound;
-        public event AttachedSoundGainChangeCallback OnAttachSoundGainChange;
-        public event SoundTriggerCallback OnSoundTrigger;
-        public event PreloadSoundCallback OnPreloadSound;
-
-        public SoundManager(GridClient client)
-        {
-            Client = client;
-
-            Client.Network.RegisterCallback(PacketType.AttachedSound, new NetworkManager.PacketCallback(AttachedSoundHandler));
-            Client.Network.RegisterCallback(PacketType.AttachedSoundGainChange, new NetworkManager.PacketCallback(AttachedSoundGainChangeHandler));
-            Client.Network.RegisterCallback(PacketType.PreloadSound, new NetworkManager.PacketCallback(PreloadSoundHandler));
-            Client.Network.RegisterCallback(PacketType.SoundTrigger, new NetworkManager.PacketCallback(SoundTriggerHandler));
-        }
-
-        #region public methods
-
-        /// <summary>
-        /// Plays a sound in the current region at full volume from avatar position
-        /// </summary>
-        /// <param name="soundID">UUID of the sound to be played</param>
-        public void SoundTrigger(UUID soundID)
-        {
-            SoundTrigger(soundID, Client.Self.SimPosition, 1.0f);
-        }
-
-        /// <summary>
-        /// Plays a sound in the current region at full volume
-        /// </summary>
-        /// <param name="soundID">UUID of the sound to be played.</param>
-        /// <param name="position">position for the sound to be played at. Normally the avatar.</param>
-        public void SoundTrigger(UUID soundID, Vector3 position)
-        {
-            SoundTrigger(soundID, Client.Self.SimPosition, 1.0f);
-        }
-
-        /// <summary>
-        /// Plays a sound in the current region
-        /// </summary>
-        /// <param name="soundID">UUID of the sound to be played.</param>
-        /// <param name="position">position for the sound to be played at. Normally the avatar.</param>
-        /// <param name="gain">volume of the sound, from 0.0 to 1.0</param>
-        public void SoundTrigger(UUID soundID, Vector3 position, float gain)
-        {
-            SoundTrigger(soundID, Client.Network.CurrentSim.Handle, position, 1.0f);
-        }
-        /// <summary>
-        /// Plays a sound in the specified sim
-        /// </summary>
-        /// <param name="soundID">UUID of the sound to be played.</param>
-        /// <param name="sim">UUID of the sound to be played.</param>
-        /// <param name="position">position for the sound to be played at. Normally the avatar.</param>
-        /// <param name="gain">volume of the sound, from 0.0 to 1.0</param>
-        public void SoundTrigger(UUID soundID, Simulator sim, Vector3 position, float gain)
-        {
-            SoundTrigger(soundID, sim.Handle, position, 1.0f);
-        }
-
-        /// <summary>
-        /// Plays a sound
-        /// </summary>
-        /// <param name="soundID">UUID of the sound to be played.</param>
-        /// <param name="handle">handle id for the sim to be played in.</param>
-        /// <param name="position">position for the sound to be played at. Normally the avatar.</param>
-        /// <param name="gain">volume of the sound, from 0.0 to 1.0</param>
-        public void SoundTrigger(UUID soundID, ulong handle, Vector3 position, float gain)
-        {
-            SoundTriggerPacket soundtrigger = new SoundTriggerPacket();
-            soundtrigger.SoundData = new SoundTriggerPacket.SoundDataBlock();
-            soundtrigger.SoundData.SoundID = soundID;
-            soundtrigger.SoundData.ObjectID = UUID.Zero;
-            soundtrigger.SoundData.OwnerID = UUID.Zero;
-            soundtrigger.SoundData.ParentID = UUID.Zero;
-            soundtrigger.SoundData.Handle = handle;
-            soundtrigger.SoundData.Position = position;
-            soundtrigger.SoundData.Gain = gain;
-            Client.Network.SendPacket(soundtrigger);
-        }
-
-        #endregion
-        #region Packet Handlers
-        protected void AttachedSoundHandler(Packet packet, Simulator simulator)
-        {
-            AttachedSoundPacket sound = (AttachedSoundPacket)packet;
-            if (OnAttachSound != null)
-            {
-                try { OnAttachSound(sound.DataBlock.SoundID, sound.DataBlock.OwnerID, sound.DataBlock.ObjectID, sound.DataBlock.Gain, sound.DataBlock.Flags); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        protected void AttachedSoundGainChangeHandler(Packet packet, Simulator simulator)
-        {
-            AttachedSoundGainChangePacket change = (AttachedSoundGainChangePacket)packet;
-            if (OnAttachSoundGainChange != null)
-            {
-                try { OnAttachSoundGainChange(change.DataBlock.ObjectID, change.DataBlock.Gain); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        protected void PreloadSoundHandler(Packet packet, Simulator simulator)
-        {
-            PreloadSoundPacket preload = (PreloadSoundPacket)packet;
-            if (OnPreloadSound != null)
-            {
-                foreach (PreloadSoundPacket.DataBlockBlock data in preload.DataBlock)
-                {
-                    try
-                    {
-                        OnPreloadSound(data.SoundID, data.OwnerID, data.ObjectID);
-                    }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-            }
-        }
-
-        protected void SoundTriggerHandler(Packet packet, Simulator simulator)
-        {
-            SoundTriggerPacket trigger = (SoundTriggerPacket)packet;
-            if (OnSoundTrigger != null)
-            {
-                try
-                {
-                    OnSoundTrigger(
-                        trigger.SoundData.SoundID,
-                        trigger.SoundData.OwnerID,
-                        trigger.SoundData.ObjectID,
-                        trigger.SoundData.ParentID,
-                        trigger.SoundData.Gain,
-                        trigger.SoundData.Handle,
-                        trigger.SoundData.Position
-                     );
-                }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-        #endregion
-    }
-}
+/*
+ * Copyright (c) 2006-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using OpenMetaverse.Packets;
+
+namespace OpenMetaverse
+{
+    public class SoundManager
+    {
+        public readonly GridClient Client;
+
+        public delegate void AttachSoundCallback(UUID soundID, UUID ownerID, UUID objectID, float gain, byte flags);
+        public delegate void AttachedSoundGainChangeCallback(UUID objectID, float gain);
+        public delegate void SoundTriggerCallback(UUID soundID, UUID ownerID, UUID objectID, UUID parentID, float gain, ulong regionHandle, Vector3 position);
+        public delegate void PreloadSoundCallback(UUID soundID, UUID ownerID, UUID objectID);
+
+        public event AttachSoundCallback OnAttachSound;
+        public event AttachedSoundGainChangeCallback OnAttachSoundGainChange;
+        public event SoundTriggerCallback OnSoundTrigger;
+        public event PreloadSoundCallback OnPreloadSound;
+
+        public SoundManager(GridClient client)
+        {
+            Client = client;
+
+            Client.Network.RegisterCallback(PacketType.AttachedSound, new NetworkManager.PacketCallback(AttachedSoundHandler));
+            Client.Network.RegisterCallback(PacketType.AttachedSoundGainChange, new NetworkManager.PacketCallback(AttachedSoundGainChangeHandler));
+            Client.Network.RegisterCallback(PacketType.PreloadSound, new NetworkManager.PacketCallback(PreloadSoundHandler));
+            Client.Network.RegisterCallback(PacketType.SoundTrigger, new NetworkManager.PacketCallback(SoundTriggerHandler));
+        }
+
+        #region public methods
+
+        /// <summary>
+        /// Plays a sound in the current region at full volume from avatar position
+        /// </summary>
+        /// <param name="soundID">UUID of the sound to be played</param>
+        public void SoundTrigger(UUID soundID)
+        {
+            SoundTrigger(soundID, Client.Self.SimPosition, 1.0f);
+        }
+
+        /// <summary>
+        /// Plays a sound in the current region at full volume
+        /// </summary>
+        /// <param name="soundID">UUID of the sound to be played.</param>
+        /// <param name="position">position for the sound to be played at. Normally the avatar.</param>
+        public void SoundTrigger(UUID soundID, Vector3 position)
+        {
+            SoundTrigger(soundID, Client.Self.SimPosition, 1.0f);
+        }
+
+        /// <summary>
+        /// Plays a sound in the current region
+        /// </summary>
+        /// <param name="soundID">UUID of the sound to be played.</param>
+        /// <param name="position">position for the sound to be played at. Normally the avatar.</param>
+        /// <param name="gain">volume of the sound, from 0.0 to 1.0</param>
+        public void SoundTrigger(UUID soundID, Vector3 position, float gain)
+        {
+            SoundTrigger(soundID, Client.Network.CurrentSim.Handle, position, 1.0f);
+        }
+        /// <summary>
+        /// Plays a sound in the specified sim
+        /// </summary>
+        /// <param name="soundID">UUID of the sound to be played.</param>
+        /// <param name="sim">UUID of the sound to be played.</param>
+        /// <param name="position">position for the sound to be played at. Normally the avatar.</param>
+        /// <param name="gain">volume of the sound, from 0.0 to 1.0</param>
+        public void SoundTrigger(UUID soundID, Simulator sim, Vector3 position, float gain)
+        {
+            SoundTrigger(soundID, sim.Handle, position, 1.0f);
+        }
+
+        /// <summary>
+        /// Plays a sound
+        /// </summary>
+        /// <param name="soundID">UUID of the sound to be played.</param>
+        /// <param name="handle">handle id for the sim to be played in.</param>
+        /// <param name="position">position for the sound to be played at. Normally the avatar.</param>
+        /// <param name="gain">volume of the sound, from 0.0 to 1.0</param>
+        public void SoundTrigger(UUID soundID, ulong handle, Vector3 position, float gain)
+        {
+            SoundTriggerPacket soundtrigger = new SoundTriggerPacket();
+            soundtrigger.SoundData = new SoundTriggerPacket.SoundDataBlock();
+            soundtrigger.SoundData.SoundID = soundID;
+            soundtrigger.SoundData.ObjectID = UUID.Zero;
+            soundtrigger.SoundData.OwnerID = UUID.Zero;
+            soundtrigger.SoundData.ParentID = UUID.Zero;
+            soundtrigger.SoundData.Handle = handle;
+            soundtrigger.SoundData.Position = position;
+            soundtrigger.SoundData.Gain = gain;
+            Client.Network.SendPacket(soundtrigger);
+        }
+
+        #endregion
+        #region Packet Handlers
+        protected void AttachedSoundHandler(Packet packet, Simulator simulator)
+        {
+            AttachedSoundPacket sound = (AttachedSoundPacket)packet;
+            if (OnAttachSound != null)
+            {
+                try { OnAttachSound(sound.DataBlock.SoundID, sound.DataBlock.OwnerID, sound.DataBlock.ObjectID, sound.DataBlock.Gain, sound.DataBlock.Flags); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        protected void AttachedSoundGainChangeHandler(Packet packet, Simulator simulator)
+        {
+            AttachedSoundGainChangePacket change = (AttachedSoundGainChangePacket)packet;
+            if (OnAttachSoundGainChange != null)
+            {
+                try { OnAttachSoundGainChange(change.DataBlock.ObjectID, change.DataBlock.Gain); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        protected void PreloadSoundHandler(Packet packet, Simulator simulator)
+        {
+            PreloadSoundPacket preload = (PreloadSoundPacket)packet;
+            if (OnPreloadSound != null)
+            {
+                foreach (PreloadSoundPacket.DataBlockBlock data in preload.DataBlock)
+                {
+                    try
+                    {
+                        OnPreloadSound(data.SoundID, data.OwnerID, data.ObjectID);
+                    }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+            }
+        }
+
+        protected void SoundTriggerHandler(Packet packet, Simulator simulator)
+        {
+            SoundTriggerPacket trigger = (SoundTriggerPacket)packet;
+            if (OnSoundTrigger != null)
+            {
+                try
+                {
+                    OnSoundTrigger(
+                        trigger.SoundData.SoundID,
+                        trigger.SoundData.OwnerID,
+                        trigger.SoundData.ObjectID,
+                        trigger.SoundData.ParentID,
+                        trigger.SoundData.Gain,
+                        trigger.SoundData.Handle,
+                        trigger.SoundData.Position
+                     );
+                }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+        #endregion
+    }
+}
Index: FriendsManager.cs
===================================================================
--- FriendsManager.cs	(revision 2445)
+++ FriendsManager.cs	(working copy)
@@ -1,762 +1,762 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-using OpenMetaverse.Packets;
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    [Flags]
-    public enum FriendRights : int
-    {
-        /// <summary>The avatar has no rights</summary>
-        None = 0,
-        /// <summary>The avatar can see the online status of the target avatar</summary>
-        CanSeeOnline = 1,
-        /// <summary>The avatar can see the location of the target avatar on the map</summary>
-        CanSeeOnMap = 2,
-        /// <summary>The avatar can modify the ojects of the target avatar </summary>
-        CanModifyObjects = 4
-    }
-
-    /// <summary>
-    /// This class holds information about an avatar in the friends list.  There are two ways 
-    /// to interface to this class.  The first is through the set of boolean properties.  This is the typical
-    /// way clients of this class will use it.  The second interface is through two bitflag properties,
-    /// TheirFriendsRights and MyFriendsRights
-    /// </summary>
-    public class FriendInfo
-    {
-        private UUID m_id;
-        private string m_name;
-        private bool m_isOnline;
-        private bool m_canSeeMeOnline;
-        private bool m_canSeeMeOnMap;
-        private bool m_canModifyMyObjects;
-        private bool m_canSeeThemOnline;
-        private bool m_canSeeThemOnMap;
-        private bool m_canModifyTheirObjects;
-
-        #region Properties
-
-        /// <summary>
-        /// System ID of the avatar
-        /// </summary>
-        public UUID UUID { get { return m_id; } }
-
-        /// <summary>
-        /// full name of the avatar
-        /// </summary>
-        public string Name
-        {
-            get { return m_name; }
-            set { m_name = value; }
-        }
-
-        /// <summary>
-        /// True if the avatar is online
-        /// </summary>
-        public bool IsOnline
-        {
-            get { return m_isOnline; }
-            set { m_isOnline = value; }
-        }
-
-        /// <summary>
-        /// True if the friend can see if I am online
-        /// </summary>
-        public bool CanSeeMeOnline
-        {
-            get { return m_canSeeMeOnline; }
-            set
-            {
-                m_canSeeMeOnline = value;
-
-                // if I can't see them online, then I can't see them on the map
-                if (!m_canSeeMeOnline)
-                    m_canSeeMeOnMap = false;
-            }
-        }
-
-        /// <summary>
-        /// True if the friend can see me on the map 
-        /// </summary>
-        public bool CanSeeMeOnMap
-        {
-            get { return m_canSeeMeOnMap; }
-            set
-            {
-                // if I can't see them online, then I can't see them on the map
-                if (m_canSeeMeOnline)
-                    m_canSeeMeOnMap = value;
-            }
-        }
-
-        /// <summary>
-        /// True if the freind can modify my objects
-        /// </summary>
-        public bool CanModifyMyObjects
-        {
-            get { return m_canModifyMyObjects; }
-            set { m_canModifyMyObjects = value; }
-        }
-
-        /// <summary>
-        /// True if I can see if my friend is online
-        /// </summary>
-        public bool CanSeeThemOnline { get { return m_canSeeThemOnline; } }
-
-        /// <summary>
-        /// True if I can see if my friend is on the map
-        /// </summary>
-        public bool CanSeeThemOnMap { get { return m_canSeeThemOnMap; } }
-
-        /// <summary>
-        /// True if I can modify my friend's objects
-        /// </summary>
-        public bool CanModifyTheirObjects { get { return m_canModifyTheirObjects; } }
-
-        /// <summary>
-        /// My friend's rights represented as bitmapped flags
-        /// </summary>
-        public FriendRights TheirFriendRights
-        {
-            get
-            {
-                FriendRights results = FriendRights.None;
-                if (m_canSeeMeOnline)
-                    results |= FriendRights.CanSeeOnline;
-                if (m_canSeeMeOnMap)
-                    results |= FriendRights.CanSeeOnMap;
-                if (m_canModifyMyObjects)
-                    results |= FriendRights.CanModifyObjects;
-
-                return results;
-            }
-            set
-            {
-                m_canSeeMeOnline = (value & FriendRights.CanSeeOnline) != 0;
-                m_canSeeMeOnMap = (value & FriendRights.CanSeeOnMap) != 0;
-                m_canModifyMyObjects = (value & FriendRights.CanModifyObjects) != 0;
-            }
-        }
-
-        /// <summary>
-        /// My rights represented as bitmapped flags
-        /// </summary>
-        public FriendRights MyFriendRights
-        {
-            get
-            {
-                FriendRights results = FriendRights.None;
-                if (m_canSeeThemOnline)
-                    results |= FriendRights.CanSeeOnline;
-                if (m_canSeeThemOnMap)
-                    results |= FriendRights.CanSeeOnMap;
-                if (m_canModifyTheirObjects)
-                    results |= FriendRights.CanModifyObjects;
-
-                return results;
-            }
-            set
-            {
-                m_canSeeThemOnline = (value & FriendRights.CanSeeOnline) != 0;
-                m_canSeeThemOnMap = (value & FriendRights.CanSeeOnMap) != 0;
-                m_canModifyTheirObjects = (value & FriendRights.CanModifyObjects) != 0;
-            }
-        }
-
-        #endregion Properties
-
-        /// <summary>
-        /// Used internally when building the initial list of friends at login time
-        /// </summary>
-        /// <param name="id">System ID of the avatar being prepesented</param>
-        /// <param name="theirRights">Rights the friend has to see you online and to modify your objects</param>
-        /// <param name="myRights">Rights you have to see your friend online and to modify their objects</param>
-        internal FriendInfo(UUID id, FriendRights theirRights, FriendRights myRights)
-        {
-            m_id = id;
-            m_canSeeMeOnline = (theirRights & FriendRights.CanSeeOnline) != 0;
-            m_canSeeMeOnMap = (theirRights & FriendRights.CanSeeOnMap) != 0;
-            m_canModifyMyObjects = (theirRights & FriendRights.CanModifyObjects) != 0;
-
-            m_canSeeThemOnline = (myRights & FriendRights.CanSeeOnline) != 0;
-            m_canSeeThemOnMap = (myRights & FriendRights.CanSeeOnMap) != 0;
-            m_canModifyTheirObjects = (myRights & FriendRights.CanModifyObjects) != 0;
-        }
-
-        /// <summary>
-        /// FriendInfo represented as a string
-        /// </summary>
-        /// <returns>A string reprentation of both my rights and my friends rights</returns>
-        public override string ToString()
-        {
-            if (!String.IsNullOrEmpty(m_name))
-                return String.Format("{0} (Their Rights: {1}, My Rights: {2})", m_name, TheirFriendRights,
-                    MyFriendRights);
-            else
-                return String.Format("{0} (Their Rights: {1}, My Rights: {2})", m_id, TheirFriendRights,
-                    MyFriendRights);
-        }
-    }
-
-    /// <summary>
-    /// This class is used to add and remove avatars from your friends list and to manage their permission.  
-    /// </summary>
-    public class FriendsManager
-    {
-        #region Delegates
-
-        /// <summary>
-        /// Triggered when an avatar in your friends list comes online
-        /// </summary>
-        /// <param name="friend"> System ID of the avatar</param>
-        public delegate void FriendOnlineEvent(FriendInfo friend);
-        /// <summary>
-        /// Triggered when an avatar in your friends list goes offline
-        /// </summary>
-        /// <param name="friend"> System ID of the avatar</param>
-        public delegate void FriendOfflineEvent(FriendInfo friend);
-        /// <summary>
-        /// Triggered in response to a call to the FriendRights() method, or when a friend changes your rights
-        /// </summary>
-        /// <param name="friend"> System ID of the avatar you changed the right of</param>
-        public delegate void FriendRightsEvent(FriendInfo friend);
-        /// <summary>
-        /// Triggered when names on the friend list are received after the initial request upon login
-        /// </summary>
-        /// <param name="names"></param>
-        public delegate void FriendNamesReceived(Dictionary<UUID, string> names);
-        /// <summary>
-        /// Triggered when someone offers you friendship
-        /// </summary>
-        /// <param name="agentID">System ID of the agent offering friendship</param>
-        /// <param name="agentName">full name of the agent offereing friendship</param>
-        /// <param name="imSessionID">session ID need when accepting/declining the offer</param>
-        /// <returns>Return true to accept the friendship, false to deny it</returns>
-        public delegate void FriendshipOfferedEvent(UUID agentID, string agentName, UUID imSessionID);
-        /// <summary>
-        /// Trigger when your friendship offer has been accepted or declined
-        /// </summary>
-        /// <param name="agentID">System ID of the avatar who accepted your friendship offer</param>
-        /// <param name="agentName">Full name of the avatar who accepted your friendship offer</param>
-        /// <param name="accepted">Whether the friendship request was accepted or declined</param>
-        public delegate void FriendshipResponseEvent(UUID agentID, string agentName, bool accepted);
-        /// <summary>
-        /// Trigger when someone terminates your friendship.
-        /// </summary>
-        /// <param name="agentID">System ID of the avatar who terminated your friendship</param>
-        /// <param name="agentName">Full name of the avatar who terminated your friendship</param>
-        public delegate void FriendshipTerminatedEvent(UUID agentID, string agentName);
-
-        /// <summary>
-        /// Triggered in response to a FindFriend request
-        /// </summary>
-        /// <param name="agentID">Friends Key</param>
-        /// <param name="regionHandle">region handle friend is in</param>
-        /// <param name="location">X/Y location of friend</param>
-        public delegate void FriendFoundEvent(UUID agentID, ulong regionHandle, Vector3 location);
-
-        #endregion Delegates
-
-        #region Events
-
-        public event FriendNamesReceived OnFriendNamesReceived;
-        public event FriendOnlineEvent OnFriendOnline;
-        public event FriendOfflineEvent OnFriendOffline;
-        public event FriendRightsEvent OnFriendRights;
-        public event FriendshipOfferedEvent OnFriendshipOffered;
-        public event FriendshipResponseEvent OnFriendshipResponse;
-        public event FriendshipTerminatedEvent OnFriendshipTerminated;
-        public event FriendFoundEvent OnFriendFound;
-
-        #endregion Events
-
-        private GridClient Client;
-        /// <summary>
-        /// A dictionary of key/value pairs containing known friends of this avatar. 
-        /// 
-        /// The Key is the <seealso cref="UUID"/> of the friend, the value is a <seealso cref="FriendInfo"/>
-        /// object that contains detailed information including permissions you have and have given to the friend
-        /// </summary>
-        public InternalDictionary<UUID, FriendInfo> FriendList = new InternalDictionary<UUID, FriendInfo>();
-
-        /// <summary>
-        /// A Dictionary of key/value pairs containing current pending frienship offers.
-        /// 
-        /// The key is the <seealso cref="UUID"/> of the avatar making the request, 
-        /// the value is the <seealso cref="UUID"/> of the request which is used to accept
-        /// or decline the friendship offer
-        /// </summary>
-        public InternalDictionary<UUID, UUID> FriendRequests = new InternalDictionary<UUID, UUID>();
-
-        /// <summary>
-        /// Internal constructor
-        /// </summary>
-        /// <param name="client">A reference to the GridClient Object</param>
-        internal FriendsManager(GridClient client)
-        {
-            Client = client;
-
-            Client.Network.OnConnected += new NetworkManager.ConnectedCallback(Network_OnConnect);
-            Client.Avatars.OnAvatarNames += new AvatarManager.AvatarNamesCallback(Avatars_OnAvatarNames);
-            Client.Self.OnInstantMessage += new AgentManager.InstantMessageCallback(MainAvatar_InstantMessage);
-
-            Client.Network.RegisterCallback(PacketType.OnlineNotification, OnlineNotificationHandler);
-            Client.Network.RegisterCallback(PacketType.OfflineNotification, OfflineNotificationHandler);
-            Client.Network.RegisterCallback(PacketType.ChangeUserRights, ChangeUserRightsHandler);
-            Client.Network.RegisterCallback(PacketType.TerminateFriendship, TerminateFriendshipHandler);
-            Client.Network.RegisterCallback(PacketType.FindAgent, OnFindAgentReplyHandler);
-
-            Client.Network.RegisterLoginResponseCallback(new NetworkManager.LoginResponseCallback(Network_OnLoginResponse),
-                new string[] { "buddy-list" });
-        }
-        #region Public Methods
-        
-        /// <summary>
-        /// Accept a friendship request
-        /// </summary>
-        /// <param name="fromAgentID">agentID of avatatar to form friendship with</param>
-        /// <param name="imSessionID">imSessionID of the friendship request message</param>
-        public void AcceptFriendship(UUID fromAgentID, UUID imSessionID)
-        {
-            UUID callingCardFolder = Client.Inventory.FindFolderForType(AssetType.CallingCard);
-
-            AcceptFriendshipPacket request = new AcceptFriendshipPacket();
-            request.AgentData.AgentID = Client.Self.AgentID;
-            request.AgentData.SessionID = Client.Self.SessionID;
-            request.TransactionBlock.TransactionID = imSessionID;
-            request.FolderData = new AcceptFriendshipPacket.FolderDataBlock[1];
-            request.FolderData[0] = new AcceptFriendshipPacket.FolderDataBlock();
-            request.FolderData[0].FolderID = callingCardFolder;
-
-            Client.Network.SendPacket(request);
-
-            FriendInfo friend = new FriendInfo(fromAgentID, FriendRights.CanSeeOnline,
-                FriendRights.CanSeeOnline);
-            lock (FriendList)
-            {
-                if(!FriendList.ContainsKey(fromAgentID))  FriendList.Add(friend.UUID, friend);
-            }
-            lock (FriendRequests) { if (FriendRequests.ContainsKey(fromAgentID)) FriendRequests.Remove(fromAgentID); }
-
-            Client.Avatars.RequestAvatarName(fromAgentID);
-        }
-
-        /// <summary>
-        /// Decline a friendship request
-        /// </summary>
-        /// <param name="fromAgentID"><seealso cref="UUID"/> of friend</param>
-        /// <param name="imSessionID">imSessionID of the friendship request message</param>
-        public void DeclineFriendship(UUID fromAgentID, UUID imSessionID)
-        {
-            DeclineFriendshipPacket request = new DeclineFriendshipPacket();
-            request.AgentData.AgentID = Client.Self.AgentID;
-            request.AgentData.SessionID = Client.Self.SessionID;
-            request.TransactionBlock.TransactionID = imSessionID;
-            Client.Network.SendPacket(request);
-
-            lock (FriendRequests) { if (FriendRequests.ContainsKey(fromAgentID)) FriendRequests.Remove(fromAgentID); }
-        }
-
-        /// <summary>
-        /// Offer friendship to an avatar.
-        /// </summary>
-        /// <param name="agentID">System ID of the avatar you are offering friendship to</param>
-        public void OfferFriendship(UUID agentID)
-        {
-            // HACK: folder id stored as "message"
-            UUID callingCardFolder = Client.Inventory.FindFolderForType(AssetType.CallingCard);
-            Client.Self.InstantMessage(Client.Self.Name,
-                agentID,
-                callingCardFolder.ToString(),
-                UUID.Random(),
-                InstantMessageDialog.FriendshipOffered,
-                InstantMessageOnline.Online,
-                Client.Self.SimPosition,
-                Client.Network.CurrentSim.ID,
-                new byte[0]);
-        }
-
-
-        /// <summary>
-        /// Terminate a friendship with an avatar
-        /// </summary>
-        /// <param name="agentID">System ID of the avatar you are terminating the friendship with</param>
-        public void TerminateFriendship(UUID agentID)
-        {
-            if (FriendList.ContainsKey(agentID))
-            {
-                TerminateFriendshipPacket request = new TerminateFriendshipPacket();
-                request.AgentData.AgentID = Client.Self.AgentID;
-                request.AgentData.SessionID = Client.Self.SessionID;
-                request.ExBlock.OtherID = agentID;
-
-                Client.Network.SendPacket(request);
-
-                lock (FriendList)
-                {
-                    if (FriendList.ContainsKey(agentID))
-                        FriendList.Remove(agentID);
-                }
-            }
-        }
-        /// <summary>
-        /// Fired when another friend terminates friendship. We need to remove them from
-        /// our cached list.
-        /// </summary>
-        /// <param name="packet"></param>
-        /// <param name="simulator"></param>
-        private void TerminateFriendshipHandler(Packet packet, Simulator simulator)
-        {
-            TerminateFriendshipPacket itsOver = (TerminateFriendshipPacket)packet;
-            string name = String.Empty;
-            lock (FriendList)
-            {
-                if (FriendList.ContainsKey(itsOver.ExBlock.OtherID))
-                {
-                    name = FriendList[itsOver.ExBlock.OtherID].Name;
-                    FriendList.Remove(itsOver.ExBlock.OtherID);
-                }
-            }
-            if (OnFriendshipTerminated != null)
-            {
-                OnFriendshipTerminated(itsOver.ExBlock.OtherID, name);
-            }
-        }
-
-        /// <summary>
-        /// Change the rights of a friend avatar.
-        /// </summary>
-        /// <param name="friendID">the <seealso cref="UUID"/> of the friend</param>
-        /// <param name="rights">the new rights to give the friend</param>
-        /// <remarks>This method will implicitly set the rights to those passed in the rights parameter.</remarks>
-        public void GrantRights(UUID friendID, FriendRights rights)
-        {
-            GrantUserRightsPacket request = new GrantUserRightsPacket();
-            request.AgentData.AgentID = Client.Self.AgentID;
-            request.AgentData.SessionID = Client.Self.SessionID;
-            request.Rights = new GrantUserRightsPacket.RightsBlock[1];
-            request.Rights[0] = new GrantUserRightsPacket.RightsBlock();
-            request.Rights[0].AgentRelated = friendID;
-            request.Rights[0].RelatedRights = (int)rights;
-
-            Client.Network.SendPacket(request);
-        }
-
-        /// <summary>
-        /// Use to map a friends location on the grid.
-        /// </summary>
-        /// <param name="friendID">Friends UUID to find</param>
-        /// <remarks><seealso cref="E:OnFriendFound"/></remarks>
-        public void MapFriend(UUID friendID)
-        {
-            FindAgentPacket stalk = new FindAgentPacket();
-            stalk.AgentBlock.Hunter = Client.Self.AgentID;
-            stalk.AgentBlock.Prey = friendID;
-
-            Client.Network.SendPacket(stalk);
-        }
-
-        /// <summary>
-        /// Use to track a friends movement on the grid
-        /// </summary>
-        /// <param name="friendID">Friends Key</param>
-        public void TrackFriend(UUID friendID)
-        {
-            TrackAgentPacket stalk = new TrackAgentPacket();
-            stalk.AgentData.AgentID = Client.Self.AgentID;
-            stalk.AgentData.SessionID = Client.Self.SessionID;
-            stalk.TargetData.PreyID = friendID;
-
-            Client.Network.SendPacket(stalk);
-        }
-
-        #endregion
-        #region Internal events
-        /// <summary>
-        /// Called when a connection to the SL server is established.  The list of friend avatars 
-        /// is populated from XML returned by the login server.  That list contains the avatar's id 
-        /// and right, but no names.  Here is where those names are requested.
-        /// </summary>
-        /// <param name="sender"></param>
-        private void Network_OnConnect(object sender)
-        {
-            List<UUID> names = new List<UUID>();
-
-            if ( FriendList.Count > 0 )
-            {
-                lock (FriendList)
-                {
-                    foreach (KeyValuePair<UUID, FriendInfo> kvp in FriendList.Dictionary)
-                    {
-                        if (String.IsNullOrEmpty(kvp.Value.Name))
-                            names.Add(kvp.Key);
-                    }
-                }
-
-                Client.Avatars.RequestAvatarNames(names);
-            }
-        }
-
-
-        /// <summary>
-        /// This handles the asynchronous response of a RequestAvatarNames call.
-        /// </summary>
-        /// <param name="names">names cooresponding to the the list of IDs sent the the RequestAvatarNames call.</param>
-        private void Avatars_OnAvatarNames(Dictionary<UUID, string> names)
-        {
-            lock (FriendList)
-            {
-                Dictionary<UUID, string> newNames = new Dictionary<UUID, string>();
-                foreach (KeyValuePair<UUID, string> kvp in names)
-                {
-                    if (FriendList.ContainsKey(kvp.Key))
-                    {
-                        if (FriendList[kvp.Key].Name == null)
-                            newNames.Add(kvp.Key, names[kvp.Key]);
-
-                        FriendList[kvp.Key].Name = names[kvp.Key];
-                    }
-                }
-                if (newNames.Count > 0 && OnFriendNamesReceived != null)
-                {
-                    try { OnFriendNamesReceived(newNames); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-            }
-        }
-        #endregion
-        #region Packet Handlers
-
-        /// <summary>
-        /// Handle notifications sent when a friends has come online.
-        /// </summary>
-        /// <param name="packet"></param>
-        /// <param name="simulator"></param>
-        private void OnlineNotificationHandler(Packet packet, Simulator simulator)
-        {
-            if (packet.Type == PacketType.OnlineNotification)
-            {
-                OnlineNotificationPacket notification = ((OnlineNotificationPacket)packet);
-
-                foreach (OnlineNotificationPacket.AgentBlockBlock block in notification.AgentBlock)
-                {
-                    FriendInfo friend;
-
-                    lock (FriendList)
-                    {
-                        if (!FriendList.ContainsKey(block.AgentID))
-                        {
-                            friend = new FriendInfo(block.AgentID, FriendRights.CanSeeOnline,
-                                FriendRights.CanSeeOnline);
-                            FriendList.Add(block.AgentID, friend);
-                        }
-                        else
-                        {
-                            friend = FriendList[block.AgentID];
-                        }
-                    }
-
-                    bool doNotify = !friend.IsOnline;
-                    friend.IsOnline = true;
-
-                    if (OnFriendOnline != null && doNotify)
-                    {
-                        try { OnFriendOnline(friend); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                    }
-                }
-            }
-        }
-
-
-        /// <summary>
-        /// Handle notifications sent when a friends has gone offline.
-        /// </summary>
-        /// <param name="packet"></param>
-        /// <param name="simulator"></param>
-        private void OfflineNotificationHandler(Packet packet, Simulator simulator)
-        {
-            if (packet.Type == PacketType.OfflineNotification)
-            {
-                OfflineNotificationPacket notification = ((OfflineNotificationPacket)packet);
-
-                foreach (OfflineNotificationPacket.AgentBlockBlock block in notification.AgentBlock)
-                {
-                    FriendInfo friend;
-
-                    lock (FriendList)
-                    {
-                        if (!FriendList.ContainsKey(block.AgentID))
-                            FriendList.Add(block.AgentID, new FriendInfo(block.AgentID, FriendRights.CanSeeOnline, FriendRights.CanSeeOnline));
-
-                        friend = FriendList[block.AgentID];
-                        friend.IsOnline = false;
-                    }
-
-                    if (OnFriendOffline != null)
-                    {
-                        try { OnFriendOffline(friend); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                    }
-                }
-            }
-        }
-
-
-        /// <summary>
-        /// Handle notifications sent when a friend rights change.  This notification is also received
-        /// when my own rights change.
-        /// </summary>
-        /// <param name="packet"></param>
-        /// <param name="simulator"></param>
-        private void ChangeUserRightsHandler(Packet packet, Simulator simulator)
-        {
-            if (packet.Type == PacketType.ChangeUserRights)
-            {
-                FriendInfo friend;
-                ChangeUserRightsPacket rights = (ChangeUserRightsPacket)packet;
-
-                foreach (ChangeUserRightsPacket.RightsBlock block in rights.Rights)
-                {
-                    FriendRights newRights = (FriendRights)block.RelatedRights;
-                    if (FriendList.TryGetValue(block.AgentRelated, out friend))
-                    {
-                        friend.TheirFriendRights = newRights;
-                        if (OnFriendRights != null)
-                        {
-                            try { OnFriendRights(friend); }
-                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                        }
-                    }
-                    else if (block.AgentRelated == Client.Self.AgentID)
-                    {
-                        if (FriendList.TryGetValue(rights.AgentData.AgentID, out friend))
-                        {
-                            friend.MyFriendRights = newRights;
-                            if (OnFriendRights != null)
-                            {
-                                try { OnFriendRights(friend); }
-                                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Handle friend location updates
-        /// </summary>
-        /// <param name="packet">The Packet</param>
-        /// <param name="simulator">The Simulator</param>
-        public void OnFindAgentReplyHandler(Packet packet, Simulator simulator)
-        {
-            if(OnFriendFound != null)
-            {
-            FindAgentPacket reply = (FindAgentPacket)packet;
-
-            float x,y;
-            UUID prey = reply.AgentBlock.Prey;
-            ulong regionHandle = Helpers.GlobalPosToRegionHandle((float)reply.LocationBlock[0].GlobalX, 
-                (float)reply.LocationBlock[0].GlobalY, out x, out y);
-            Vector3 xyz = new Vector3(x, y, 0f);
-
-            try { OnFriendFound(prey, regionHandle, xyz); }
-            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        #endregion
-
-        /// <summary>
-        /// Handles relevant messages from the server encapsulated in instant messages.
-        /// </summary>
-        /// <param name="im">InstantMessage object containing encapsalated instant message</param>
-        /// <param name="simulator">Originating Simulator</param>
-        private void MainAvatar_InstantMessage(InstantMessage im, Simulator simulator)
-        {
-            if (im.Dialog == InstantMessageDialog.FriendshipOffered)
-            {
-                if (OnFriendshipOffered != null)
-                {
-                    lock (FriendRequests)
-                    {
-                        if (FriendRequests.ContainsKey(im.FromAgentID))
-                        	FriendRequests[im.FromAgentID] = im.IMSessionID;
-                        else
-                        	FriendRequests.Add(im.FromAgentID, im.IMSessionID);
-                    }
-                    try { OnFriendshipOffered(im.FromAgentID, im.FromAgentName, im.IMSessionID); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-            }
-            else if (im.Dialog == InstantMessageDialog.FriendshipAccepted)
-            {
-                FriendInfo friend = new FriendInfo(im.FromAgentID, FriendRights.CanSeeOnline,
-                    FriendRights.CanSeeOnline);
-                friend.Name = im.FromAgentName;
-                lock (FriendList) FriendList[friend.UUID] = friend;
-
-                if (OnFriendshipResponse != null)
-                {
-                    try { OnFriendshipResponse(im.FromAgentID, im.FromAgentName, true); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-            }
-            else if (im.Dialog == InstantMessageDialog.FriendshipDeclined)
-            {
-                if (OnFriendshipResponse != null)
-                {
-                    try { OnFriendshipResponse(im.FromAgentID, im.FromAgentName, false); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-            }
-        }
-
-        private void Network_OnLoginResponse(bool loginSuccess, bool redirect, string message, string reason,
-            LoginResponseData replyData)
-        {
-            if (loginSuccess && replyData.BuddyList != null)
-            {
-                lock (FriendList)
-                {
-                    for (int i = 0; i < replyData.BuddyList.Length; i++)
-                    {
-                        FriendInfo friend = replyData.BuddyList[i];
-                        FriendList[friend.UUID] = friend;
-                    }
-                }
-            }
-        }
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using OpenMetaverse.Packets;
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// 
+    /// </summary>
+    [Flags]
+    public enum FriendRights : int
+    {
+        /// <summary>The avatar has no rights</summary>
+        None = 0,
+        /// <summary>The avatar can see the online status of the target avatar</summary>
+        CanSeeOnline = 1,
+        /// <summary>The avatar can see the location of the target avatar on the map</summary>
+        CanSeeOnMap = 2,
+        /// <summary>The avatar can modify the ojects of the target avatar </summary>
+        CanModifyObjects = 4
+    }
+
+    /// <summary>
+    /// This class holds information about an avatar in the friends list.  There are two ways 
+    /// to interface to this class.  The first is through the set of boolean properties.  This is the typical
+    /// way clients of this class will use it.  The second interface is through two bitflag properties,
+    /// TheirFriendsRights and MyFriendsRights
+    /// </summary>
+    public class FriendInfo
+    {
+        private UUID m_id;
+        private string m_name;
+        private bool m_isOnline;
+        private bool m_canSeeMeOnline;
+        private bool m_canSeeMeOnMap;
+        private bool m_canModifyMyObjects;
+        private bool m_canSeeThemOnline;
+        private bool m_canSeeThemOnMap;
+        private bool m_canModifyTheirObjects;
+
+        #region Properties
+
+        /// <summary>
+        /// System ID of the avatar
+        /// </summary>
+        public UUID UUID { get { return m_id; } }
+
+        /// <summary>
+        /// full name of the avatar
+        /// </summary>
+        public string Name
+        {
+            get { return m_name; }
+            set { m_name = value; }
+        }
+
+        /// <summary>
+        /// True if the avatar is online
+        /// </summary>
+        public bool IsOnline
+        {
+            get { return m_isOnline; }
+            set { m_isOnline = value; }
+        }
+
+        /// <summary>
+        /// True if the friend can see if I am online
+        /// </summary>
+        public bool CanSeeMeOnline
+        {
+            get { return m_canSeeMeOnline; }
+            set
+            {
+                m_canSeeMeOnline = value;
+
+                // if I can't see them online, then I can't see them on the map
+                if (!m_canSeeMeOnline)
+                    m_canSeeMeOnMap = false;
+            }
+        }
+
+        /// <summary>
+        /// True if the friend can see me on the map 
+        /// </summary>
+        public bool CanSeeMeOnMap
+        {
+            get { return m_canSeeMeOnMap; }
+            set
+            {
+                // if I can't see them online, then I can't see them on the map
+                if (m_canSeeMeOnline)
+                    m_canSeeMeOnMap = value;
+            }
+        }
+
+        /// <summary>
+        /// True if the freind can modify my objects
+        /// </summary>
+        public bool CanModifyMyObjects
+        {
+            get { return m_canModifyMyObjects; }
+            set { m_canModifyMyObjects = value; }
+        }
+
+        /// <summary>
+        /// True if I can see if my friend is online
+        /// </summary>
+        public bool CanSeeThemOnline { get { return m_canSeeThemOnline; } }
+
+        /// <summary>
+        /// True if I can see if my friend is on the map
+        /// </summary>
+        public bool CanSeeThemOnMap { get { return m_canSeeThemOnMap; } }
+
+        /// <summary>
+        /// True if I can modify my friend's objects
+        /// </summary>
+        public bool CanModifyTheirObjects { get { return m_canModifyTheirObjects; } }
+
+        /// <summary>
+        /// My friend's rights represented as bitmapped flags
+        /// </summary>
+        public FriendRights TheirFriendRights
+        {
+            get
+            {
+                FriendRights results = FriendRights.None;
+                if (m_canSeeMeOnline)
+                    results |= FriendRights.CanSeeOnline;
+                if (m_canSeeMeOnMap)
+                    results |= FriendRights.CanSeeOnMap;
+                if (m_canModifyMyObjects)
+                    results |= FriendRights.CanModifyObjects;
+
+                return results;
+            }
+            set
+            {
+                m_canSeeMeOnline = (value & FriendRights.CanSeeOnline) != 0;
+                m_canSeeMeOnMap = (value & FriendRights.CanSeeOnMap) != 0;
+                m_canModifyMyObjects = (value & FriendRights.CanModifyObjects) != 0;
+            }
+        }
+
+        /// <summary>
+        /// My rights represented as bitmapped flags
+        /// </summary>
+        public FriendRights MyFriendRights
+        {
+            get
+            {
+                FriendRights results = FriendRights.None;
+                if (m_canSeeThemOnline)
+                    results |= FriendRights.CanSeeOnline;
+                if (m_canSeeThemOnMap)
+                    results |= FriendRights.CanSeeOnMap;
+                if (m_canModifyTheirObjects)
+                    results |= FriendRights.CanModifyObjects;
+
+                return results;
+            }
+            set
+            {
+                m_canSeeThemOnline = (value & FriendRights.CanSeeOnline) != 0;
+                m_canSeeThemOnMap = (value & FriendRights.CanSeeOnMap) != 0;
+                m_canModifyTheirObjects = (value & FriendRights.CanModifyObjects) != 0;
+            }
+        }
+
+        #endregion Properties
+
+        /// <summary>
+        /// Used internally when building the initial list of friends at login time
+        /// </summary>
+        /// <param name="id">System ID of the avatar being prepesented</param>
+        /// <param name="theirRights">Rights the friend has to see you online and to modify your objects</param>
+        /// <param name="myRights">Rights you have to see your friend online and to modify their objects</param>
+        internal FriendInfo(UUID id, FriendRights theirRights, FriendRights myRights)
+        {
+            m_id = id;
+            m_canSeeMeOnline = (theirRights & FriendRights.CanSeeOnline) != 0;
+            m_canSeeMeOnMap = (theirRights & FriendRights.CanSeeOnMap) != 0;
+            m_canModifyMyObjects = (theirRights & FriendRights.CanModifyObjects) != 0;
+
+            m_canSeeThemOnline = (myRights & FriendRights.CanSeeOnline) != 0;
+            m_canSeeThemOnMap = (myRights & FriendRights.CanSeeOnMap) != 0;
+            m_canModifyTheirObjects = (myRights & FriendRights.CanModifyObjects) != 0;
+        }
+
+        /// <summary>
+        /// FriendInfo represented as a string
+        /// </summary>
+        /// <returns>A string reprentation of both my rights and my friends rights</returns>
+        public override string ToString()
+        {
+            if (!String.IsNullOrEmpty(m_name))
+                return String.Format("{0} (Their Rights: {1}, My Rights: {2})", m_name, TheirFriendRights,
+                    MyFriendRights);
+            else
+                return String.Format("{0} (Their Rights: {1}, My Rights: {2})", m_id, TheirFriendRights,
+                    MyFriendRights);
+        }
+    }
+
+    /// <summary>
+    /// This class is used to add and remove avatars from your friends list and to manage their permission.  
+    /// </summary>
+    public class FriendsManager
+    {
+        #region Delegates
+
+        /// <summary>
+        /// Triggered when an avatar in your friends list comes online
+        /// </summary>
+        /// <param name="friend"> System ID of the avatar</param>
+        public delegate void FriendOnlineEvent(FriendInfo friend);
+        /// <summary>
+        /// Triggered when an avatar in your friends list goes offline
+        /// </summary>
+        /// <param name="friend"> System ID of the avatar</param>
+        public delegate void FriendOfflineEvent(FriendInfo friend);
+        /// <summary>
+        /// Triggered in response to a call to the FriendRights() method, or when a friend changes your rights
+        /// </summary>
+        /// <param name="friend"> System ID of the avatar you changed the right of</param>
+        public delegate void FriendRightsEvent(FriendInfo friend);
+        /// <summary>
+        /// Triggered when names on the friend list are received after the initial request upon login
+        /// </summary>
+        /// <param name="names"></param>
+        public delegate void FriendNamesReceived(Dictionary<UUID, string> names);
+        /// <summary>
+        /// Triggered when someone offers you friendship
+        /// </summary>
+        /// <param name="agentID">System ID of the agent offering friendship</param>
+        /// <param name="agentName">full name of the agent offereing friendship</param>
+        /// <param name="imSessionID">session ID need when accepting/declining the offer</param>
+        /// <returns>Return true to accept the friendship, false to deny it</returns>
+        public delegate void FriendshipOfferedEvent(UUID agentID, string agentName, UUID imSessionID);
+        /// <summary>
+        /// Trigger when your friendship offer has been accepted or declined
+        /// </summary>
+        /// <param name="agentID">System ID of the avatar who accepted your friendship offer</param>
+        /// <param name="agentName">Full name of the avatar who accepted your friendship offer</param>
+        /// <param name="accepted">Whether the friendship request was accepted or declined</param>
+        public delegate void FriendshipResponseEvent(UUID agentID, string agentName, bool accepted);
+        /// <summary>
+        /// Trigger when someone terminates your friendship.
+        /// </summary>
+        /// <param name="agentID">System ID of the avatar who terminated your friendship</param>
+        /// <param name="agentName">Full name of the avatar who terminated your friendship</param>
+        public delegate void FriendshipTerminatedEvent(UUID agentID, string agentName);
+
+        /// <summary>
+        /// Triggered in response to a FindFriend request
+        /// </summary>
+        /// <param name="agentID">Friends Key</param>
+        /// <param name="regionHandle">region handle friend is in</param>
+        /// <param name="location">X/Y location of friend</param>
+        public delegate void FriendFoundEvent(UUID agentID, ulong regionHandle, Vector3 location);
+
+        #endregion Delegates
+
+        #region Events
+
+        public event FriendNamesReceived OnFriendNamesReceived;
+        public event FriendOnlineEvent OnFriendOnline;
+        public event FriendOfflineEvent OnFriendOffline;
+        public event FriendRightsEvent OnFriendRights;
+        public event FriendshipOfferedEvent OnFriendshipOffered;
+        public event FriendshipResponseEvent OnFriendshipResponse;
+        public event FriendshipTerminatedEvent OnFriendshipTerminated;
+        public event FriendFoundEvent OnFriendFound;
+
+        #endregion Events
+
+        private GridClient Client;
+        /// <summary>
+        /// A dictionary of key/value pairs containing known friends of this avatar. 
+        /// 
+        /// The Key is the <seealso cref="UUID"/> of the friend, the value is a <seealso cref="FriendInfo"/>
+        /// object that contains detailed information including permissions you have and have given to the friend
+        /// </summary>
+        public InternalDictionary<UUID, FriendInfo> FriendList = new InternalDictionary<UUID, FriendInfo>();
+
+        /// <summary>
+        /// A Dictionary of key/value pairs containing current pending frienship offers.
+        /// 
+        /// The key is the <seealso cref="UUID"/> of the avatar making the request, 
+        /// the value is the <seealso cref="UUID"/> of the request which is used to accept
+        /// or decline the friendship offer
+        /// </summary>
+        public InternalDictionary<UUID, UUID> FriendRequests = new InternalDictionary<UUID, UUID>();
+
+        /// <summary>
+        /// Internal constructor
+        /// </summary>
+        /// <param name="client">A reference to the GridClient Object</param>
+        internal FriendsManager(GridClient client)
+        {
+            Client = client;
+
+            Client.Network.OnConnected += new NetworkManager.ConnectedCallback(Network_OnConnect);
+            Client.Avatars.OnAvatarNames += new AvatarManager.AvatarNamesCallback(Avatars_OnAvatarNames);
+            Client.Self.OnInstantMessage += new AgentManager.InstantMessageCallback(MainAvatar_InstantMessage);
+
+            Client.Network.RegisterCallback(PacketType.OnlineNotification, OnlineNotificationHandler);
+            Client.Network.RegisterCallback(PacketType.OfflineNotification, OfflineNotificationHandler);
+            Client.Network.RegisterCallback(PacketType.ChangeUserRights, ChangeUserRightsHandler);
+            Client.Network.RegisterCallback(PacketType.TerminateFriendship, TerminateFriendshipHandler);
+            Client.Network.RegisterCallback(PacketType.FindAgent, OnFindAgentReplyHandler);
+
+            Client.Network.RegisterLoginResponseCallback(new NetworkManager.LoginResponseCallback(Network_OnLoginResponse),
+                new string[] { "buddy-list" });
+        }
+        #region Public Methods
+        
+        /// <summary>
+        /// Accept a friendship request
+        /// </summary>
+        /// <param name="fromAgentID">agentID of avatatar to form friendship with</param>
+        /// <param name="imSessionID">imSessionID of the friendship request message</param>
+        public void AcceptFriendship(UUID fromAgentID, UUID imSessionID)
+        {
+            UUID callingCardFolder = Client.Inventory.FindFolderForType(AssetType.CallingCard);
+
+            AcceptFriendshipPacket request = new AcceptFriendshipPacket();
+            request.AgentData.AgentID = Client.Self.AgentID;
+            request.AgentData.SessionID = Client.Self.SessionID;
+            request.TransactionBlock.TransactionID = imSessionID;
+            request.FolderData = new AcceptFriendshipPacket.FolderDataBlock[1];
+            request.FolderData[0] = new AcceptFriendshipPacket.FolderDataBlock();
+            request.FolderData[0].FolderID = callingCardFolder;
+
+            Client.Network.SendPacket(request);
+
+            FriendInfo friend = new FriendInfo(fromAgentID, FriendRights.CanSeeOnline,
+                FriendRights.CanSeeOnline);
+            lock (FriendList)
+            {
+                if(!FriendList.ContainsKey(fromAgentID))  FriendList.Add(friend.UUID, friend);
+            }
+            lock (FriendRequests) { if (FriendRequests.ContainsKey(fromAgentID)) FriendRequests.Remove(fromAgentID); }
+
+            Client.Avatars.RequestAvatarName(fromAgentID);
+        }
+
+        /// <summary>
+        /// Decline a friendship request
+        /// </summary>
+        /// <param name="fromAgentID"><seealso cref="UUID"/> of friend</param>
+        /// <param name="imSessionID">imSessionID of the friendship request message</param>
+        public void DeclineFriendship(UUID fromAgentID, UUID imSessionID)
+        {
+            DeclineFriendshipPacket request = new DeclineFriendshipPacket();
+            request.AgentData.AgentID = Client.Self.AgentID;
+            request.AgentData.SessionID = Client.Self.SessionID;
+            request.TransactionBlock.TransactionID = imSessionID;
+            Client.Network.SendPacket(request);
+
+            lock (FriendRequests) { if (FriendRequests.ContainsKey(fromAgentID)) FriendRequests.Remove(fromAgentID); }
+        }
+
+        /// <summary>
+        /// Offer friendship to an avatar.
+        /// </summary>
+        /// <param name="agentID">System ID of the avatar you are offering friendship to</param>
+        public void OfferFriendship(UUID agentID)
+        {
+            // HACK: folder id stored as "message"
+            UUID callingCardFolder = Client.Inventory.FindFolderForType(AssetType.CallingCard);
+            Client.Self.InstantMessage(Client.Self.Name,
+                agentID,
+                callingCardFolder.ToString(),
+                UUID.Random(),
+                InstantMessageDialog.FriendshipOffered,
+                InstantMessageOnline.Online,
+                Client.Self.SimPosition,
+                Client.Network.CurrentSim.ID,
+                new byte[0]);
+        }
+
+
+        /// <summary>
+        /// Terminate a friendship with an avatar
+        /// </summary>
+        /// <param name="agentID">System ID of the avatar you are terminating the friendship with</param>
+        public void TerminateFriendship(UUID agentID)
+        {
+            if (FriendList.ContainsKey(agentID))
+            {
+                TerminateFriendshipPacket request = new TerminateFriendshipPacket();
+                request.AgentData.AgentID = Client.Self.AgentID;
+                request.AgentData.SessionID = Client.Self.SessionID;
+                request.ExBlock.OtherID = agentID;
+
+                Client.Network.SendPacket(request);
+
+                lock (FriendList)
+                {
+                    if (FriendList.ContainsKey(agentID))
+                        FriendList.Remove(agentID);
+                }
+            }
+        }
+        /// <summary>
+        /// Fired when another friend terminates friendship. We need to remove them from
+        /// our cached list.
+        /// </summary>
+        /// <param name="packet"></param>
+        /// <param name="simulator"></param>
+        private void TerminateFriendshipHandler(Packet packet, Simulator simulator)
+        {
+            TerminateFriendshipPacket itsOver = (TerminateFriendshipPacket)packet;
+            string name = String.Empty;
+            lock (FriendList)
+            {
+                if (FriendList.ContainsKey(itsOver.ExBlock.OtherID))
+                {
+                    name = FriendList[itsOver.ExBlock.OtherID].Name;
+                    FriendList.Remove(itsOver.ExBlock.OtherID);
+                }
+            }
+            if (OnFriendshipTerminated != null)
+            {
+                OnFriendshipTerminated(itsOver.ExBlock.OtherID, name);
+            }
+        }
+
+        /// <summary>
+        /// Change the rights of a friend avatar.
+        /// </summary>
+        /// <param name="friendID">the <seealso cref="UUID"/> of the friend</param>
+        /// <param name="rights">the new rights to give the friend</param>
+        /// <remarks>This method will implicitly set the rights to those passed in the rights parameter.</remarks>
+        public void GrantRights(UUID friendID, FriendRights rights)
+        {
+            GrantUserRightsPacket request = new GrantUserRightsPacket();
+            request.AgentData.AgentID = Client.Self.AgentID;
+            request.AgentData.SessionID = Client.Self.SessionID;
+            request.Rights = new GrantUserRightsPacket.RightsBlock[1];
+            request.Rights[0] = new GrantUserRightsPacket.RightsBlock();
+            request.Rights[0].AgentRelated = friendID;
+            request.Rights[0].RelatedRights = (int)rights;
+
+            Client.Network.SendPacket(request);
+        }
+
+        /// <summary>
+        /// Use to map a friends location on the grid.
+        /// </summary>
+        /// <param name="friendID">Friends UUID to find</param>
+        /// <remarks><seealso cref="E:OnFriendFound"/></remarks>
+        public void MapFriend(UUID friendID)
+        {
+            FindAgentPacket stalk = new FindAgentPacket();
+            stalk.AgentBlock.Hunter = Client.Self.AgentID;
+            stalk.AgentBlock.Prey = friendID;
+
+            Client.Network.SendPacket(stalk);
+        }
+
+        /// <summary>
+        /// Use to track a friends movement on the grid
+        /// </summary>
+        /// <param name="friendID">Friends Key</param>
+        public void TrackFriend(UUID friendID)
+        {
+            TrackAgentPacket stalk = new TrackAgentPacket();
+            stalk.AgentData.AgentID = Client.Self.AgentID;
+            stalk.AgentData.SessionID = Client.Self.SessionID;
+            stalk.TargetData.PreyID = friendID;
+
+            Client.Network.SendPacket(stalk);
+        }
+
+        #endregion
+        #region Internal events
+        /// <summary>
+        /// Called when a connection to the SL server is established.  The list of friend avatars 
+        /// is populated from XML returned by the login server.  That list contains the avatar's id 
+        /// and right, but no names.  Here is where those names are requested.
+        /// </summary>
+        /// <param name="sender"></param>
+        private void Network_OnConnect(object sender)
+        {
+            List<UUID> names = new List<UUID>();
+
+            if ( FriendList.Count > 0 )
+            {
+                lock (FriendList)
+                {
+                    foreach (KeyValuePair<UUID, FriendInfo> kvp in FriendList.Dictionary)
+                    {
+                        if (String.IsNullOrEmpty(kvp.Value.Name))
+                            names.Add(kvp.Key);
+                    }
+                }
+
+                Client.Avatars.RequestAvatarNames(names);
+            }
+        }
+
+
+        /// <summary>
+        /// This handles the asynchronous response of a RequestAvatarNames call.
+        /// </summary>
+        /// <param name="names">names cooresponding to the the list of IDs sent the the RequestAvatarNames call.</param>
+        private void Avatars_OnAvatarNames(Dictionary<UUID, string> names)
+        {
+            lock (FriendList)
+            {
+                Dictionary<UUID, string> newNames = new Dictionary<UUID, string>();
+                foreach (KeyValuePair<UUID, string> kvp in names)
+                {
+                    if (FriendList.ContainsKey(kvp.Key))
+                    {
+                        if (FriendList[kvp.Key].Name == null)
+                            newNames.Add(kvp.Key, names[kvp.Key]);
+
+                        FriendList[kvp.Key].Name = names[kvp.Key];
+                    }
+                }
+                if (newNames.Count > 0 && OnFriendNamesReceived != null)
+                {
+                    try { OnFriendNamesReceived(newNames); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+            }
+        }
+        #endregion
+        #region Packet Handlers
+
+        /// <summary>
+        /// Handle notifications sent when a friends has come online.
+        /// </summary>
+        /// <param name="packet"></param>
+        /// <param name="simulator"></param>
+        private void OnlineNotificationHandler(Packet packet, Simulator simulator)
+        {
+            if (packet.Type == PacketType.OnlineNotification)
+            {
+                OnlineNotificationPacket notification = ((OnlineNotificationPacket)packet);
+
+                foreach (OnlineNotificationPacket.AgentBlockBlock block in notification.AgentBlock)
+                {
+                    FriendInfo friend;
+
+                    lock (FriendList)
+                    {
+                        if (!FriendList.ContainsKey(block.AgentID))
+                        {
+                            friend = new FriendInfo(block.AgentID, FriendRights.CanSeeOnline,
+                                FriendRights.CanSeeOnline);
+                            FriendList.Add(block.AgentID, friend);
+                        }
+                        else
+                        {
+                            friend = FriendList[block.AgentID];
+                        }
+                    }
+
+                    bool doNotify = !friend.IsOnline;
+                    friend.IsOnline = true;
+
+                    if (OnFriendOnline != null && doNotify)
+                    {
+                        try { OnFriendOnline(friend); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                    }
+                }
+            }
+        }
+
+
+        /// <summary>
+        /// Handle notifications sent when a friends has gone offline.
+        /// </summary>
+        /// <param name="packet"></param>
+        /// <param name="simulator"></param>
+        private void OfflineNotificationHandler(Packet packet, Simulator simulator)
+        {
+            if (packet.Type == PacketType.OfflineNotification)
+            {
+                OfflineNotificationPacket notification = ((OfflineNotificationPacket)packet);
+
+                foreach (OfflineNotificationPacket.AgentBlockBlock block in notification.AgentBlock)
+                {
+                    FriendInfo friend;
+
+                    lock (FriendList)
+                    {
+                        if (!FriendList.ContainsKey(block.AgentID))
+                            FriendList.Add(block.AgentID, new FriendInfo(block.AgentID, FriendRights.CanSeeOnline, FriendRights.CanSeeOnline));
+
+                        friend = FriendList[block.AgentID];
+                        friend.IsOnline = false;
+                    }
+
+                    if (OnFriendOffline != null)
+                    {
+                        try { OnFriendOffline(friend); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                    }
+                }
+            }
+        }
+
+
+        /// <summary>
+        /// Handle notifications sent when a friend rights change.  This notification is also received
+        /// when my own rights change.
+        /// </summary>
+        /// <param name="packet"></param>
+        /// <param name="simulator"></param>
+        private void ChangeUserRightsHandler(Packet packet, Simulator simulator)
+        {
+            if (packet.Type == PacketType.ChangeUserRights)
+            {
+                FriendInfo friend;
+                ChangeUserRightsPacket rights = (ChangeUserRightsPacket)packet;
+
+                foreach (ChangeUserRightsPacket.RightsBlock block in rights.Rights)
+                {
+                    FriendRights newRights = (FriendRights)block.RelatedRights;
+                    if (FriendList.TryGetValue(block.AgentRelated, out friend))
+                    {
+                        friend.TheirFriendRights = newRights;
+                        if (OnFriendRights != null)
+                        {
+                            try { OnFriendRights(friend); }
+                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                        }
+                    }
+                    else if (block.AgentRelated == Client.Self.AgentID)
+                    {
+                        if (FriendList.TryGetValue(rights.AgentData.AgentID, out friend))
+                        {
+                            friend.MyFriendRights = newRights;
+                            if (OnFriendRights != null)
+                            {
+                                try { OnFriendRights(friend); }
+                                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Handle friend location updates
+        /// </summary>
+        /// <param name="packet">The Packet</param>
+        /// <param name="simulator">The Simulator</param>
+        public void OnFindAgentReplyHandler(Packet packet, Simulator simulator)
+        {
+            if(OnFriendFound != null)
+            {
+            FindAgentPacket reply = (FindAgentPacket)packet;
+
+            float x,y;
+            UUID prey = reply.AgentBlock.Prey;
+            ulong regionHandle = Helpers.GlobalPosToRegionHandle((float)reply.LocationBlock[0].GlobalX, 
+                (float)reply.LocationBlock[0].GlobalY, out x, out y);
+            Vector3 xyz = new Vector3(x, y, 0f);
+
+            try { OnFriendFound(prey, regionHandle, xyz); }
+            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        #endregion
+
+        /// <summary>
+        /// Handles relevant messages from the server encapsulated in instant messages.
+        /// </summary>
+        /// <param name="im">InstantMessage object containing encapsalated instant message</param>
+        /// <param name="simulator">Originating Simulator</param>
+        private void MainAvatar_InstantMessage(InstantMessage im, Simulator simulator)
+        {
+            if (im.Dialog == InstantMessageDialog.FriendshipOffered)
+            {
+                if (OnFriendshipOffered != null)
+                {
+                    lock (FriendRequests)
+                    {
+                        if (FriendRequests.ContainsKey(im.FromAgentID))
+                        	FriendRequests[im.FromAgentID] = im.IMSessionID;
+                        else
+                        	FriendRequests.Add(im.FromAgentID, im.IMSessionID);
+                    }
+                    try { OnFriendshipOffered(im.FromAgentID, im.FromAgentName, im.IMSessionID); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+            }
+            else if (im.Dialog == InstantMessageDialog.FriendshipAccepted)
+            {
+                FriendInfo friend = new FriendInfo(im.FromAgentID, FriendRights.CanSeeOnline,
+                    FriendRights.CanSeeOnline);
+                friend.Name = im.FromAgentName;
+                lock (FriendList) FriendList[friend.UUID] = friend;
+
+                if (OnFriendshipResponse != null)
+                {
+                    try { OnFriendshipResponse(im.FromAgentID, im.FromAgentName, true); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+            }
+            else if (im.Dialog == InstantMessageDialog.FriendshipDeclined)
+            {
+                if (OnFriendshipResponse != null)
+                {
+                    try { OnFriendshipResponse(im.FromAgentID, im.FromAgentName, false); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+            }
+        }
+
+        private void Network_OnLoginResponse(bool loginSuccess, bool redirect, string message, string reason,
+            LoginResponseData replyData)
+        {
+            if (loginSuccess && replyData.BuddyList != null)
+            {
+                lock (FriendList)
+                {
+                    for (int i = 0; i < replyData.BuddyList.Length; i++)
+                    {
+                        FriendInfo friend = replyData.BuddyList[i];
+                        FriendList[friend.UUID] = friend;
+                    }
+                }
+            }
+        }
+    }
+}
Index: TexturePipeline.cs
===================================================================
--- TexturePipeline.cs	(revision 2445)
+++ TexturePipeline.cs	(working copy)
@@ -1,357 +1,357 @@
-/*
- * Copyright (c) 2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using System.Threading;
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// Texture request download handler, allows a configurable number of download slots
-    /// </summary>
-    public class TexturePipeline
-    {
-        class TaskInfo
-        {
-            public UUID RequestID;
-            public int RequestNbr;
-            public ImageType Type;
-
-            public TaskInfo(UUID reqID, int reqNbr, ImageType type)
-            {
-                RequestID = reqID;
-                RequestNbr = reqNbr;
-                Type = type;
-            }
-        }
-
-        public delegate void DownloadFinishedCallback(UUID id, bool success);
-        public delegate void DownloadProgressCallback(UUID image, int recieved, int total);
-
-        /// <summary>Fired when a texture download completes</summary>
-        public event DownloadFinishedCallback OnDownloadFinished;
-        /// <summary>Fired when some texture data is received</summary>
-        public event DownloadProgressCallback OnDownloadProgress;
-
-        public int CurrentCount { get { return currentRequests.Count; } }
-        public int QueuedCount { get { return requestQueue.Count; } }
-
-        GridClient client;
-        /// <summary>Maximum concurrent texture requests</summary>
-        int maxTextureRequests;
-        /// <summary>Queue for image requests that have not been sent out yet</summary>
-        List<TaskInfo> requestQueue;
-        /// <summary>Current texture downloads</summary>
-        Dictionary<UUID, int> currentRequests;
-        /// <summary>Storage for completed texture downloads</summary>
-        Dictionary<UUID, ImageDownload> completedDownloads;
-        AutoResetEvent[] resetEvents;
-        int[] threadpoolSlots;
-        Thread downloadMaster;
-        bool running;
-        object syncObject = new object();
-
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        /// <param name="client">Reference to <code>SecondLife</code> client</param>
-        /// <param name="maxRequests">Maximum number of concurrent texture requests</param>
-        public TexturePipeline(GridClient client, int maxRequests)
-        {
-            running = true;
-            this.client = client;
-            maxTextureRequests = maxRequests;
-
-            requestQueue = new List<TaskInfo>();
-            currentRequests = new Dictionary<UUID, int>(maxTextureRequests);
-            completedDownloads = new Dictionary<UUID, ImageDownload>();
-            resetEvents = new AutoResetEvent[maxTextureRequests];
-            threadpoolSlots = new int[maxTextureRequests];
-
-            // Pre-configure autoreset events/download slots
-            for (int i = 0; i < maxTextureRequests; i++)
-            {
-                resetEvents[i] = new AutoResetEvent(false);
-                threadpoolSlots[i] = -1;
-            }
-
-            client.Assets.OnImageReceived += Assets_OnImageReceived;
-            client.Assets.OnImageReceiveProgress += Assets_OnImageReceiveProgress;
-
-            // Fire up the texture download thread
-            downloadMaster = new Thread(new ThreadStart(DownloadThread));
-            downloadMaster.Start();
-        }
-
-        public void Shutdown()
-        {
-            client.Assets.OnImageReceived -= Assets_OnImageReceived;
-            client.Assets.OnImageReceiveProgress -= Assets_OnImageReceiveProgress;
-
-            requestQueue.Clear();
-
-            for (int i = 0; i < resetEvents.Length; i++)
-                if (resetEvents[i] != null)
-                    resetEvents[i].Set();
-
-            running = false;
-        }
-
-        /// <summary>
-        /// Request a texture be downloaded, once downloaded OnImageRenderReady event will be fired
-        /// containing texture key which can be used to retrieve texture with GetTextureToRender method
-        /// </summary>
-        /// <param name="textureID">Texture to request</param>
-        /// <param name="type">Type of the requested texture</param>
-        public void RequestTexture(UUID textureID, ImageType type)
-        {
-            lock (syncObject)
-            {
-                if (client.Assets.Cache.HasImage(textureID))
-                {
-                    // Add to rendering dictionary
-                    if (!completedDownloads.ContainsKey(textureID))
-                    {
-                        completedDownloads.Add(textureID, client.Assets.Cache.GetCachedImage(textureID));
-
-                        // Let any subscribers know about it
-                        if (OnDownloadFinished != null)
-                            OnDownloadFinished(textureID, true);
-                    }
-                    else
-                    {
-                        // This image has already been served up, ignore this request
-                    }
-                }
-                else
-                {
-                    // Make sure the request isn't already queued up
-                    foreach (TaskInfo task in requestQueue)
-                    {
-                        if (task.RequestID == textureID)
-                            return;
-                    }
-
-                    // Make sure we aren't already downloading the texture
-                    if (!currentRequests.ContainsKey(textureID))
-                        requestQueue.Add(new TaskInfo(textureID, 0, type));
-                }
-            }
-        }
-
-        /// <summary>
-        /// retrieve texture information from dictionary
-        /// </summary>
-        /// <param name="textureID">Texture ID</param>
-        /// <returns>ImageDownload object</returns>
-        public ImageDownload GetTextureToRender(UUID textureID)
-        {
-            lock (syncObject)
-            {
-                if (completedDownloads.ContainsKey(textureID))
-                {
-                    return completedDownloads[textureID];
-                }
-                else
-                {
-                    Logger.Log("Requested texture data for texture that does not exist in dictionary", Helpers.LogLevel.Warning);
-                    return null;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Remove no longer necessary texture from dictionary
-        /// </summary>
-        /// <param name="textureID"></param>
-        public bool RemoveFromPipeline(UUID textureID)
-        {
-            lock (syncObject)
-                return completedDownloads.Remove(textureID);
-        }
-
-        public void AbortDownload(UUID textureID)
-        {
-            lock (syncObject)
-            {
-                for (int i = 0; i < requestQueue.Count; i++)
-                {
-                    TaskInfo task = requestQueue[i];
-
-                    if (task.RequestID == textureID)
-                    {
-                        requestQueue.RemoveAt(i);
-                        --i;
-                    }
-                }
-
-                int current;
-                if (currentRequests.TryGetValue(textureID, out current))
-                {
-                    currentRequests.Remove(textureID);
-                    resetEvents[current].Set();
-
-                    // FIXME: Send an abort packet
-                }
-            }
-        }
-
-        /// <summary>
-        /// Master Download Thread, Queues up downloads in the threadpool
-        /// </summary>
-        private void DownloadThread()
-        {
-            int reqNbr;
-
-            while (running)
-            {
-                if (requestQueue.Count > 0)
-                {
-                    reqNbr = -1;
-                    // find available slot for reset event
-                    for (int i = 0; i < threadpoolSlots.Length; i++)
-                    {
-                        if (threadpoolSlots[i] == -1)
-                        {
-                            threadpoolSlots[i] = 1;
-                            reqNbr = i;
-                            break;
-                        }
-                    }
-
-                    if (reqNbr != -1)
-                    {
-                        TaskInfo task = null;
-                        lock (syncObject)
-                        {
-                            if (requestQueue.Count > 0)
-                            {
-                                task = requestQueue[0];
-                                requestQueue.RemoveAt(0);
-                            }
-                        }
-
-                        if (task != null)
-                        {
-                            task.RequestNbr = reqNbr;
-
-                            Logger.DebugLog(String.Format("Sending Worker thread new download request {0}", reqNbr));
-                            ThreadPool.QueueUserWorkItem(TextureRequestDoWork, task);
-                            continue;
-                        }
-                    }
-                }
-
-                // Queue was empty, let's give up some CPU time
-                Thread.Sleep(500);
-            }
-
-            Logger.Log("Texture pipeline shutting down", Helpers.LogLevel.Info);
-        }
-
-        private void TextureRequestDoWork(Object threadContext)
-        {
-            TaskInfo ti = (TaskInfo)threadContext;
-
-            lock (syncObject)
-            {
-                if (currentRequests.ContainsKey(ti.RequestID))
-                {
-                    threadpoolSlots[ti.RequestNbr] = -1;
-                    return;
-                }
-                else
-                {
-                    currentRequests.Add(ti.RequestID, ti.RequestNbr);
-                }
-            }
-
-            Logger.DebugLog(String.Format("Worker {0} Requesting {1}", ti.RequestNbr, ti.RequestID));
-
-            resetEvents[ti.RequestNbr].Reset();
-            client.Assets.RequestImage(ti.RequestID, ti.Type);
-
-            // don't release this worker slot until texture is downloaded or timeout occurs
-            if (!resetEvents[ti.RequestNbr].WaitOne(45 * 1000, false))
-            {
-                // Timed out
-                Logger.Log("Worker " + ti.RequestNbr + " Timeout waiting for Texture " + ti.RequestID + " to Download", Helpers.LogLevel.Warning);
-
-                lock (syncObject)
-                    currentRequests.Remove(ti.RequestID);
-
-                if (OnDownloadFinished != null)
-                    OnDownloadFinished(ti.RequestID, false);
-            }
-
-            // free up this download slot
-            threadpoolSlots[ti.RequestNbr] = -1;
-        }
-
-        private void Assets_OnImageReceived(ImageDownload image, AssetTexture asset)
-        {
-            int requestNbr;
-            bool found;
-
-            lock (syncObject)
-                found = currentRequests.TryGetValue(image.ID, out requestNbr);
-
-            if (asset != null && found)
-            {
-                Logger.DebugLog(String.Format("Worker {0} Downloaded texture {1}", requestNbr, image.ID));
-
-                // Free up this slot in the ThreadPool
-                lock (syncObject)
-                    currentRequests.Remove(image.ID);
-
-                resetEvents[requestNbr].Set();
-
-                if (image.Success)
-                {
-                    // Add to the completed texture dictionary
-                    lock (syncObject)
-                        completedDownloads[image.ID] = image;
-                }
-                else
-                {
-                    Logger.Log(String.Format("Download of texture {0} failed. NotFound={1}", image.ID, image.NotFound),
-                        Helpers.LogLevel.Warning);
-                }
-
-                // Let any subscribers know about it
-                if (OnDownloadFinished != null)
-                    OnDownloadFinished(image.ID, image.Success);
-            }
-        }
-
-        private void Assets_OnImageReceiveProgress(UUID image, int lastPacket, int recieved, int total)
-        {
-            if (OnDownloadProgress != null && currentRequests.ContainsKey(image))
-                OnDownloadProgress(image, recieved, total);
-        }
-    }
-}
+/*
+ * Copyright (c) 2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Threading;
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// Texture request download handler, allows a configurable number of download slots
+    /// </summary>
+    public class TexturePipeline
+    {
+        class TaskInfo
+        {
+            public UUID RequestID;
+            public int RequestNbr;
+            public ImageType Type;
+
+            public TaskInfo(UUID reqID, int reqNbr, ImageType type)
+            {
+                RequestID = reqID;
+                RequestNbr = reqNbr;
+                Type = type;
+            }
+        }
+
+        public delegate void DownloadFinishedCallback(UUID id, bool success);
+        public delegate void DownloadProgressCallback(UUID image, int recieved, int total);
+
+        /// <summary>Fired when a texture download completes</summary>
+        public event DownloadFinishedCallback OnDownloadFinished;
+        /// <summary>Fired when some texture data is received</summary>
+        public event DownloadProgressCallback OnDownloadProgress;
+
+        public int CurrentCount { get { return currentRequests.Count; } }
+        public int QueuedCount { get { return requestQueue.Count; } }
+
+        GridClient client;
+        /// <summary>Maximum concurrent texture requests</summary>
+        int maxTextureRequests;
+        /// <summary>Queue for image requests that have not been sent out yet</summary>
+        List<TaskInfo> requestQueue;
+        /// <summary>Current texture downloads</summary>
+        Dictionary<UUID, int> currentRequests;
+        /// <summary>Storage for completed texture downloads</summary>
+        Dictionary<UUID, ImageDownload> completedDownloads;
+        AutoResetEvent[] resetEvents;
+        int[] threadpoolSlots;
+        Thread downloadMaster;
+        bool running;
+        object syncObject = new object();
+
+        /// <summary>
+        /// Default constructor
+        /// </summary>
+        /// <param name="client">Reference to <code>SecondLife</code> client</param>
+        /// <param name="maxRequests">Maximum number of concurrent texture requests</param>
+        public TexturePipeline(GridClient client, int maxRequests)
+        {
+            running = true;
+            this.client = client;
+            maxTextureRequests = maxRequests;
+
+            requestQueue = new List<TaskInfo>();
+            currentRequests = new Dictionary<UUID, int>(maxTextureRequests);
+            completedDownloads = new Dictionary<UUID, ImageDownload>();
+            resetEvents = new AutoResetEvent[maxTextureRequests];
+            threadpoolSlots = new int[maxTextureRequests];
+
+            // Pre-configure autoreset events/download slots
+            for (int i = 0; i < maxTextureRequests; i++)
+            {
+                resetEvents[i] = new AutoResetEvent(false);
+                threadpoolSlots[i] = -1;
+            }
+
+            client.Assets.OnImageReceived += Assets_OnImageReceived;
+            client.Assets.OnImageReceiveProgress += Assets_OnImageReceiveProgress;
+
+            // Fire up the texture download thread
+            downloadMaster = new Thread(new ThreadStart(DownloadThread));
+            downloadMaster.Start();
+        }
+
+        public void Shutdown()
+        {
+            client.Assets.OnImageReceived -= Assets_OnImageReceived;
+            client.Assets.OnImageReceiveProgress -= Assets_OnImageReceiveProgress;
+
+            requestQueue.Clear();
+
+            for (int i = 0; i < resetEvents.Length; i++)
+                if (resetEvents[i] != null)
+                    resetEvents[i].Set();
+
+            running = false;
+        }
+
+        /// <summary>
+        /// Request a texture be downloaded, once downloaded OnImageRenderReady event will be fired
+        /// containing texture key which can be used to retrieve texture with GetTextureToRender method
+        /// </summary>
+        /// <param name="textureID">Texture to request</param>
+        /// <param name="type">Type of the requested texture</param>
+        public void RequestTexture(UUID textureID, ImageType type)
+        {
+            lock (syncObject)
+            {
+                if (client.Assets.Cache.HasImage(textureID))
+                {
+                    // Add to rendering dictionary
+                    if (!completedDownloads.ContainsKey(textureID))
+                    {
+                        completedDownloads.Add(textureID, client.Assets.Cache.GetCachedImage(textureID));
+
+                        // Let any subscribers know about it
+                        if (OnDownloadFinished != null)
+                            OnDownloadFinished(textureID, true);
+                    }
+                    else
+                    {
+                        // This image has already been served up, ignore this request
+                    }
+                }
+                else
+                {
+                    // Make sure the request isn't already queued up
+                    foreach (TaskInfo task in requestQueue)
+                    {
+                        if (task.RequestID == textureID)
+                            return;
+                    }
+
+                    // Make sure we aren't already downloading the texture
+                    if (!currentRequests.ContainsKey(textureID))
+                        requestQueue.Add(new TaskInfo(textureID, 0, type));
+                }
+            }
+        }
+
+        /// <summary>
+        /// retrieve texture information from dictionary
+        /// </summary>
+        /// <param name="textureID">Texture ID</param>
+        /// <returns>ImageDownload object</returns>
+        public ImageDownload GetTextureToRender(UUID textureID)
+        {
+            lock (syncObject)
+            {
+                if (completedDownloads.ContainsKey(textureID))
+                {
+                    return completedDownloads[textureID];
+                }
+                else
+                {
+                    Logger.Log("Requested texture data for texture that does not exist in dictionary", Helpers.LogLevel.Warning);
+                    return null;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Remove no longer necessary texture from dictionary
+        /// </summary>
+        /// <param name="textureID"></param>
+        public bool RemoveFromPipeline(UUID textureID)
+        {
+            lock (syncObject)
+                return completedDownloads.Remove(textureID);
+        }
+
+        public void AbortDownload(UUID textureID)
+        {
+            lock (syncObject)
+            {
+                for (int i = 0; i < requestQueue.Count; i++)
+                {
+                    TaskInfo task = requestQueue[i];
+
+                    if (task.RequestID == textureID)
+                    {
+                        requestQueue.RemoveAt(i);
+                        --i;
+                    }
+                }
+
+                int current;
+                if (currentRequests.TryGetValue(textureID, out current))
+                {
+                    currentRequests.Remove(textureID);
+                    resetEvents[current].Set();
+
+                    // FIXME: Send an abort packet
+                }
+            }
+        }
+
+        /// <summary>
+        /// Master Download Thread, Queues up downloads in the threadpool
+        /// </summary>
+        private void DownloadThread()
+        {
+            int reqNbr;
+
+            while (running)
+            {
+                if (requestQueue.Count > 0)
+                {
+                    reqNbr = -1;
+                    // find available slot for reset event
+                    for (int i = 0; i < threadpoolSlots.Length; i++)
+                    {
+                        if (threadpoolSlots[i] == -1)
+                        {
+                            threadpoolSlots[i] = 1;
+                            reqNbr = i;
+                            break;
+                        }
+                    }
+
+                    if (reqNbr != -1)
+                    {
+                        TaskInfo task = null;
+                        lock (syncObject)
+                        {
+                            if (requestQueue.Count > 0)
+                            {
+                                task = requestQueue[0];
+                                requestQueue.RemoveAt(0);
+                            }
+                        }
+
+                        if (task != null)
+                        {
+                            task.RequestNbr = reqNbr;
+
+                            Logger.DebugLog(String.Format("Sending Worker thread new download request {0}", reqNbr));
+                            ThreadPool.QueueUserWorkItem(TextureRequestDoWork, task);
+                            continue;
+                        }
+                    }
+                }
+
+                // Queue was empty, let's give up some CPU time
+                Thread.Sleep(500);
+            }
+
+            Logger.Log("Texture pipeline shutting down", Helpers.LogLevel.Info);
+        }
+
+        private void TextureRequestDoWork(Object threadContext)
+        {
+            TaskInfo ti = (TaskInfo)threadContext;
+
+            lock (syncObject)
+            {
+                if (currentRequests.ContainsKey(ti.RequestID))
+                {
+                    threadpoolSlots[ti.RequestNbr] = -1;
+                    return;
+                }
+                else
+                {
+                    currentRequests.Add(ti.RequestID, ti.RequestNbr);
+                }
+            }
+
+            Logger.DebugLog(String.Format("Worker {0} Requesting {1}", ti.RequestNbr, ti.RequestID));
+
+            resetEvents[ti.RequestNbr].Reset();
+            client.Assets.RequestImage(ti.RequestID, ti.Type);
+
+            // don't release this worker slot until texture is downloaded or timeout occurs
+            if (!resetEvents[ti.RequestNbr].WaitOne(45 * 1000, false))
+            {
+                // Timed out
+                Logger.Log("Worker " + ti.RequestNbr + " Timeout waiting for Texture " + ti.RequestID + " to Download", Helpers.LogLevel.Warning);
+
+                lock (syncObject)
+                    currentRequests.Remove(ti.RequestID);
+
+                if (OnDownloadFinished != null)
+                    OnDownloadFinished(ti.RequestID, false);
+            }
+
+            // free up this download slot
+            threadpoolSlots[ti.RequestNbr] = -1;
+        }
+
+        private void Assets_OnImageReceived(ImageDownload image, AssetTexture asset)
+        {
+            int requestNbr;
+            bool found;
+
+            lock (syncObject)
+                found = currentRequests.TryGetValue(image.ID, out requestNbr);
+
+            if (asset != null && found)
+            {
+                Logger.DebugLog(String.Format("Worker {0} Downloaded texture {1}", requestNbr, image.ID));
+
+                // Free up this slot in the ThreadPool
+                lock (syncObject)
+                    currentRequests.Remove(image.ID);
+
+                resetEvents[requestNbr].Set();
+
+                if (image.Success)
+                {
+                    // Add to the completed texture dictionary
+                    lock (syncObject)
+                        completedDownloads[image.ID] = image;
+                }
+                else
+                {
+                    Logger.Log(String.Format("Download of texture {0} failed. NotFound={1}", image.ID, image.NotFound),
+                        Helpers.LogLevel.Warning);
+                }
+
+                // Let any subscribers know about it
+                if (OnDownloadFinished != null)
+                    OnDownloadFinished(image.ID, image.Success);
+            }
+        }
+
+        private void Assets_OnImageReceiveProgress(UUID image, int lastPacket, int recieved, int total)
+        {
+            if (OnDownloadProgress != null && currentRequests.ContainsKey(image))
+                OnDownloadProgress(image, recieved, total);
+        }
+    }
+}
Index: GroupManager.cs
===================================================================
--- GroupManager.cs	(revision 2445)
+++ GroupManager.cs	(working copy)
@@ -1124,6 +1124,21 @@
             Client.Network.SendPacket(p);
         }
 
+        /// <summary>Set preferences for recieving group notices and listing group in prfile</summary>
+        /// <param name="groupID">The group to modify user preference on</param>
+        /// <param name="rcv_notices">Weather to recieve group notices from this group</param>
+        /// <param name="show_in_profile">Weather to list this group in your profile</param>        
+        public void setUserGroupFlags(UUID groupID, bool rcv_notices, bool show_in_profile)
+        {
+            SetGroupAcceptNoticesPacket p = new SetGroupAcceptNoticesPacket();
+            p.AgentData.AgentID = Client.Self.AgentID;
+            p.AgentData.SessionID = Client.Self.SessionID;
+            p.Data.GroupID = groupID;
+            p.Data.AcceptNotices = rcv_notices;
+            p.NewData.ListInProfile = show_in_profile;
+            Client.Network.SendPacket(p);
+        }
+
         #region Packet Handlers
 
         private void GroupDataHandler(Packet packet, Simulator simulator)
@@ -1252,6 +1267,10 @@
                         if(groupMemberCache.Count >= members.GroupData.MemberCount)
                             GroupMembersRequests.Remove(members.GroupData.RequestID);
                     }
+
+
+                    if (groupMemberCache.Count >= members.GroupData.MemberCount)
+                        GroupMembersRequests.Remove(members.GroupData.RequestID);
                 }
             }
 
Index: InventoryManager.cs
===================================================================
--- InventoryManager.cs	(revision 2445)
+++ InventoryManager.cs	(working copy)
@@ -1,3539 +1,3793 @@
-/*
- * Copyright (c) 2006-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using System.Text.RegularExpressions;
-using System.Threading;
-using System.Text;
-using OpenMetaverse.Http;
-using OpenMetaverse.StructuredData;
-using OpenMetaverse.Packets;
-
-namespace OpenMetaverse
-{
-    #region Enums
-    /// <summary>
-    /// Inventory Item Types, eg Script, Notecard, Folder, etc
-    /// </summary>
-    public enum InventoryType : sbyte
-    {
-        /// <summary>Unknown</summary>
-        Unknown = -1,
-        /// <summary>Texture</summary>
-        Texture = 0,
-        /// <summary>Sound</summary>
-        Sound = 1,
-        /// <summary>Calling Card</summary>
-        CallingCard = 2,
-        /// <summary>Landmark</summary>
-        Landmark = 3,
-        /*
-        /// <summary>Script</summary>
-        //[Obsolete("See LSL")] Script = 4,
-        /// <summary>Clothing</summary>
-        //[Obsolete("See Wearable")] Clothing = 5,
-        /// <summary>Object, both single and coalesced</summary>
-         */
-        Object = 6,
-        /// <summary>Notecard</summary>
-        Notecard = 7,
-        /// <summary></summary>
-        Category = 8,
-        /// <summary>Folder</summary>
-        Folder = 8,
-        /// <summary></summary>
-        RootCategory = 9,
-        /// <summary>an LSL Script</summary>
-        LSL = 10,
-        /*
-        /// <summary></summary>
-        //[Obsolete("See LSL")] LSLBytecode = 11,
-        /// <summary></summary>
-        //[Obsolete("See Texture")] TextureTGA = 12,
-        /// <summary></summary>
-        //[Obsolete] Bodypart = 13,
-        /// <summary></summary>
-        //[Obsolete] Trash = 14,
-         */
-        /// <summary></summary>
-        Snapshot = 15,
-        /*
-        /// <summary></summary>
-        //[Obsolete] LostAndFound = 16,
-         */
-        /// <summary></summary>
-        Attachment = 17,
-        /// <summary></summary>
-        Wearable = 18,
-        /// <summary></summary>
-        Animation = 19,
-        /// <summary></summary>
-        Gesture = 20
-    }
-
-    /// <summary>
-    /// Item Sale Status
-    /// </summary>
-    public enum SaleType : byte
-    {
-        /// <summary>Not for sale</summary>
-        Not = 0,
-        /// <summary>The original is for sale</summary>
-        Original = 1,
-        /// <summary>Copies are for sale</summary>
-        Copy = 2,
-        /// <summary>The contents of the object are for sale</summary>
-        Contents = 3
-    }
-
-    [Flags]
-    public enum InventorySortOrder : int
-    {
-        /// <summary>Sort by name</summary>
-        ByName = 0,
-        /// <summary>Sort by date</summary>
-        ByDate = 1,
-        /// <summary>Sort folders by name, regardless of whether items are
-        /// sorted by name or date</summary>
-        FoldersByName = 2,
-        /// <summary>Place system folders at the top</summary>
-        SystemFoldersToTop = 4
-    }
-
-    /// <summary>
-    /// Possible destinations for DeRezObject request
-    /// </summary>
-    public enum DeRezDestination : byte
-    {
-        /// <summary></summary>
-        AgentInventorySave = 0,
-        /// <summary>Copy from in-world to agent inventory</summary>
-        AgentInventoryCopy = 1,
-        /// <summary>Derez to TaskInventory</summary>
-        TaskInventory = 2,
-        /// <summary></summary>
-        Attachment = 3,
-        /// <summary>Take Object</summary>
-        AgentInventoryTake = 4,
-        /// <summary></summary>
-        ForceToGodInventory = 5,
-        /// <summary>Delete Object</summary>
-        TrashFolder = 6,
-        /// <summary>Put an avatar attachment into agent inventory</summary>
-        AttachmentToInventory = 7,
-        /// <summary></summary>
-        AttachmentExists = 8,
-        /// <summary>Return an object back to the owner's inventory</summary>
-        ReturnToOwner = 9,
-        /// <summary>Return a deeded object back to the last owner's inventory</summary>
-        ReturnToLastOwner = 10
-    }
-
-    #endregion Enums
-
-    #region Inventory Object Classes
-    /// <summary>
-    /// Base Class for Inventory Items
-    /// </summary>
-    public abstract class InventoryBase
-    {
-        /// <summary><seealso cref="OpenMetaverse.UUID"/> of item/folder</summary>
-        public readonly UUID UUID;
-        /// <summary><seealso cref="OpenMetaverse.UUID"/> of parent folder</summary>
-        public UUID ParentUUID;
-        /// <summary>Name of item/folder</summary>
-        public string Name;
-        /// <summary>Item/Folder Owners <seealso cref="OpenMetaverse.UUID"/></summary>
-        public UUID OwnerID;
-
-        /// <summary>
-        /// Constructor, takes an itemID as a parameter
-        /// </summary>
-        /// <param name="itemID">The <seealso cref="OpenMetaverse.UUID"/> of the item</param>
-        public InventoryBase(UUID itemID)
-        {
-            if (itemID == UUID.Zero)
-                Logger.Log("Initializing an InventoryBase with UUID.Zero", Helpers.LogLevel.Warning);
-            UUID = itemID;
-        }
-
-        /// <summary>
-        /// Generates a number corresponding to the value of the object to support the use of a hash table,
-        /// suitable for use in hashing algorithms and data structures such as a hash table
-        /// </summary>
-        /// <returns>A Hashcode of all the combined InventoryBase fields</returns>
-        public override int GetHashCode()
-        {
-            return UUID.GetHashCode() ^ ParentUUID.GetHashCode() ^ Name.GetHashCode() ^ OwnerID.GetHashCode();
-        }
-
-        /// <summary>
-        /// Determine whether the specified <seealso cref="OpenMetaverse.InventoryBase"/> object is equal to the current object
-        /// </summary>
-        /// <param name="o">InventoryBase object to compare against</param>
-        /// <returns>true if objects are the same</returns>
-        public override bool Equals(object o)
-        {
-            InventoryBase inv = o as InventoryBase;
-            return inv != null && Equals(inv);
-        }
-
-        /// <summary>
-        /// Determine whether the specified <seealso cref="OpenMetaverse.InventoryBase"/> object is equal to the current object
-        /// </summary>
-        /// <param name="o">InventoryBase object to compare against</param>
-        /// <returns>true if objects are the same</returns>
-        public virtual bool Equals(InventoryBase o)
-        {
-            return o.UUID == UUID
-                && o.ParentUUID == ParentUUID
-                && o.Name == Name
-                && o.OwnerID == OwnerID;
-        }
-    }
-
-    /// <summary>
-    /// An Item in Inventory
-    /// </summary>
-    public class InventoryItem : InventoryBase
-    {
-        /// <summary>The <seealso cref="OpenMetaverse.UUID"/> of this item</summary>
-        public UUID AssetUUID;
-        /// <summary>The combined <seealso cref="OpenMetaverse.Permissions"/> of this item</summary>
-        public Permissions Permissions;
-        /// <summary>The type of item from <seealso cref="OpenMetaverse.AssetType"/></summary>
-        public AssetType AssetType;
-        /// <summary>The type of item from the <seealso cref="OpenMetaverse.InventoryType"/> enum</summary>
-        public InventoryType InventoryType;
-        /// <summary>The <seealso cref="OpenMetaverse.UUID"/> of the creator of this item</summary>
-        public UUID CreatorID;
-        /// <summary>A Description of this item</summary>
-        public string Description;
-        /// <summary>The <seealso cref="OpenMetaverse.Group"/>s <seealso cref="OpenMetaverse.UUID"/> this item is set to or owned by</summary>
-        public UUID GroupID;
-        /// <summary>If true, item is owned by a group</summary>
-        public bool GroupOwned;
-        /// <summary>The price this item can be purchased for</summary>
-        public int SalePrice;
-        /// <summary>The type of sale from the <seealso cref="OpenMetaverse.SaleType"/> enum</summary>
-        public SaleType SaleType;
-        /// <summary>Combined flags from <seealso cref="OpenMetaverse.InventoryItemFlags"/></summary>
-        public uint Flags;
-        /// <summary>Time and date this inventory item was created, stored as
-        /// UTC (Coordinated Universal Time)</summary>
-        public DateTime CreationDate;
-
-        /// <summary>
-        ///  Construct a new InventoryItem object
-        /// </summary>
-        /// <param name="itemID">The <seealso cref="OpenMetaverse.UUID"/> of the item</param>
-        public InventoryItem(UUID itemID) 
-            : base(itemID) { }
-
-        /// <summary>
-        /// Construct a new InventoryItem object of a specific Type
-        /// </summary>
-        /// <param name="type">The type of item from <seealso cref="OpenMetaverse.InventoryType"/></param>
-        /// <param name="itemID"><seealso cref="OpenMetaverse.UUID"/> of the item</param>
-        public InventoryItem(InventoryType type, UUID itemID) : base(itemID) { InventoryType = type; }
-
-        /// <summary>
-        /// Generates a number corresponding to the value of the object to support the use of a hash table.
-        /// Suitable for use in hashing algorithms and data structures such as a hash table
-        /// </summary>
-        /// <returns>A Hashcode of all the combined InventoryItem fields</returns>
-        public override int GetHashCode()
-        {
-            return AssetUUID.GetHashCode() ^ Permissions.GetHashCode() ^ AssetType.GetHashCode() ^
-                InventoryType.GetHashCode() ^ Description.GetHashCode() ^ GroupID.GetHashCode() ^
-                GroupOwned.GetHashCode() ^ SalePrice.GetHashCode() ^ SaleType.GetHashCode() ^
-                Flags.GetHashCode() ^ CreationDate.GetHashCode();
-        }
-
-        /// <summary>
-        /// Compares an object
-        /// </summary>
-        /// <param name="o">The object to compare</param>
-        /// <returns>true if comparison object matches</returns>
-        public override bool Equals(object o)
-        {
-            InventoryItem item = o as InventoryItem;
-            return item != null && Equals(item);
-        }
-
-        /// <summary>
-        /// Determine whether the specified <seealso cref="OpenMetaverse.InventoryBase"/> object is equal to the current object
-        /// </summary>
-        /// <param name="o">The <seealso cref="OpenMetaverse.InventoryBase"/> object to compare against</param>
-        /// <returns>true if objects are the same</returns>
-        public override bool Equals(InventoryBase o)
-        {
-            InventoryItem item = o as InventoryItem;
-            return item != null && Equals(item);
-        }
-
-        /// <summary>
-        /// Determine whether the specified <seealso cref="OpenMetaverse.InventoryItem"/> object is equal to the current object
-        /// </summary>
-        /// <param name="o">The <seealso cref="OpenMetaverse.InventoryItem"/> object to compare against</param>
-        /// <returns>true if objects are the same</returns>
-        public bool Equals(InventoryItem o)
-        {
-            return base.Equals(o as InventoryBase)
-                && o.AssetType == AssetType
-                && o.AssetUUID == AssetUUID
-                && o.CreationDate == CreationDate
-                && o.Description == Description
-                && o.Flags == Flags
-                && o.GroupID == GroupID
-                && o.GroupOwned == GroupOwned
-                && o.InventoryType == InventoryType
-                && o.Permissions.Equals(Permissions)
-                && o.SalePrice == SalePrice
-                && o.SaleType == SaleType;
-        }
-    }
-
-    /// <summary>
-    /// InventoryTexture Class representing a graphical image
-    /// </summary>
-    /// <seealso cref="ManagedImage"/>
-    public class InventoryTexture : InventoryItem 
-    { 
-        /// <summary>
-        /// Construct an InventoryTexture object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventoryTexture(UUID itemID) : base(itemID) 
-        { 
-            InventoryType = InventoryType.Texture; 
-        } 
-    }
-
-    /// <summary>
-    /// InventorySound Class representing a playable sound
-    /// </summary>
-    public class InventorySound : InventoryItem 
-    {
-        /// <summary>
-        /// Construct an InventorySound object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventorySound(UUID itemID) : base(itemID) 
-        { 
-            InventoryType = InventoryType.Sound; 
-        } 
-    }
-
-    /// <summary>
-    /// InventoryCallingCard Class, contains information on another avatar
-    /// </summary>
-    public class InventoryCallingCard : InventoryItem 
-    {
-        /// <summary>
-        /// Construct an InventoryCallingCard object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventoryCallingCard(UUID itemID) : base(itemID) 
-        { 
-            InventoryType = InventoryType.CallingCard; 
-        }
-    }
-
-    /// <summary>
-    /// InventoryLandmark Class, contains details on a specific location
-    /// </summary>
-    public class InventoryLandmark : InventoryItem 
-    {
-        /// <summary>
-        /// Construct an InventoryLandmark object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventoryLandmark(UUID itemID) : base(itemID) 
-        { 
-            InventoryType = InventoryType.Landmark; 
-        }
-
-        /// <summary>
-        /// Landmarks use the ObjectType struct and will have a flag of 1 set if they have been visited
-        /// </summary>
-        public ObjectType LandmarkType
-        {
-            get { return (ObjectType)Flags; }
-            set { Flags = (uint)value; }
-        }
-    }
-
-    /// <summary>
-    /// InventoryObject Class contains details on a primitive or coalesced set of primitives
-    /// </summary>
-    public class InventoryObject : InventoryItem 
-    {
-        /// <summary>
-        /// Construct an InventoryObject object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventoryObject(UUID itemID) : base(itemID) 
-        { 
-            InventoryType = InventoryType.Object; 
-        }
-
-        /// <summary>
-        /// Get the Objects permission override settings
-        /// 
-        /// These will indicate the which permissions that 
-        /// will be overwritten when the object is rezzed in-world
-        /// </summary>
-        public ObjectType ObjectType
-        {
-            get { return (ObjectType)Flags; }
-            set { Flags = (uint)value; }
-        }
-    }
-
-    /// <summary>
-    /// InventoryNotecard Class, contains details on an encoded text document
-    /// </summary>
-    public class InventoryNotecard : InventoryItem 
-    {
-        /// <summary>
-        /// Construct an InventoryNotecard object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventoryNotecard(UUID itemID) : base(itemID) 
-        { 
-            InventoryType = InventoryType.Notecard; 
-        } 
-    }
-
-    /// <summary>
-    /// InventoryCategory Class
-    /// </summary>
-    /// <remarks>TODO: Is this even used for anything?</remarks>
-    public class InventoryCategory : InventoryItem 
-    {
-        /// <summary>
-        /// Construct an InventoryCategory object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventoryCategory(UUID itemID) : base(itemID) 
-        { 
-            InventoryType = InventoryType.Category; 
-        } 
-    }
-
-    /// <summary>
-    /// InventoryLSL Class, represents a Linden Scripting Language object
-    /// </summary>
-    public class InventoryLSL : InventoryItem 
-    {
-        /// <summary>
-        /// Construct an InventoryLSL object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventoryLSL(UUID itemID) : base(itemID) 
-        { 
-            InventoryType = InventoryType.LSL; 
-        } 
-    }
-
-    /// <summary>
-    /// InventorySnapshot Class, an image taken with the viewer
-    /// </summary>
-    public class InventorySnapshot : InventoryItem 
-    {
-        /// <summary>
-        /// Construct an InventorySnapshot object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventorySnapshot(UUID itemID) : base(itemID) 
-        { 
-            InventoryType = InventoryType.Snapshot; 
-        } 
-    }
-
-    /// <summary>
-    /// InventoryAttachment Class, contains details on an attachable object
-    /// </summary>
-    public class InventoryAttachment  : InventoryItem 
-    {
-        /// <summary>
-        /// Construct an InventoryAttachment object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventoryAttachment(UUID itemID) : base(itemID) 
-        { 
-            InventoryType = InventoryType.Attachment; 
-        }
-
-        /// <summary>
-        /// Get the last AttachmentPoint this object was attached to
-        /// </summary>
-        public AttachmentPoint AttachmentPoint
-        {
-            get { return (AttachmentPoint)Flags; }
-            set { Flags = (uint)value; }
-        }
-    }
-
-    /// <summary>
-    /// InventoryWearable Class, details on a clothing item or body part
-    /// </summary>
-    public class InventoryWearable : InventoryItem
-    {
-        /// <summary>
-        /// Construct an InventoryWearable object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventoryWearable(UUID itemID) : base(itemID) { InventoryType = InventoryType.Wearable; }
-
-        /// <summary>
-        /// The <seealso cref="OpenMetaverse.WearableType"/>, Skin, Shape, Skirt, Etc
-        /// </summary>
-        public WearableType WearableType
-        {
-            get { return (WearableType)Flags; }
-            set { Flags = (uint)value; }
-        }
-    }
-
-    /// <summary>
-    /// InventoryAnimation Class, A bvh encoded object which animates an avatar
-    /// </summary>
-    public class InventoryAnimation : InventoryItem 
-    {
-        /// <summary>
-        /// Construct an InventoryAnimation object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventoryAnimation(UUID itemID) : base(itemID) 
-        { 
-            InventoryType = InventoryType.Animation; 
-        } 
-    }
-
-    /// <summary>
-    /// InventoryGesture Class, details on a series of animations, sounds, and actions
-    /// </summary>
-    public class InventoryGesture : InventoryItem 
-    {
-        /// <summary>
-        /// Construct an InventoryGesture object
-        /// </summary>
-        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
-        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
-        public InventoryGesture(UUID itemID) : base(itemID) 
-        { 
-            InventoryType = InventoryType.Gesture; 
-        } 
-    }
-    
-    /// <summary>
-    /// A folder contains <seealso cref="T:OpenMetaverse.InventoryItem"/>s and has certain attributes specific 
-    /// to itself
-    /// </summary>
-    public class InventoryFolder : InventoryBase
-    {
-        /// <summary>The Preferred <seealso cref="T:OpenMetaverse.AssetType"/> for a folder.</summary>
-        public AssetType PreferredType;
-        /// <summary>The Version of this folder</summary>
-        public int Version;
-        /// <summary>Number of child items this folder contains.</summary>
-        public int DescendentCount;
-
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        /// <param name="itemID">UUID of the folder</param>
-        public InventoryFolder(UUID itemID)
-            : base(itemID) { }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <returns></returns>
-        public override string ToString()
-        {
-            return Name;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <returns></returns>
-        public override int GetHashCode()
-        {
-            return PreferredType.GetHashCode() ^ Version.GetHashCode() ^ DescendentCount.GetHashCode();
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="o"></param>
-        /// <returns></returns>
-        public override bool Equals(object o)
-        {
-            InventoryFolder folder = o as InventoryFolder;
-            return folder != null && Equals(folder);
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="o"></param>
-        /// <returns></returns>
-        public override bool Equals(InventoryBase o)
-        {
-            InventoryFolder folder = o as InventoryFolder;
-            return folder != null && Equals(folder);
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="o"></param>
-        /// <returns></returns>
-        public bool Equals(InventoryFolder o)
-        {
-            return base.Equals(o as InventoryBase)
-                && o.DescendentCount == DescendentCount
-                && o.PreferredType == PreferredType
-                && o.Version == Version;
-        }
-    }
-
-    #endregion Inventory Object Classes
-
-    /// <summary>
-    /// Tools for dealing with agents inventory
-    /// </summary>
-    public class InventoryManager
-    {
-        protected struct InventorySearch
-        {
-            public UUID Folder;
-            public UUID Owner;
-            public string[] Path;
-            public int Level;
-        }
-
-        #region Delegates
-
-        /// <summary>
-        /// Callback for inventory item creation finishing
-        /// </summary>
-        /// <param name="success">Whether the request to create an inventory
-        /// item succeeded or not</param>
-        /// <param name="item">Inventory item being created. If success is
-        /// false this will be null</param>
-        public delegate void ItemCreatedCallback(bool success, InventoryItem item);
-
-        /// <summary>
-        /// Callback for an inventory item being create from an uploaded asset
-        /// </summary>
-        /// <param name="success">true if inventory item creation was successful</param>
-        /// <param name="status"></param>
-        /// <param name="itemID"></param>
-        /// <param name="assetID"></param>
-        public delegate void ItemCreatedFromAssetCallback(bool success, string status, UUID itemID, UUID assetID);
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="item"></param>
-        public delegate void ItemCopiedCallback(InventoryBase item);
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="item"></param>
-        public delegate void ItemReceivedCallback(InventoryItem item);
-
-        /// <summary>
-        /// Callback for an inventory folder updating
-        /// </summary>
-        /// <param name="folderID">UUID of the folder that was updated</param>
-        public delegate void FolderUpdatedCallback(UUID folderID);
-
-        /// <summary>
-        /// Callback for when an inventory item is offered to us by another avatar or an object
-        /// </summary>
-        /// <param name="offerDetails">A <seealso cref="InstantMessage"/> object containing specific
-        /// details on the item being offered, eg who its from</param>
-        /// <param name="type">The <seealso cref="AssetType"/>AssetType being offered</param>
-        /// <param name="objectID">Will be null if item is offered from an object</param>
-        /// <param name="fromTask">will be true of item is offered from an object</param>
-        /// <returns>Return true to accept the offer, or false to decline it</returns>
-        public delegate bool ObjectOfferedCallback(InstantMessage offerDetails, AssetType type, UUID objectID, bool fromTask);
-
-        /// <summary>
-        /// Callback when an inventory object is accepted and received from a
-        /// task inventory. This is the callback in which you actually get
-        /// the ItemID, as in ObjectOfferedCallback it is null when received
-        /// from a task.
-        /// </summary>
-        /// <param name="itemID"></param>
-        /// <param name="folderID"></param>
-        /// <param name="creatorID"></param>
-        /// <param name="assetID"></param>
-        /// <param name="type"></param>
-        public delegate void TaskItemReceivedCallback(UUID itemID, UUID folderID, UUID creatorID, 
-            UUID assetID, InventoryType type);
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="path"></param>
-        /// <param name="inventoryObjectID"></param>
-        public delegate void FindObjectByPathCallback(string path, UUID inventoryObjectID);
-
-        /// <summary>
-        /// Reply received after calling <code>RequestTaskInventory</code>,
-        /// contains a filename that can be used in an asset download request
-        /// </summary>
-        /// <param name="itemID">UUID of the inventory item</param>
-        /// <param name="serial">Version number of the task inventory asset</param>
-        /// <param name="assetFilename">Filename of the task inventory asset</param>
-        public delegate void TaskInventoryReplyCallback(UUID itemID, short serial, string assetFilename);
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="success"></param>
-        /// <param name="status"></param>
-        /// <param name="itemID"></param>
-        /// <param name="assetID"></param>
-        public delegate void NotecardUploadedAssetCallback(bool success, string status, UUID itemID, UUID assetID);
-
-        #endregion Delegates
-
-        #region Events
-
-        /// <summary>
-        /// Fired when a reply to a RequestFetchInventory() is received
-        /// </summary>
-        /// <seealso cref="InventoryManager.RequestFetchInventory"/>
-        public event ItemReceivedCallback OnItemReceived;
-
-        /// <summary>
-        /// Fired when a response to a RequestFolderContents() is received 
-        /// </summary>
-        /// <seealso cref="InventoryManager.RequestFolderContents"/>
-        public event FolderUpdatedCallback OnFolderUpdated;
-
-        /// <summary>
-        /// Fired when an object or another avatar offers us an inventory item
-        /// </summary>
-        public event ObjectOfferedCallback OnObjectOffered;
-       
-        /// <summary>
-        /// Fired when a response to FindObjectByPath() is received
-        /// </summary>
-        /// <seealso cref="InventoryManager.FindObjectByPath"/>
-        public event FindObjectByPathCallback OnFindObjectByPath;
-
-        /// <summary>
-        /// Fired when a task inventory item is received
-        /// 
-        /// This may occur when an object that's rezzed in world is
-        /// taken into inventory, when an item is created using the CreateInventoryItem
-        /// packet, or when an object is purchased
-        /// </summary>
-        public event TaskItemReceivedCallback OnTaskItemReceived;
-
-        /// <summary>
-        /// Fired in response to a request for a tasks (primitive) inventory
-        /// </summary>
-        /// <seealso cref="InventoryManager.GetTaskInventory"/>
-        /// <seealso cref="InventoryManager.RequestTaskInventory"/>
-        public event TaskInventoryReplyCallback OnTaskInventoryReply;
-
-        #endregion Events
-
-        private GridClient _Client;
-        private Inventory _Store;
-        //private Random _RandNumbers = new Random();
-        private object _CallbacksLock = new object();
-        private uint _CallbackPos;
-        private Dictionary<uint, ItemCreatedCallback> _ItemCreatedCallbacks = new Dictionary<uint, ItemCreatedCallback>();
-        private Dictionary<uint, ItemCopiedCallback> _ItemCopiedCallbacks = new Dictionary<uint,ItemCopiedCallback>();
-        private List<InventorySearch> _Searches = new List<InventorySearch>();
-
-        #region String Arrays
-
-        /// <summary>Partial mapping of AssetTypes to folder names</summary>
-        private static readonly string[] _NewFolderNames = new string[]
-        {
-            "Textures",
-            "Sounds",
-            "Calling Cards",
-            "Landmarks",
-            "Scripts",
-            "Clothing",
-            "Objects",
-            "Notecards",
-            "New Folder",
-            "Inventory",
-            "Scripts",
-            "Scripts",
-            "Uncompressed Images",
-            "Body Parts",
-            "Trash",
-            "Photo Album",
-            "Lost And Found",
-            "Uncompressed Sounds",
-            "Uncompressed Images",
-            "Uncompressed Images",
-            "Animations",
-            "Gestures"
-        };
-
-        private static readonly string[] _AssetTypeNames = new string[]
-        {
-            "texture",
-	        "sound",
-	        "callcard",
-	        "landmark",
-	        "script",
-	        "clothing",
-	        "object",
-	        "notecard",
-	        "category",
-	        "root",
-	        "lsltext",
-	        "lslbyte",
-	        "txtr_tga",
-	        "bodypart",
-	        "trash",
-	        "snapshot",
-	        "lstndfnd",
-	        "snd_wav",
-	        "img_tga",
-	        "jpeg",
-	        "animatn",
-	        "gesture",
-	        "simstate"
-        };
-
-        private static readonly string[] _InventoryTypeNames = new string[]
-        {
-            "texture",
-	        "sound",
-	        "callcard",
-	        "landmark",
-	        String.Empty,
-	        String.Empty,
-	        "object",
-	        "notecard",
-	        "category",
-	        "root",
-	        "script",
-	        String.Empty,
-	        String.Empty,
-	        String.Empty,
-	        String.Empty,
-	        "snapshot",
-	        String.Empty,
-	        "attach",
-	        "wearable",
-	        "animation",
-	        "gesture",
-        };
-
-        private static readonly string[] _SaleTypeNames = new string[]
-        {
-            "not",
-            "orig",
-            "copy",
-            "cntn"
-        };
-
-        #endregion String Arrays
-
-        #region Properties
-
-        /// <summary>
-        /// Get this agents Inventory data
-        /// </summary>
-        public Inventory Store { get { return _Store; } }
-
-        #endregion Properties
-
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        /// <param name="client">Reference to the GridClient object</param>
-        public InventoryManager(GridClient client)
-        {
-            _Client = client;
-
-            _Client.Network.RegisterCallback(PacketType.UpdateCreateInventoryItem, new NetworkManager.PacketCallback(UpdateCreateInventoryItemHandler));
-            _Client.Network.RegisterCallback(PacketType.SaveAssetIntoInventory, new NetworkManager.PacketCallback(SaveAssetIntoInventoryHandler));
-            _Client.Network.RegisterCallback(PacketType.BulkUpdateInventory, new NetworkManager.PacketCallback(BulkUpdateInventoryHandler));
-            _Client.Network.RegisterCallback(PacketType.MoveInventoryItem, new NetworkManager.PacketCallback(MoveInventoryItemHandler));
-            _Client.Network.RegisterCallback(PacketType.InventoryDescendents, new NetworkManager.PacketCallback(InventoryDescendentsHandler));
-            _Client.Network.RegisterCallback(PacketType.FetchInventoryReply, new NetworkManager.PacketCallback(FetchInventoryReplyHandler));
-            _Client.Network.RegisterCallback(PacketType.ReplyTaskInventory, new NetworkManager.PacketCallback(ReplyTaskInventoryHandler));
-            
-            // Watch for inventory given to us through instant message
-            _Client.Self.OnInstantMessage += new AgentManager.InstantMessageCallback(Self_OnInstantMessage);
-
-            // Register extra parameters with login and parse the inventory data that comes back
-            _Client.Network.RegisterLoginResponseCallback(
-                new NetworkManager.LoginResponseCallback(Network_OnLoginResponse),
-                new string[] {
-                    "inventory-root", "inventory-skeleton", "inventory-lib-root",
-                    "inventory-lib-owner", "inventory-skel-lib"});
-        }
-
-        #region Fetch
-
-        /// <summary>
-        /// Fetch an inventory item from the dataserver
-        /// </summary>
-        /// <param name="itemID">The items <seealso cref="UUID"/></param>
-        /// <param name="ownerID">The item Owners <seealso cref="OpenMetaverse.UUID"/></param>
-        /// <param name="timeoutMS">a integer representing the number of milliseconds to wait for results</param>
-        /// <returns>An <seealso cref="InventoryItem"/> object on success, or null if no item was found</returns>
-        /// <remarks>Items will also be sent to the <seealso cref="InventoryManager.OnItemReceived"/> event</remarks>
-        public InventoryItem FetchItem(UUID itemID, UUID ownerID, int timeoutMS)
-        {
-            AutoResetEvent fetchEvent = new AutoResetEvent(false);
-            InventoryItem fetchedItem = null;
-
-            ItemReceivedCallback callback =
-                delegate(InventoryItem item)
-                {
-                    if (item.UUID == itemID)
-                    {
-                        fetchedItem = item;
-                        fetchEvent.Set();
-                    }
-                };
-
-            OnItemReceived += callback;
-            RequestFetchInventory(itemID, ownerID);
-
-            fetchEvent.WaitOne(timeoutMS, false);
-            OnItemReceived -= callback;
-
-            return fetchedItem;
-        }
-
-        /// <summary>
-        /// Request A single inventory item
-        /// </summary>
-        /// <param name="itemID">The items <seealso cref="OpenMetaverse.UUID"/></param>
-        /// <param name="ownerID">The item Owners <seealso cref="OpenMetaverse.UUID"/></param>
-        /// <seealso cref="InventoryManager.OnItemReceived"/>
-        public void RequestFetchInventory(UUID itemID, UUID ownerID)
-        {
-            FetchInventoryPacket fetch = new FetchInventoryPacket();
-            fetch.AgentData = new FetchInventoryPacket.AgentDataBlock();
-            fetch.AgentData.AgentID = _Client.Self.AgentID;
-            fetch.AgentData.SessionID = _Client.Self.SessionID;
-
-            fetch.InventoryData = new FetchInventoryPacket.InventoryDataBlock[1];
-            fetch.InventoryData[0] = new FetchInventoryPacket.InventoryDataBlock();
-            fetch.InventoryData[0].ItemID = itemID;
-            fetch.InventoryData[0].OwnerID = ownerID;
-
-            _Client.Network.SendPacket(fetch);
-        }
-
-        /// <summary>
-        /// Request inventory items
-        /// </summary>
-        /// <param name="itemIDs">Inventory items to request</param>
-        /// <param name="ownerIDs">Owners of the inventory items</param>
-        /// <seealso cref="InventoryManager.OnItemReceived"/>
-        public void RequestFetchInventory(List<UUID> itemIDs, List<UUID> ownerIDs)
-        {
-            if (itemIDs.Count != ownerIDs.Count)
-                throw new ArgumentException("itemIDs and ownerIDs must contain the same number of entries");
-
-            FetchInventoryPacket fetch = new FetchInventoryPacket();
-            fetch.AgentData = new FetchInventoryPacket.AgentDataBlock();
-            fetch.AgentData.AgentID = _Client.Self.AgentID;
-            fetch.AgentData.SessionID = _Client.Self.SessionID;
-
-            fetch.InventoryData = new FetchInventoryPacket.InventoryDataBlock[itemIDs.Count];
-            for (int i = 0; i < itemIDs.Count; i++)
-            {
-                fetch.InventoryData[i] = new FetchInventoryPacket.InventoryDataBlock();
-                fetch.InventoryData[i].ItemID = itemIDs[i];
-                fetch.InventoryData[i].OwnerID = ownerIDs[i];
-            }
-
-            _Client.Network.SendPacket(fetch);
-        }
-
-        /// <summary>
-        /// Get contents of a folder
-        /// </summary>
-        /// <param name="folder">The <seealso cref="UUID"/> of the folder to search</param>
-        /// <param name="owner">The <seealso cref="UUID"/> of the folders owner</param>
-        /// <param name="folders">true to retrieve folders</param>
-        /// <param name="items">true to retrieve items</param>
-        /// <param name="order">sort order to return results in</param>
-        /// <param name="timeoutMS">a integer representing the number of milliseconds to wait for results</param>
-        /// <returns>A list of inventory items matching search criteria within folder</returns>
-        /// <seealso cref="InventoryManager.RequestFolderContents"/>
-        /// <remarks>InventoryFolder.DescendentCount will only be accurate if both folders and items are
-        /// requested</remarks>
-        public List<InventoryBase> FolderContents(UUID folder, UUID owner, bool folders, bool items,
-            InventorySortOrder order, int timeoutMS)
-        {
-            List<InventoryBase> objects = null;
-            AutoResetEvent fetchEvent = new AutoResetEvent(false);
-
-            FolderUpdatedCallback callback =
-                delegate(UUID folderID)
-                {
-                    if (folderID == folder
-                        && _Store[folder] is InventoryFolder)
-                    {
-                        // InventoryDescendentsHandler only stores DescendendCount if both folders and items are fetched.
-                        if (_Store.GetContents(folder).Count >= ((InventoryFolder)_Store[folder]).DescendentCount)
-                        {
-                            
-                            fetchEvent.Set();
-                        }
-                    }
-                    else
-                    {
-                        fetchEvent.Set();
-                    }
-                };
-
-            OnFolderUpdated += callback;
-
-            RequestFolderContents(folder, owner, folders, items, order);
-            if (fetchEvent.WaitOne(timeoutMS, false))
-                objects = _Store.GetContents(folder);
-
-            OnFolderUpdated -= callback;
-
-            return objects;
-        }
-
-        /// <summary>
-        /// Request the contents of an inventory folder
-        /// </summary>
-        /// <param name="folder">The folder to search</param>
-        /// <param name="owner">The folder owners <seealso cref="UUID"/></param>
-        /// <param name="folders">true to return <seealso cref="InventoryManager.InventoryFolder"/>s contained in folder</param>
-        /// <param name="items">true to return <seealso cref="InventoryManager.InventoryItem"/>s containd in folder</param>
-        /// <param name="order">the sort order to return items in</param>
-        /// <seealso cref="InventoryManager.FolderContents"/>
-        public void RequestFolderContents(UUID folder, UUID owner, bool folders, bool items, 
-            InventorySortOrder order)
-        {
-            FetchInventoryDescendentsPacket fetch = new FetchInventoryDescendentsPacket();
-            fetch.AgentData.AgentID = _Client.Self.AgentID;
-            fetch.AgentData.SessionID = _Client.Self.SessionID;
-
-            fetch.InventoryData.FetchFolders = folders;
-            fetch.InventoryData.FetchItems = items;
-            fetch.InventoryData.FolderID = folder;
-            fetch.InventoryData.OwnerID = owner;
-            fetch.InventoryData.SortOrder = (int)order;
-
-            _Client.Network.SendPacket(fetch);
-        }
-
-        #endregion Fetch
-
-        #region Find
-
-        /// <summary>
-        /// Returns the UUID of the folder (category) that defaults to
-        /// containing 'type'. The folder is not necessarily only for that
-        /// type
-        /// </summary>
-        /// <remarks>This will return the root folder if one does not exist</remarks>
-        /// <param name="type"></param>
-        /// <returns>The UUID of the desired folder if found, the UUID of the RootFolder
-        /// if not found, or UUID.Zero on failure</returns>
-        public UUID FindFolderForType(AssetType type)
-        {
-            if (_Store == null)
-            {
-                Logger.Log("Inventory is null, FindFolderForType() lookup cannot continue",
-                    Helpers.LogLevel.Error, _Client);
-                return UUID.Zero;
-            }
-
-            // Folders go in the root
-            if (type == AssetType.Folder)
-                return _Store.RootFolder.UUID;
-
-            // Loop through each top-level directory and check if PreferredType
-            // matches the requested type
-            List<InventoryBase> contents = _Store.GetContents(_Store.RootFolder.UUID);
-            foreach (InventoryBase inv in contents)
-            {
-                if (inv is InventoryFolder)
-                {
-                    InventoryFolder folder = inv as InventoryFolder;
-
-                    if (folder.PreferredType == type)
-                        return folder.UUID;
-                }
-            }
-
-            // No match found, return Root Folder ID
-            return _Store.RootFolder.UUID;
-        }
-
-        /// <summary>
-        /// Find an object in inventory using a specific path to search
-        /// </summary>
-        /// <param name="baseFolder">The folder to begin the search in</param>
-        /// <param name="inventoryOwner">The object owners <seealso cref="UUID"/></param>
-        /// <param name="path">A string path to search</param>
-        /// <param name="timeoutMS">milliseconds to wait for a reply</param>
-        /// <returns>Found items <seealso cref="UUID"/> or <seealso cref="UUID.Zero"/> if 
-        /// timeout occurs or item is not found</returns>
-        public UUID FindObjectByPath(UUID baseFolder, UUID inventoryOwner, string path, int timeoutMS)
-        {
-            AutoResetEvent findEvent = new AutoResetEvent(false);
-            UUID foundItem = UUID.Zero;
-
-            FindObjectByPathCallback callback =
-                delegate(string thisPath, UUID inventoryObjectID)
-                {
-                    if (thisPath == path)
-                    {
-                        foundItem = inventoryObjectID;
-                        findEvent.Set();
-                    }
-                };
-
-            OnFindObjectByPath += callback;
-
-            RequestFindObjectByPath(baseFolder, inventoryOwner, path);
-            findEvent.WaitOne(timeoutMS, false);
-
-            OnFindObjectByPath -= callback;
-
-            return foundItem;
-        }
-
-        /// <summary>
-        /// Find inventory items by path
-        /// </summary>
-        /// <param name="baseFolder">The folder to begin the search in</param>
-        /// <param name="inventoryOwner">The object owners <seealso cref="UUID"/></param>
-        /// <param name="path">A string path to search, folders/objects separated by a '/'</param>
-        /// <remarks>Results are sent to the <seealso cref="InventoryManager.OnFindObjectByPath"/> event</remarks>
-        public void RequestFindObjectByPath(UUID baseFolder, UUID inventoryOwner, string path)
-        {
-            if (path == null || path.Length == 0)
-                throw new ArgumentException("Empty path is not supported");
-
-            // Store this search
-            InventorySearch search;
-            search.Folder = baseFolder;
-            search.Owner = inventoryOwner;
-            search.Path = path.Split('/');
-            search.Level = 0;
-            lock (_Searches) _Searches.Add(search);
-
-            // Start the search
-            RequestFolderContents(baseFolder, inventoryOwner, true, true, InventorySortOrder.ByName);
-        }
-
-        /// <summary>
-        /// Search inventory Store object for an item or folder
-        /// </summary>
-        /// <param name="baseFolder">The folder to begin the search in</param>
-        /// <param name="path">An array which creates a path to search</param>
-        /// <param name="level">Number of levels below baseFolder to conduct searches</param>
-        /// <param name="firstOnly">if True, will stop searching after first match is found</param>
-        /// <returns>A list of inventory items found</returns>
-        public List<InventoryBase> LocalFind(UUID baseFolder, string[] path, int level, bool firstOnly)
-        {
-            List<InventoryBase> objects = new List<InventoryBase>();
-            //List<InventoryFolder> folders = new List<InventoryFolder>();
-            List<InventoryBase> contents = _Store.GetContents(baseFolder);
-
-            foreach (InventoryBase inv in contents)
-            {
-                if (inv.Name.CompareTo(path[level]) == 0)
-                {
-                    if (level == path.Length - 1)
-                    {
-                        objects.Add(inv);
-                        if (firstOnly) return objects;
-                    }
-                    else if (inv is InventoryFolder)
-                        objects.AddRange(LocalFind(inv.UUID, path, level + 1, firstOnly));
-                }
-            }
-
-            return objects;
-        }
-
-        #endregion Find
-
-        #region Move/Rename
-        
-        /// <summary>
-        /// Move an inventory item or folder to a new location
-        /// </summary>
-        /// <param name="item">The <seealso cref="T:InventoryBase"/> item or folder to move</param>
-        /// <param name="newParent">The <seealso cref="T:InventoryFolder"/> to move item or folder to</param>
-        public void Move(InventoryBase item, InventoryFolder newParent)
-        {
-            if (item is InventoryFolder)
-                MoveFolder(item.UUID, newParent.UUID);
-            else
-                MoveItem(item.UUID, newParent.UUID);
-        }
-
-        /// <summary>
-        /// Move an inventory item or folder to a new location and change its name
-        /// </summary>
-        /// <param name="item">The <seealso cref="T:InventoryBase"/> item or folder to move</param>
-        /// <param name="newParent">The <seealso cref="T:InventoryFolder"/> to move item or folder to</param>
-        /// <param name="newName">The name to change the item or folder to</param>
-        public void Move(InventoryBase item, InventoryFolder newParent, string newName)
-        {
-            if (item is InventoryFolder)
-                MoveFolder(item.UUID, newParent.UUID, newName);
-            else
-                MoveItem(item.UUID, newParent.UUID, newName);
-        }
-
-        /// <summary>
-        /// Move and rename a folder
-        /// </summary>
-        /// <param name="folderID">The source folders <seealso cref="UUID"/></param>
-        /// <param name="newparentID">The destination folders <seealso cref="UUID"/></param>
-        /// <param name="newName">The name to change the folder to</param>
-        public void MoveFolder(UUID folderID, UUID newparentID, string newName)
-        {
-            lock (Store)
-            {
-                if (_Store.Contains(folderID))
-                {
-                    InventoryBase inv = Store[folderID];
-                    inv.Name = newName;
-                    _Store.UpdateNodeFor(inv);
-                }
-            }
-
-            UpdateInventoryFolderPacket move = new UpdateInventoryFolderPacket();
-            move.AgentData.AgentID = _Client.Self.AgentID;
-            move.AgentData.SessionID = _Client.Self.SessionID;
-            move.FolderData = new UpdateInventoryFolderPacket.FolderDataBlock[1];
-            move.FolderData[0] = new UpdateInventoryFolderPacket.FolderDataBlock();
-            move.FolderData[0].FolderID = folderID;
-            move.FolderData[0].ParentID = newparentID;
-            move.FolderData[0].Name = Utils.StringToBytes(newName);
-            move.FolderData[0].Type = -1;
-
-            _Client.Network.SendPacket(move);
-        }
-
-        /// <summary>
-        /// Move a folder
-        /// </summary>
-        /// <param name="folderID">The source folders <seealso cref="UUID"/></param>
-        /// <param name="newParentID">The destination folders <seealso cref="UUID"/></param>
-        public void MoveFolder(UUID folderID, UUID newParentID)
-        {
-            lock (Store)
-            {
-                if (_Store.Contains(folderID))
-                {
-                    InventoryBase inv = Store[folderID];
-                    inv.ParentUUID = newParentID;
-                    _Store.UpdateNodeFor(inv);
-                }
-            }
-
-            MoveInventoryFolderPacket move = new MoveInventoryFolderPacket();
-            move.AgentData.AgentID = _Client.Self.AgentID;
-            move.AgentData.SessionID = _Client.Self.SessionID;
-            move.AgentData.Stamp = false; //FIXME: ??
-
-            move.InventoryData = new MoveInventoryFolderPacket.InventoryDataBlock[1];
-            move.InventoryData[0] = new MoveInventoryFolderPacket.InventoryDataBlock();
-            move.InventoryData[0].FolderID = folderID;
-            move.InventoryData[0].ParentID = newParentID;
-            
-            _Client.Network.SendPacket(move);
-        }
- 
-        /// <summary>
-        /// Move multiple folders, the keys in the Dictionary parameter,
-        /// to a new parents, the value of that folder's key.
-        /// </summary>
-        /// <param name="foldersNewParents">A Dictionary containing the 
-        /// <seealso cref="UUID"/> of the source as the key, and the 
-        /// <seealso cref="UUID"/> of the destination as the value</param>
-        public void MoveFolders(Dictionary<UUID, UUID> foldersNewParents)
-        {
-            // FIXME: Use two List<UUID> to stay consistent
-
-            lock (Store)
-            {
-                foreach (KeyValuePair<UUID, UUID> entry in foldersNewParents)
-                {
-                    if (_Store.Contains(entry.Key))
-                    {
-                        InventoryBase inv = _Store[entry.Key];
-                        inv.ParentUUID = entry.Value;
-                        _Store.UpdateNodeFor(inv);
-                    }
-                }
-            }
-
-            //TODO: Test if this truly supports multiple-folder move
-            MoveInventoryFolderPacket move = new MoveInventoryFolderPacket();
-            move.AgentData.AgentID = _Client.Self.AgentID;
-            move.AgentData.SessionID = _Client.Self.SessionID;
-            move.AgentData.Stamp = false; //FIXME: ??
-
-            move.InventoryData = new MoveInventoryFolderPacket.InventoryDataBlock[foldersNewParents.Count];
-
-            int index = 0;
-            foreach (KeyValuePair<UUID, UUID> folder in foldersNewParents)
-            {
-                MoveInventoryFolderPacket.InventoryDataBlock block = new MoveInventoryFolderPacket.InventoryDataBlock();
-                block.FolderID = folder.Key;
-                block.ParentID = folder.Value;
-                move.InventoryData[index++] = block;
-            }
-
-            _Client.Network.SendPacket(move);
-        }
-
-
-        /// <summary>
-        /// Move an inventory item to a new folder
-        /// </summary>
-        /// <param name="itemID">The <seealso cref="UUID"/> of the source item to move</param>
-        /// <param name="folderID">The <seealso cref="UUID"/> of the destination folder</param>
-        public void MoveItem(UUID itemID, UUID folderID)
-        {
-            MoveItem(itemID, folderID, String.Empty);
-        }
-
-        /// <summary>
-        /// Move and rename an inventory item
-        /// </summary>
-        /// <param name="itemID">The <seealso cref="UUID"/> of the source item to move</param>
-        /// <param name="folderID">The <seealso cref="UUID"/> of the destination folder</param>
-        /// <param name="newName">The name to change the folder to</param>
-        public void MoveItem(UUID itemID, UUID folderID, string newName)
-        {
-            lock (_Store)
-            {
-                    if (_Store.Contains(itemID))
-                    {
-                        InventoryBase inv = _Store[itemID];
-                        inv.ParentUUID = folderID;
-                        _Store.UpdateNodeFor(inv);
-                    }
-            }
-
-            MoveInventoryItemPacket move = new MoveInventoryItemPacket();
-            move.AgentData.AgentID = _Client.Self.AgentID;
-            move.AgentData.SessionID = _Client.Self.SessionID;
-            move.AgentData.Stamp = false; //FIXME: ??
-
-            move.InventoryData = new MoveInventoryItemPacket.InventoryDataBlock[1];
-            move.InventoryData[0] = new MoveInventoryItemPacket.InventoryDataBlock();
-            move.InventoryData[0].ItemID = itemID;
-            move.InventoryData[0].FolderID = folderID;
-            move.InventoryData[0].NewName = Utils.StringToBytes(newName);
-
-            _Client.Network.SendPacket(move);
-        }
-
-        /// <summary>
-        /// Move multiple inventory items to new locations
-        /// </summary>
-        /// <param name="itemsNewParents">A Dictionary containing the 
-        /// <seealso cref="UUID"/> of the source item as the key, and the 
-        /// <seealso cref="UUID"/> of the destination folder as the value</param>
-        public void MoveItems(Dictionary<UUID, UUID> itemsNewParents)
-        {
-            lock (_Store)
-            {
-                foreach (KeyValuePair<UUID, UUID> entry in itemsNewParents)
-                {
-                    if (_Store.Contains(entry.Key))
-                    {
-                        InventoryBase inv = _Store[entry.Key];
-                        inv.ParentUUID = entry.Value;
-                        _Store.UpdateNodeFor(inv);
-                    }
-                }
-            }
-
-            MoveInventoryItemPacket move = new MoveInventoryItemPacket();
-            move.AgentData.AgentID = _Client.Self.AgentID;
-            move.AgentData.SessionID = _Client.Self.SessionID;
-            move.AgentData.Stamp = false; //FIXME: ??
-
-            move.InventoryData = new MoveInventoryItemPacket.InventoryDataBlock[itemsNewParents.Count];
-
-            int index = 0;
-            foreach (KeyValuePair<UUID, UUID> entry in itemsNewParents)
-            {
-                MoveInventoryItemPacket.InventoryDataBlock block = new MoveInventoryItemPacket.InventoryDataBlock();
-                block.ItemID = entry.Key;
-                block.FolderID = entry.Value;
-                block.NewName = new byte[0];
-                move.InventoryData[index++] = block;
-            }
-
-            _Client.Network.SendPacket(move);
-        }
-
-        #endregion Move
-
-        #region Remove
-
-        /// <summary>
-        /// Remove descendants of a folder
-        /// </summary>
-        /// <param name="folder">The <seealso cref="UUID"/> of the folder</param>
-        public void RemoveDescendants(UUID folder)
-        {
-            PurgeInventoryDescendentsPacket purge = new PurgeInventoryDescendentsPacket();
-            purge.AgentData.AgentID = _Client.Self.AgentID;
-            purge.AgentData.SessionID = _Client.Self.SessionID;
-            purge.InventoryData.FolderID = folder;
-            _Client.Network.SendPacket(purge);
-
-            // Update our local copy
-            lock (_Store)
-            {
-                if (_Store.Contains(folder))
-                {
-                    List<InventoryBase> contents = _Store.GetContents(folder);
-                    foreach (InventoryBase obj in contents)
-                    {
-                        _Store.RemoveNodeFor(obj);
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Remove a single item from inventory
-        /// </summary>
-        /// <param name="item">The <seealso cref="UUID"/> of the inventory item to remove</param>
-        public void RemoveItem(UUID item)
-        {
-            List<UUID> items = new List<UUID>(1);
-            items.Add(item);
-
-            Remove(items, null);
-        }
-
-        /// <summary>
-        /// Remove a folder from inventory
-        /// </summary>
-        /// <param name="folder">The <seealso cref="UUID"/> of the folder to remove</param>
-        public void RemoveFolder(UUID folder)
-        {
-            List<UUID> folders = new List<UUID>(1);
-            folders.Add(folder);
-
-            Remove(null, folders);
-        }
-
-        /// <summary>
-        /// Remove multiple items or folders from inventory
-        /// </summary>
-        /// <param name="items">A List containing the <seealso cref="UUID"/>s of items to remove</param>
-        /// <param name="folders">A List containing the <seealso cref="UUID"/>s of the folders to remove</param>
-        public void Remove(List<UUID> items, List<UUID> folders)
-        {
-            if ((items == null || items.Count == 0) && (folders == null || folders.Count == 0))
-                return;
-
-            RemoveInventoryObjectsPacket rem = new RemoveInventoryObjectsPacket();
-            rem.AgentData.AgentID = _Client.Self.AgentID;
-            rem.AgentData.SessionID = _Client.Self.SessionID;
-
-            if (items == null || items.Count == 0)
-            {
-                // To indicate that we want no items removed:
-                rem.ItemData = new RemoveInventoryObjectsPacket.ItemDataBlock[1];
-                rem.ItemData[0] = new RemoveInventoryObjectsPacket.ItemDataBlock();
-                rem.ItemData[0].ItemID = UUID.Zero;
-            }
-            else
-            {
-                lock (_Store)
-                {
-                    rem.ItemData = new RemoveInventoryObjectsPacket.ItemDataBlock[items.Count];
-                    for (int i = 0; i < items.Count; i++)
-                    {
-                        rem.ItemData[i] = new RemoveInventoryObjectsPacket.ItemDataBlock();
-                        rem.ItemData[i].ItemID = items[i];
-
-                        // Update local copy
-                        if (_Store.Contains(items[i]))
-                            _Store.RemoveNodeFor(Store[items[i]]);
-                    }
-                }
-            }
-
-            if (folders == null || folders.Count == 0)
-            {
-                // To indicate we want no folders removed:
-                rem.FolderData = new RemoveInventoryObjectsPacket.FolderDataBlock[1];
-                rem.FolderData[0] = new RemoveInventoryObjectsPacket.FolderDataBlock();
-                rem.FolderData[0].FolderID = UUID.Zero;
-            }
-            else
-            {
-                lock (_Store)
-                {
-                    rem.FolderData = new RemoveInventoryObjectsPacket.FolderDataBlock[folders.Count];
-                    for (int i = 0; i < folders.Count; i++)
-                    {
-                        rem.FolderData[i] = new RemoveInventoryObjectsPacket.FolderDataBlock();
-                        rem.FolderData[i].FolderID = folders[i];
-
-                        // Update local copy
-                        if (_Store.Contains(folders[i]))
-                            _Store.RemoveNodeFor(Store[folders[i]]);
-                    }
-                }
-            }
-            _Client.Network.SendPacket(rem);
-        }
-    
-        /// <summary>
-        /// Empty the Lost and Found folder
-        /// </summary>
-        public void EmptyLostAndFound()
-        {
-            EmptySystemFolder(AssetType.LostAndFoundFolder);
-        }
-
-        /// <summary>
-        /// Empty the Trash folder
-        /// </summary>
-        public void EmptyTrash()
-        {
-            EmptySystemFolder(AssetType.TrashFolder);
-        }
-
-        private void EmptySystemFolder(AssetType folderType)
-        {
-            List<InventoryBase> items = _Store.GetContents(_Store.RootFolder);
-
-            UUID folderKey = UUID.Zero;
-            foreach (InventoryBase item in items)
-            {
-                if ((item as InventoryFolder) != null)
-                {
-                    InventoryFolder folder = item as InventoryFolder;
-                    if (folder.PreferredType == folderType)
-                    {
-                        folderKey = folder.UUID;
-                        break;
-                    }
-                }
-            }
-            items = _Store.GetContents(folderKey);
-            List<UUID> remItems = new List<UUID>();
-            List<UUID> remFolders = new List<UUID>();
-            foreach (InventoryBase item in items)
-            {
-                if ((item as InventoryFolder) != null)
-                {
-                    remFolders.Add(item.UUID);
-                }
-                else
-                {
-                    remItems.Add(item.UUID);
-                }
-            }
-            Remove(remItems, remFolders);
-        }   
-        #endregion Remove
-
-        #region Create
-        
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="parentFolder"></param>
-        /// <param name="name"></param>
-        /// <param name="description"></param>
-        /// <param name="type"></param>
-        /// <param name="assetTransactionID">Proper use is to upload the inventory's asset first, then provide the Asset's TransactionID here.</param>
-        /// <param name="invType"></param>
-        /// <param name="nextOwnerMask"></param>
-        /// <param name="callback"></param>
-        public void RequestCreateItem(UUID parentFolder, string name, string description, AssetType type, UUID assetTransactionID,
-            InventoryType invType, PermissionMask nextOwnerMask, ItemCreatedCallback callback)
-        {
-            // Even though WearableType 0 is Shape, in this context it is treated as NOT_WEARABLE
-            RequestCreateItem(parentFolder, name, description, type, assetTransactionID, invType, (WearableType)0, nextOwnerMask, 
-                callback);
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="parentFolder"></param>
-        /// <param name="name"></param>
-        /// <param name="description"></param>
-        /// <param name="type"></param>
-        /// <param name="assetTransactionID">Proper use is to upload the inventory's asset first, then provide the Asset's TransactionID here.</param>
-        /// <param name="invType"></param>
-        /// <param name="wearableType"></param>
-        /// <param name="nextOwnerMask"></param>
-        /// <param name="callback"></param>
-        public void RequestCreateItem(UUID parentFolder, string name, string description, AssetType type, UUID assetTransactionID,
-            InventoryType invType, WearableType wearableType, PermissionMask nextOwnerMask, ItemCreatedCallback callback)
-        {
-            CreateInventoryItemPacket create = new CreateInventoryItemPacket();
-            create.AgentData.AgentID = _Client.Self.AgentID;
-            create.AgentData.SessionID = _Client.Self.SessionID;
-
-            create.InventoryBlock.CallbackID = RegisterItemCreatedCallback(callback);
-            create.InventoryBlock.FolderID = parentFolder;
-            create.InventoryBlock.TransactionID = assetTransactionID;
-            create.InventoryBlock.NextOwnerMask = (uint)nextOwnerMask;
-            create.InventoryBlock.Type = (sbyte)type;
-            create.InventoryBlock.InvType = (sbyte)invType;
-            create.InventoryBlock.WearableType = (byte)wearableType;
-            create.InventoryBlock.Name = Utils.StringToBytes(name);
-            create.InventoryBlock.Description = Utils.StringToBytes(description);
-
-            _Client.Network.SendPacket(create);
-        }
-
-        /// <summary>
-        /// Creates a new inventory folder
-        /// </summary>
-        /// <param name="parentID">ID of the folder to put this folder in</param>
-        /// <param name="name">Name of the folder to create</param>
-        /// <returns>The UUID of the newly created folder</returns>
-        public UUID CreateFolder(UUID parentID, string name)
-        {
-            return CreateFolder(parentID, name, AssetType.Unknown);
-        }
-
-        /// <summary>
-        /// Creates a new inventory folder
-        /// </summary>
-        /// <param name="parentID">ID of the folder to put this folder in</param>
-        /// <param name="name">Name of the folder to create</param>
-        /// <param name="preferredType">Sets this folder as the default folder
-        /// for new assets of the specified type. Use <code>AssetType.Unknown</code>
-        /// to create a normal folder, otherwise it will likely create a
-        /// duplicate of an existing folder type</param>
-        /// <returns>The UUID of the newly created folder</returns>
-        /// <remarks>If you specify a preferred type of <code>AsseType.Folder</code>
-        /// it will create a new root folder which may likely cause all sorts
-        /// of strange problems</remarks>
-        public UUID CreateFolder(UUID parentID, string name, AssetType preferredType)
-        {
-            UUID id = UUID.Random();
-
-            // Assign a folder name if one is not already set
-            if (String.IsNullOrEmpty(name))
-            {
-                if (preferredType >= AssetType.Texture && preferredType <= AssetType.Gesture)
-                {
-                    name = _NewFolderNames[(int)preferredType];
-                }
-                else
-                {
-                    name = "New Folder";
-                }
-            }
-
-            // Create the new folder locally
-            InventoryFolder newFolder = new InventoryFolder(id);
-            newFolder.Version = 1;
-            newFolder.DescendentCount = 0;
-            newFolder.ParentUUID = parentID;
-            newFolder.PreferredType = preferredType;
-            newFolder.Name = name;
-            newFolder.OwnerID = _Client.Self.AgentID;
-
-            // Update the local store
-            try { _Store[newFolder.UUID] = newFolder; }
-            catch (InventoryException ie) { Logger.Log(ie.Message, Helpers.LogLevel.Warning, _Client, ie); }
-
-            // Create the create folder packet and send it
-            CreateInventoryFolderPacket create = new CreateInventoryFolderPacket();
-            create.AgentData.AgentID = _Client.Self.AgentID;
-            create.AgentData.SessionID = _Client.Self.SessionID;
-
-            create.FolderData.FolderID = id;
-            create.FolderData.ParentID = parentID;
-            create.FolderData.Type = (sbyte)preferredType;
-            create.FolderData.Name = Utils.StringToBytes(name);
-
-            _Client.Network.SendPacket(create);
-
-            return id;
-        }
-
-        public void RequestCreateItemFromAsset(byte[] data, string name, string description, AssetType assetType,
-            InventoryType invType, UUID folderID, CapsClient.ProgressCallback progCallback, ItemCreatedFromAssetCallback callback)
-        {
-            if (_Client.Network.CurrentSim == null || _Client.Network.CurrentSim.Caps == null)
-                throw new Exception("NewFileAgentInventory capability is not currently available");
-
-            Uri url = _Client.Network.CurrentSim.Caps.CapabilityURI("NewFileAgentInventory");
-
-            if (url != null)
-            {
-                OSDMap query = new OSDMap();
-                query.Add("folder_id", OSD.FromUUID(folderID));
-                query.Add("asset_type", OSD.FromString(AssetTypeToString(assetType)));
-                query.Add("inventory_type", OSD.FromString(InventoryTypeToString(invType)));
-                query.Add("name", OSD.FromString(name));
-                query.Add("description", OSD.FromString(description));
-
-                // Make the request
-                CapsClient request = new CapsClient(url);
-                request.OnComplete += new CapsClient.CompleteCallback(CreateItemFromAssetResponse);
-                request.UserData = new object[] { progCallback, callback, data };
-
-                request.StartRequest(query);
-            }
-            else
-            {
-                throw new Exception("NewFileAgentInventory capability is not currently available");
-            }
-        }
-
-        #endregion Create
-
-        #region Copy
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="item"></param>
-        /// <param name="newParent"></param>
-        /// <param name="newName"></param>
-        /// <param name="callback"></param>
-        public void RequestCopyItem(UUID item, UUID newParent, string newName, ItemCopiedCallback callback)
-        {
-            RequestCopyItem(item, newParent, newName, _Client.Self.AgentID, callback);
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="item"></param>
-        /// <param name="newParent"></param>
-        /// <param name="newName"></param>
-        /// <param name="oldOwnerID"></param>
-        /// <param name="callback"></param>
-        public void RequestCopyItem(UUID item, UUID newParent, string newName, UUID oldOwnerID,
-            ItemCopiedCallback callback)
-        {
-            List<UUID> items = new List<UUID>(1);
-            items.Add(item);
-
-            List<UUID> folders = new List<UUID>(1);
-            folders.Add(newParent);
-
-            List<string> names = new List<string>(1);
-            names.Add(newName);
-
-            RequestCopyItems(items, folders, names, oldOwnerID, callback);
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="items"></param>
-        /// <param name="targetFolders"></param>
-        /// <param name="newNames"></param>
-        /// <param name="oldOwnerID"></param>
-        /// <param name="callback"></param>
-        public void RequestCopyItems(List<UUID> items, List<UUID> targetFolders, List<string> newNames,
-            UUID oldOwnerID, ItemCopiedCallback callback)
-        {
-            if (items.Count != targetFolders.Count || (newNames != null && items.Count != newNames.Count))
-                throw new ArgumentException("All list arguments must have an equal number of entries");
-
-            uint callbackID = RegisterItemsCopiedCallback(callback);
-
-            CopyInventoryItemPacket copy = new CopyInventoryItemPacket();
-            copy.AgentData.AgentID = _Client.Self.AgentID;
-            copy.AgentData.SessionID = _Client.Self.SessionID;
-
-            copy.InventoryData = new CopyInventoryItemPacket.InventoryDataBlock[items.Count];
-            for (int i = 0; i < items.Count; ++i)
-            {
-                copy.InventoryData[i] = new CopyInventoryItemPacket.InventoryDataBlock();
-                copy.InventoryData[i].CallbackID = callbackID;
-                copy.InventoryData[i].NewFolderID = targetFolders[i];
-                copy.InventoryData[i].OldAgentID = oldOwnerID;
-                copy.InventoryData[i].OldItemID = items[i];
-
-                if (newNames != null && !String.IsNullOrEmpty(newNames[i]))
-                    copy.InventoryData[i].NewName = Utils.StringToBytes(newNames[i]);
-                else
-                    copy.InventoryData[i].NewName = new byte[0];
-            }
-
-            _Client.Network.SendPacket(copy);
-        }
-
-        /// <summary>
-        /// Request a copy of an asset embedded within a notecard
-        /// </summary>
-        /// <param name="objectID">Usually UUID.Zero for copying an asset from a notecard</param>
-        /// <param name="notecardID">UUID of the notecard to request an asset from</param>
-        /// <param name="folderID">Target folder for asset to go to in your inventory</param>
-        /// <param name="itemID">UUID of the embedded asset</param>
-        /// <param name="callback">callback to run when item is copied to inventory</param>
-        public void RequestCopyItemFromNotecard(UUID objectID, UUID notecardID, UUID folderID, UUID itemID, ItemCopiedCallback callback)
-        {
-            CopyInventoryFromNotecardPacket copy = new CopyInventoryFromNotecardPacket();
-            copy.AgentData.AgentID = _Client.Self.AgentID;
-            copy.AgentData.SessionID = _Client.Self.SessionID;
-
-            copy.NotecardData.ObjectID = objectID;
-            copy.NotecardData.NotecardItemID = notecardID;
-
-            copy.InventoryData = new CopyInventoryFromNotecardPacket.InventoryDataBlock[1];
-            copy.InventoryData[0] = new CopyInventoryFromNotecardPacket.InventoryDataBlock();
-            copy.InventoryData[0].FolderID = folderID;
-            copy.InventoryData[0].ItemID = itemID;
-           
-            _ItemCopiedCallbacks[0] = callback; //Notecards always use callback ID 0
-
-            _Client.Network.SendPacket(copy);
-        }
-
-        #endregion Copy
-
-        #region Update
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="item"></param>
-        public void RequestUpdateItem(InventoryItem item)
-        {
-            List<InventoryItem> items = new List<InventoryItem>(1);
-            items.Add(item);
-
-            RequestUpdateItems(items, UUID.Random());
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="items"></param>
-        public void RequestUpdateItems(List<InventoryItem> items)
-        {
-            RequestUpdateItems(items, UUID.Random());
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="items"></param>
-        /// <param name="transactionID"></param>
-        public void RequestUpdateItems(List<InventoryItem> items, UUID transactionID)
-        {
-            UpdateInventoryItemPacket update = new UpdateInventoryItemPacket();
-            update.AgentData.AgentID = _Client.Self.AgentID;
-            update.AgentData.SessionID = _Client.Self.SessionID;
-            update.AgentData.TransactionID = transactionID;
-
-            update.InventoryData = new UpdateInventoryItemPacket.InventoryDataBlock[items.Count];
-            for (int i = 0; i < items.Count; i++)
-            {
-                InventoryItem item = items[i];
-
-                UpdateInventoryItemPacket.InventoryDataBlock block = new UpdateInventoryItemPacket.InventoryDataBlock();
-                block.BaseMask = (uint)item.Permissions.BaseMask;
-                block.CRC = ItemCRC(item);
-                block.CreationDate = (int)Utils.DateTimeToUnixTime(item.CreationDate);
-                block.CreatorID = item.CreatorID;
-                block.Description = Utils.StringToBytes(item.Description);
-                block.EveryoneMask = (uint)item.Permissions.EveryoneMask;
-                block.Flags = (uint)item.Flags;
-                block.FolderID = item.ParentUUID;
-                block.GroupID = item.GroupID;
-                block.GroupMask = (uint)item.Permissions.GroupMask;
-                block.GroupOwned = item.GroupOwned;
-                block.InvType = (sbyte)item.InventoryType;
-                block.ItemID = item.UUID;
-                block.Name = Utils.StringToBytes(item.Name);
-                block.NextOwnerMask = (uint)item.Permissions.NextOwnerMask;
-                block.OwnerID = item.OwnerID;
-                block.OwnerMask = (uint)item.Permissions.OwnerMask;
-                block.SalePrice = item.SalePrice;
-                block.SaleType = (byte)item.SaleType;
-                block.TransactionID = UUID.Zero;
-                block.Type = (sbyte)item.AssetType;
-
-                update.InventoryData[i] = block;
-            }
-
-            _Client.Network.SendPacket(update);
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="data"></param>
-        /// <param name="notecardID"></param>
-        /// <param name="callback"></param>
-        public void RequestUploadNotecardAsset(byte[] data, UUID notecardID, NotecardUploadedAssetCallback callback)
-        {
-            if (_Client.Network.CurrentSim == null || _Client.Network.CurrentSim.Caps == null)
-                throw new Exception("UpdateNotecardAgentInventory capability is not currently available");
-
-            Uri url = _Client.Network.CurrentSim.Caps.CapabilityURI("UpdateNotecardAgentInventory");
-
-            if (url != null)
-            {
-                OSDMap query = new OSDMap();
-                query.Add("item_id", OSD.FromUUID(notecardID));
-
-                byte[] postData = StructuredData.OSDParser.SerializeLLSDXmlBytes(query);
-
-                // Make the request
-                CapsClient request = new CapsClient(url);
-                request.OnComplete += new CapsClient.CompleteCallback(UploadNotecardAssetResponse);
-                request.UserData = new object[2] { new KeyValuePair<NotecardUploadedAssetCallback, byte[]>(callback, data), notecardID };
-                request.StartRequest(postData);
-            }
-            else
-            {
-                throw new Exception("UpdateNotecardAgentInventory capability is not currently available");
-            }
-        }
-        #endregion Update
-
-        #region Rez/Give
-
-        /// <summary>
-        /// Rez an object from inventory
-        /// </summary>
-        /// <param name="simulator">Simulator to place object in</param>
-        /// <param name="rotation">Rotation of the object when rezzed</param>
-        /// <param name="position">Vector of where to place object</param>
-        /// <param name="item">InventoryItem object containing item details</param>
-        public UUID RequestRezFromInventory(Simulator simulator, Quaternion rotation, Vector3 position,
-            InventoryItem item)
-        {
-            return RequestRezFromInventory(simulator, rotation, position, item, _Client.Self.ActiveGroup,
-                UUID.Random(), false);
-        }
-
-        /// <summary>
-        /// Rez an object from inventory
-        /// </summary>
-        /// <param name="simulator">Simulator to place object in</param>
-        /// <param name="rotation">Rotation of the object when rezzed</param>
-        /// <param name="position">Vector of where to place object</param>
-        /// <param name="item">InventoryItem object containing item details</param>
-        /// <param name="groupOwner">UUID of group to own the object</param>
-        public UUID RequestRezFromInventory(Simulator simulator, Quaternion rotation, Vector3 position,
-            InventoryItem item, UUID groupOwner)
-        {
-            return RequestRezFromInventory(simulator, rotation, position, item, groupOwner, UUID.Random(), false);
-        }
-
-        /// <summary>
-        /// Rez an object from inventory
-        /// </summary>
-        /// <param name="simulator">Simulator to place object in</param>
-        /// <param name="rotation">Rotation of the object when rezzed</param>
-        /// <param name="position">Vector of where to place object</param>
-        /// <param name="item">InventoryItem object containing item details</param>
-        /// <param name="groupOwner">UUID of group to own the object</param>        
-        /// <param name="queryID">User defined queryID to correlate replies</param>
-        /// <param name="requestObjectDetails">if set to true the simulator
-        /// will automatically send object detail packet(s) back to the client</param>
-        public UUID RequestRezFromInventory(Simulator simulator, Quaternion rotation, Vector3 position,
-            InventoryItem item, UUID groupOwner, UUID queryID, bool requestObjectDetails)
-        {
-            RezObjectPacket add = new RezObjectPacket();
-
-            add.AgentData.AgentID = _Client.Self.AgentID;
-            add.AgentData.SessionID = _Client.Self.SessionID;
-            add.AgentData.GroupID = groupOwner;
-
-            add.RezData.FromTaskID = UUID.Zero;
-            add.RezData.BypassRaycast = 1;
-            add.RezData.RayStart = position;
-            add.RezData.RayEnd = position;
-            add.RezData.RayTargetID = UUID.Zero;
-            add.RezData.RayEndIsIntersection = false;
-            add.RezData.RezSelected = requestObjectDetails;
-            add.RezData.RemoveItem = false;
-            add.RezData.ItemFlags = (uint)item.Flags;
-            add.RezData.GroupMask = (uint)item.Permissions.GroupMask;
-            add.RezData.EveryoneMask = (uint)item.Permissions.EveryoneMask;
-            add.RezData.NextOwnerMask = (uint)item.Permissions.NextOwnerMask;
-
-            add.InventoryData.ItemID = item.UUID;
-            add.InventoryData.FolderID = item.ParentUUID;
-            add.InventoryData.CreatorID = item.CreatorID;
-            add.InventoryData.OwnerID = item.OwnerID;
-            add.InventoryData.GroupID = item.GroupID;
-            add.InventoryData.BaseMask = (uint)item.Permissions.BaseMask;
-            add.InventoryData.OwnerMask = (uint)item.Permissions.OwnerMask;
-            add.InventoryData.GroupMask = (uint)item.Permissions.GroupMask;
-            add.InventoryData.EveryoneMask = (uint)item.Permissions.EveryoneMask;
-            add.InventoryData.NextOwnerMask = (uint)item.Permissions.NextOwnerMask;
-            add.InventoryData.GroupOwned = item.GroupOwned;
-            add.InventoryData.TransactionID = queryID;
-            add.InventoryData.Type = (sbyte)item.InventoryType;
-            add.InventoryData.InvType = (sbyte)item.InventoryType;
-            add.InventoryData.Flags = (uint)item.Flags;
-            add.InventoryData.SaleType = (byte)item.SaleType;
-            add.InventoryData.SalePrice = item.SalePrice;
-            add.InventoryData.Name = Utils.StringToBytes(item.Name);
-            add.InventoryData.Description = Utils.StringToBytes(item.Description);
-            add.InventoryData.CreationDate = (int)Utils.DateTimeToUnixTime(item.CreationDate);
-
-            _Client.Network.SendPacket(add, simulator);
-
-            return queryID;
-        }
-
-        /// <summary>
-        /// DeRez an object from the simulator to the agents Objects folder in the agents Inventory
-        /// </summary>
-        /// <param name="objectLocalID">The simulator Local ID of the object</param>
-        public void RequestDeRezToInventory(uint objectLocalID)
-        {
-            RequestDeRezToInventory(objectLocalID, DeRezDestination.AgentInventoryTake, 
-                _Client.Inventory.FindFolderForType(AssetType.Object), UUID.Random());
-        }
-
-        /// <summary>
-        /// DeRez an object from the simulator and return to inventory
-        /// </summary>
-        /// <param name="objectLocalID">The simulator Local ID of the object</param>
-        /// <param name="destType">The type of destination from the <seealso cref="DeRezDestination"/> enum</param>
-        /// <param name="destFolder">The destination inventory folders <seealso cref="UUID"/> -or- 
-        /// if DeRezzing object to a tasks Inventory, the Tasks <seealso cref="UUID"/></param>
-        /// <param name="transactionID">The transaction ID for this request which
-        /// can be used to correlate this request with other packets</param>
-        public void RequestDeRezToInventory(uint objectLocalID, DeRezDestination destType, UUID destFolder, UUID transactionID)
-        {
-            DeRezObjectPacket take = new DeRezObjectPacket();
-
-            take.AgentData.AgentID = _Client.Self.AgentID;
-            take.AgentData.SessionID = _Client.Self.SessionID;
-            take.AgentBlock = new DeRezObjectPacket.AgentBlockBlock();
-            take.AgentBlock.GroupID = UUID.Zero;
-            take.AgentBlock.Destination = (byte)destType;
-            take.AgentBlock.DestinationID = destFolder;
-            take.AgentBlock.PacketCount = 1;
-            take.AgentBlock.PacketNumber = 1;
-            take.AgentBlock.TransactionID = transactionID;
-
-            take.ObjectData = new DeRezObjectPacket.ObjectDataBlock[1];
-            take.ObjectData[0] = new DeRezObjectPacket.ObjectDataBlock();
-            take.ObjectData[0].ObjectLocalID = objectLocalID;
-            
-            _Client.Network.SendPacket(take);
-        }
-
-
-        /// <summary>
-        /// Give an inventory item to another avatar
-        /// </summary>
-        /// <param name="itemID">The <seealso cref="UUID"/> of the item to give</param>
-        /// <param name="itemName">The name of the item</param>
-        /// <param name="assetType">The type of the item from the <seealso cref="AssetType"/> enum</param>
-        /// <param name="recipient">The <seealso cref="UUID"/> of the recipient</param>
-        /// <param name="doEffect">true to generate a beameffect during transfer</param>
-        public void GiveItem(UUID itemID, string itemName, AssetType assetType, UUID recipient,
-            bool doEffect)
-        {
-            byte[] bucket;
-
-
-                bucket = new byte[17];
-                bucket[0] = (byte)assetType;
-                Buffer.BlockCopy(itemID.GetBytes(), 0, bucket, 1, 16);
-
-            _Client.Self.InstantMessage(
-                    _Client.Self.Name,
-                    recipient,
-                    itemName,
-                    UUID.Random(),
-                    InstantMessageDialog.InventoryOffered,
-                    InstantMessageOnline.Online,
-                    _Client.Self.SimPosition,
-                    _Client.Network.CurrentSim.ID,
-                    bucket);
-
-            if (doEffect)
-            {
-                _Client.Self.BeamEffect(_Client.Self.AgentID, recipient, Vector3d.Zero,
-                    _Client.Settings.DEFAULT_EFFECT_COLOR, 1f, UUID.Random());
-            }
-        }
-
-        /// <summary>
-        /// Give an inventory Folder with contents to another avatar
-        /// </summary>
-        /// <param name="folderID">The <seealso cref="UUID"/> of the Folder to give</param>
-        /// <param name="folderName">The name of the folder</param>
-        /// <param name="assetType">The type of the item from the <seealso cref="AssetType"/> enum</param>
-        /// <param name="recipient">The <seealso cref="UUID"/> of the recipient</param>
-        /// <param name="doEffect">true to generate a beameffect during transfer</param>
-        public void GiveFolder(UUID folderID, string folderName, AssetType assetType, UUID recipient,
-            bool doEffect)
-        {
-            byte[] bucket;
-
-                List<InventoryItem> folderContents = new List<InventoryItem>();
-
-                _Client.Inventory.FolderContents(folderID, _Client.Self.AgentID, false, true, InventorySortOrder.ByDate, 1000 * 15).ForEach(
-                    delegate(InventoryBase ib)
-                    {
-                        folderContents.Add(_Client.Inventory.FetchItem(ib.UUID, _Client.Self.AgentID, 1000 * 10));
-                    });
-                bucket = new byte[17 * (folderContents.Count + 1)];
-
-                //Add parent folder (first item in bucket)
-                bucket[0] = (byte)assetType;
-                Buffer.BlockCopy(folderID.GetBytes(), 0, bucket, 1, 16);
-
-                //Add contents to bucket after folder
-                for (int i = 1; i <= folderContents.Count; ++i)
-                {
-                    bucket[i * 17] = (byte)folderContents[i - 1].AssetType;
-                    Buffer.BlockCopy(folderContents[i - 1].UUID.GetBytes(), 0, bucket, i * 17 + 1, 16);
-                }
-
-            _Client.Self.InstantMessage(
-                    _Client.Self.Name,
-                    recipient,
-                    folderName,
-                    UUID.Random(),
-                    InstantMessageDialog.InventoryOffered,
-                    InstantMessageOnline.Online,
-                    _Client.Self.SimPosition,
-                    _Client.Network.CurrentSim.ID,
-                    bucket);
-
-            if (doEffect)
-            {
-                _Client.Self.BeamEffect(_Client.Self.AgentID, recipient, Vector3d.Zero,
-                    _Client.Settings.DEFAULT_EFFECT_COLOR, 1f, UUID.Random());
-            }
-        }
-
-        #endregion Rez/Give
-
-        #region Task
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="objectLocalID"></param>
-        /// <param name="item"></param>
-        /// <returns></returns>
-        public UUID UpdateTaskInventory(uint objectLocalID, InventoryItem item)
-        {
-            UUID transactionID = UUID.Random();
-
-            UpdateTaskInventoryPacket update = new UpdateTaskInventoryPacket();
-            update.AgentData.AgentID = _Client.Self.AgentID;
-            update.AgentData.SessionID = _Client.Self.SessionID;
-            update.UpdateData.Key = 0;
-            update.UpdateData.LocalID = objectLocalID;
-
-            update.InventoryData.ItemID = item.UUID;
-            update.InventoryData.FolderID = item.ParentUUID;
-            update.InventoryData.CreatorID = item.CreatorID;
-            update.InventoryData.OwnerID = item.OwnerID;
-            update.InventoryData.GroupID = item.GroupID;
-            update.InventoryData.BaseMask = (uint)item.Permissions.BaseMask;
-            update.InventoryData.OwnerMask = (uint)item.Permissions.OwnerMask;
-            update.InventoryData.GroupMask = (uint)item.Permissions.GroupMask;
-            update.InventoryData.EveryoneMask = (uint)item.Permissions.EveryoneMask;
-            update.InventoryData.NextOwnerMask = (uint)item.Permissions.NextOwnerMask;
-            update.InventoryData.GroupOwned = item.GroupOwned;
-            update.InventoryData.TransactionID = transactionID;
-            update.InventoryData.Type = (sbyte)item.AssetType;
-            update.InventoryData.InvType = (sbyte)item.InventoryType;
-            update.InventoryData.Flags = (uint)item.Flags;
-            update.InventoryData.SaleType = (byte)item.SaleType;
-            update.InventoryData.SalePrice = item.SalePrice;
-            update.InventoryData.Name = Utils.StringToBytes(item.Name);
-            update.InventoryData.Description = Utils.StringToBytes(item.Description);
-            update.InventoryData.CreationDate = (int)Utils.DateTimeToUnixTime(item.CreationDate);
-            update.InventoryData.CRC = ItemCRC(item);
-
-            _Client.Network.SendPacket(update);
-
-            return transactionID;
-        }
-
-        /// <summary>
-        /// Get the inventory of a Task (Primitive)
-        /// </summary>
-        /// <param name="objectID">The tasks <seealso cref="UUID"/></param>
-        /// <param name="objectLocalID">The tasks simulator local ID</param>
-        /// <param name="timeoutMS">milliseconds to wait for reply from simulator</param>
-        /// <returns>A List containing the inventory items inside the task</returns>
-        public List<InventoryBase> GetTaskInventory(UUID objectID, uint objectLocalID, int timeoutMS)
-        {
-            string filename = null;
-            AutoResetEvent taskReplyEvent = new AutoResetEvent(false);
-
-            TaskInventoryReplyCallback callback =
-                delegate(UUID itemID, short serial, string assetFilename)
-                {
-                    if (itemID == objectID)
-                    {
-                        filename = assetFilename;
-                        taskReplyEvent.Set();
-                    }
-                };
-
-            OnTaskInventoryReply += callback;
-
-            RequestTaskInventory(objectLocalID);
-
-            if (taskReplyEvent.WaitOne(timeoutMS, false))
-            {
-                OnTaskInventoryReply -= callback;
-
-                if (!String.IsNullOrEmpty(filename))
-                {
-                    byte[] assetData = null;
-                    ulong xferID = 0;
-                    AutoResetEvent taskDownloadEvent = new AutoResetEvent(false);
-
-                    AssetManager.XferReceivedCallback xferCallback =
-                        delegate(XferDownload xfer)
-                        {
-                            if (xfer.XferID == xferID)
-                            {
-                                assetData = xfer.AssetData;
-                                taskDownloadEvent.Set();
-                            }
-                        };
-
-                    _Client.Assets.OnXferReceived += xferCallback;
-
-                    // Start the actual asset xfer
-                    xferID = _Client.Assets.RequestAssetXfer(filename, true, false, UUID.Zero, AssetType.Unknown, true);
-
-                    if (taskDownloadEvent.WaitOne(timeoutMS, false))
-                    {
-                        _Client.Assets.OnXferReceived -= xferCallback;
-
-                        string taskList = Utils.BytesToString(assetData);
-                        return ParseTaskInventory(taskList);
-                    }
-                    else
-                    {
-                        Logger.Log("Timed out waiting for task inventory download for " + filename, Helpers.LogLevel.Warning, _Client);
-                        _Client.Assets.OnXferReceived -= xferCallback;
-                        return null;
-                    }
-                }
-                else
-                {
-                    Logger.DebugLog("Task is empty for " + objectLocalID, _Client);
-                    return null;
-                }
-            }
-            else
-            {
-                Logger.Log("Timed out waiting for task inventory reply for " + objectLocalID, Helpers.LogLevel.Warning, _Client);
-                OnTaskInventoryReply -= callback;
-                return null;
-            }
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="objectLocalID"></param>
-        public void RequestTaskInventory(uint objectLocalID)
-        {
-            RequestTaskInventory(objectLocalID, _Client.Network.CurrentSim);
-        }
-
-        /// <summary>
-        /// Request the contents of a tasks (primitives) inventory
-        /// </summary>
-        /// <param name="objectLocalID">The simulator Local ID of the object</param>
-        /// <param name="simulator">A reference to the simulator object that contains the object</param>
-        public void RequestTaskInventory(uint objectLocalID, Simulator simulator)
-        {
-            RequestTaskInventoryPacket request = new RequestTaskInventoryPacket();
-            request.AgentData.AgentID = _Client.Self.AgentID;
-            request.AgentData.SessionID = _Client.Self.SessionID;
-            request.InventoryData.LocalID = objectLocalID;
-
-            _Client.Network.SendPacket(request, simulator);
-        }
-        
-        /// <summary>
-        /// Moves an Item from an objects (Prim) Inventory to the specified folder in the avatars inventory
-        /// </summary>
-        /// <param name="objectLocalID">LocalID of the object in the simulator</param>
-        /// <param name="taskItemID">UUID of the task item to move</param>
-        /// <param name="inventoryFolderID">UUID of the folder to move the item to</param>
-        /// <param name="simulator">Simulator Object</param>
-        public void MoveTaskInventory(uint objectLocalID, UUID taskItemID, UUID inventoryFolderID, Simulator simulator)
-        {
-            MoveTaskInventoryPacket request = new MoveTaskInventoryPacket();
-            request.AgentData.AgentID = _Client.Self.AgentID;
-            request.AgentData.SessionID = _Client.Self.SessionID;
-
-            request.AgentData.FolderID = inventoryFolderID;
-
-            request.InventoryData.ItemID = taskItemID;
-            request.InventoryData.LocalID = objectLocalID;
-
-            _Client.Network.SendPacket(request, simulator);
-        }
-        
-        /// <summary>
-        /// Remove an item from an objects (Prim) Inventory
-        /// </summary>
-        /// <param name="objectLocalID">LocalID of the object in the simulator</param>
-        /// <param name="taskItemID">UUID of the task item to remove</param>
-        /// <param name="simulator">Simulator Object</param>
-        public void RemoveTaskInventory(uint objectLocalID, UUID taskItemID, Simulator simulator)
-        {
-            RemoveTaskInventoryPacket remove = new RemoveTaskInventoryPacket();
-            remove.AgentData.AgentID = _Client.Self.AgentID;
-            remove.AgentData.SessionID = _Client.Self.SessionID;
-
-            remove.InventoryData.ItemID = taskItemID;
-            remove.InventoryData.LocalID = objectLocalID;
-
-            _Client.Network.SendPacket(remove, simulator);
-        }
-
-        #endregion Task
-
-        #region Helper Functions
-
-        /// <summary>
-        /// Takes an AssetType and returns the string representation
-        /// </summary>
-        /// <param name="type">The source <seealso cref="AssetType"/></param>
-        /// <returns>The string version of the AssetType</returns>
-        public static string AssetTypeToString(AssetType type)
-        {
-            return _AssetTypeNames[(int)type];
-        }
-
-        /// <summary>
-        /// Translate a string name of an AssetType into the proper Type
-        /// </summary>
-        /// <param name="type">A string containing the AssetType name</param>
-        /// <returns>The AssetType which matches the string name, or AssetType.Unknown if no match was found</returns>
-        public static AssetType StringToAssetType(string type)
-        {
-            for (int i = 0; i < _AssetTypeNames.Length; i++)
-            {
-                if (_AssetTypeNames[i] == type)
-                    return (AssetType)i;
-            }
-
-            return AssetType.Unknown;
-        }
-
-        /// <summary>
-        /// Convert an InventoryType to a string
-        /// </summary>
-        /// <param name="type">The <seealso cref="T:InventoryType"/> to convert</param>
-        /// <returns>A string representation of the source </returns>
-        public static string InventoryTypeToString(InventoryType type)
-        {
-            return _InventoryTypeNames[(int)type];
-        }
-
-        /// <summary>
-        /// Convert a string into a valid InventoryType
-        /// </summary>
-        /// <param name="type">A string representation of the InventoryType to convert</param>
-        /// <returns>A InventoryType object which matched the type</returns>
-        public static InventoryType StringToInventoryType(string type)
-        {
-            for (int i = 0; i < _InventoryTypeNames.Length; i++)
-            {
-                if (_InventoryTypeNames[i] == type)
-                    return (InventoryType)i;
-            }
-
-            return InventoryType.Unknown;
-        }
-
-        public static string SaleTypeToString(SaleType type)
-        {
-            return _SaleTypeNames[(int)type];
-        }
-
-        public static SaleType StringToSaleType(string value)
-        {
-            for (int i = 0; i < _SaleTypeNames.Length; i++)
-            {
-                if (value == _SaleTypeNames[i])
-                    return (SaleType)i;
-            }
-
-            return SaleType.Not;
-        }
-
-        private uint RegisterItemCreatedCallback(ItemCreatedCallback callback)
-        {
-            lock (_CallbacksLock)
-            {
-                if (_CallbackPos == UInt32.MaxValue)
-                    _CallbackPos = 0;
-
-                _CallbackPos++;
-
-                if (_ItemCreatedCallbacks.ContainsKey(_CallbackPos))
-                    Logger.Log("Overwriting an existing ItemCreatedCallback", Helpers.LogLevel.Warning, _Client);
-
-                _ItemCreatedCallbacks[_CallbackPos] = callback;
-
-                return _CallbackPos;
-            }
-        }
-
-        private uint RegisterItemsCopiedCallback(ItemCopiedCallback callback)
-        {
-            lock (_CallbacksLock)
-            {
-                if (_CallbackPos == UInt32.MaxValue)
-                    _CallbackPos = 0;
-
-                _CallbackPos++;
-
-                if (_ItemCopiedCallbacks.ContainsKey(_CallbackPos))
-                    Logger.Log("Overwriting an existing ItemsCopiedCallback", Helpers.LogLevel.Warning, _Client);
-
-                _ItemCopiedCallbacks[_CallbackPos] = callback;
-
-                return _CallbackPos;
-            }
-        }
-
-        /// <summary>
-        /// Create a CRC from an InventoryItem
-        /// </summary>
-        /// <param name="iitem">The source InventoryItem</param>
-        /// <returns>A uint representing the source InventoryItem as a CRC</returns>
-        public static uint ItemCRC(InventoryItem iitem)
-        {
-            uint CRC = 0;
-
-            // IDs
-            CRC += iitem.AssetUUID.CRC(); // AssetID
-            CRC += iitem.ParentUUID.CRC(); // FolderID
-            CRC += iitem.UUID.CRC(); // ItemID
-
-            // Permission stuff
-            CRC += iitem.CreatorID.CRC(); // CreatorID
-            CRC += iitem.OwnerID.CRC(); // OwnerID
-            CRC += iitem.GroupID.CRC(); // GroupID
-
-            // CRC += another 4 words which always seem to be zero -- unclear if this is a UUID or what
-            CRC += (uint)iitem.Permissions.OwnerMask; //owner_mask;      // Either owner_mask or next_owner_mask may need to be
-            CRC += (uint)iitem.Permissions.NextOwnerMask; //next_owner_mask; // switched with base_mask -- 2 values go here and in my
-            CRC += (uint)iitem.Permissions.EveryoneMask; //everyone_mask;   // study item, the three were identical.
-            CRC += (uint)iitem.Permissions.GroupMask; //group_mask;
-
-            // The rest of the CRC fields
-            CRC += (uint)iitem.Flags; // Flags
-            CRC += (uint)iitem.InventoryType; // InvType
-            CRC += (uint)iitem.AssetType; // Type 
-            CRC += (uint)Utils.DateTimeToUnixTime(iitem.CreationDate); // CreationDate
-            CRC += (uint)iitem.SalePrice;    // SalePrice
-            CRC += (uint)((uint)iitem.SaleType * 0x07073096); // SaleType
-
-            return CRC;
-        }
-
-        /// <summary>
-        /// Wrapper for creating a new <seealso cref="InventoryItem"/> object
-        /// </summary>
-        /// <param name="type">The type of item from the <seealso cref="InventoryType"/> enum</param>
-        /// <param name="id">The <seealso cref="UUID"/> of the newly created object</param>
-        /// <returns>An <seealso cref="InventoryItem"/> object with the type and id passed</returns>
-        public static InventoryItem CreateInventoryItem(InventoryType type, UUID id)
-        {
-            switch (type)
-            {
-                case InventoryType.Texture: return new InventoryTexture(id);
-                case InventoryType.Sound: return new InventorySound(id);
-                case InventoryType.CallingCard: return new InventoryCallingCard(id);
-                case InventoryType.Landmark: return new InventoryLandmark(id);
-                case InventoryType.Object: return new InventoryObject(id);
-                case InventoryType.Notecard: return new InventoryNotecard(id);
-                case InventoryType.Category: return new InventoryCategory(id);
-                case InventoryType.LSL: return new InventoryLSL(id);
-                case InventoryType.Snapshot: return new InventorySnapshot(id);
-                case InventoryType.Attachment: return new InventoryAttachment(id);
-                case InventoryType.Wearable: return new InventoryWearable(id);
-                case InventoryType.Animation: return new InventoryAnimation(id);
-                case InventoryType.Gesture: return new InventoryGesture(id);
-                default: return new InventoryItem(type, id);
-            }
-        }
-
-        private InventoryItem SafeCreateInventoryItem(InventoryType InvType, UUID ItemID)
-        {
-            InventoryItem ret = null;
-
-            if (_Store.Contains(ItemID))
-                ret = _Store[ItemID] as InventoryItem;
-
-            if (ret == null)
-                ret = CreateInventoryItem(InvType, ItemID);
-
-            return ret;
-        }
-
-        private static bool ParseLine(string line, out string key, out string value)
-        {
-            // Clean up and convert tabs to spaces
-            line = line.Trim();
-            line = line.Replace('\t', ' ');
-
-            // Shrink all whitespace down to single spaces
-            while (line.IndexOf("  ") > 0)
-                line = line.Replace("  ", " ");
-
-            if (line.Length > 2)
-            {
-                int sep = line.IndexOf(' ');
-                if (sep > 0)
-                {
-                    key = line.Substring(0, sep);
-                    value = line.Substring(sep + 1);
-
-                    return true;
-                }
-            }
-            else if (line.Length == 1)
-            {
-                key = line;
-                value = String.Empty;
-                return true;
-            }
-
-            key = null;
-            value = null;
-            return false;
-        }
-
-        /// <summary>
-        /// Parse the results of a RequestTaskInventory() response
-        /// </summary>
-        /// <param name="taskData">A string which contains the data from the task reply</param>
-        /// <returns>A List containing the items contained within the tasks inventory</returns>
-        public static List<InventoryBase> ParseTaskInventory(string taskData)
-        {
-            List<InventoryBase> items = new List<InventoryBase>();
-            int lineNum = 0;
-            string[] lines = taskData.Replace("\r\n", "\n").Split('\n');
-
-            while (lineNum < lines.Length)
-            {
-                string key, value;
-                if (ParseLine(lines[lineNum++], out key, out value))
-                {
-                    if (key == "inv_object")
-                    {
-                        #region inv_object
-
-                        // In practice this appears to only be used for folders
-                        UUID itemID = UUID.Zero;
-                        UUID parentID = UUID.Zero;
-                        string name = String.Empty;
-                        AssetType assetType = AssetType.Unknown;
-
-                        while (lineNum < lines.Length)
-                        {
-                            if (ParseLine(lines[lineNum++], out key, out value))
-                            {
-                                if (key == "{")
-                                {
-                                    continue;
-                                }
-                                else if (key == "}")
-                                {
-                                    break;
-                                }
-                                else if (key == "obj_id")
-                                {
-                                    UUID.TryParse(value, out itemID);
-                                }
-                                else if (key == "parent_id")
-                                {
-                                    UUID.TryParse(value, out parentID);
-                                }
-                                else if (key == "type")
-                                {
-                                    assetType = StringToAssetType(value);
-                                }
-                                else if (key == "name")
-                                {
-                                    name = value.Substring(0, value.IndexOf('|'));
-                                }
-                            }
-                        }
-
-                        if (assetType == AssetType.Folder)
-                        {
-                            InventoryFolder folder = new InventoryFolder(itemID);
-                            folder.Name = name;
-                            folder.ParentUUID = parentID;
-
-                            items.Add(folder);
-                        }
-                        else
-                        {
-                            InventoryItem item = new InventoryItem(itemID);
-                            item.Name = name;
-                            item.ParentUUID = parentID;
-                            item.AssetType = assetType;
-
-                            items.Add(item);
-                        }
-
-                        #endregion inv_object
-                    }
-                    else if (key == "inv_item")
-                    {
-                        #region inv_item
-
-                        // Any inventory item that links to an assetID, has permissions, etc
-                        UUID itemID = UUID.Zero;
-                        UUID assetID = UUID.Zero;
-                        UUID parentID = UUID.Zero;
-                        UUID creatorID = UUID.Zero;
-                        UUID ownerID = UUID.Zero;
-                        UUID lastOwnerID = UUID.Zero;
-                        UUID groupID = UUID.Zero;
-                        bool groupOwned = false;
-                        string name = String.Empty;
-                        string desc = String.Empty;
-                        AssetType assetType = AssetType.Unknown;
-                        InventoryType inventoryType = InventoryType.Unknown;
-                        DateTime creationDate = Utils.Epoch;
-                        uint flags = 0;
-                        Permissions perms = Permissions.NoPermissions;
-                        SaleType saleType = SaleType.Not;
-                        int salePrice = 0;
-
-                        while (lineNum < lines.Length)
-                        {
-                            if (ParseLine(lines[lineNum++], out key, out value))
-                            {
-                                if (key == "{")
-                                {
-                                    continue;
-                                }
-                                else if (key == "}")
-                                {
-                                    break;
-                                }
-                                else if (key == "item_id")
-                                {
-                                    UUID.TryParse(value, out itemID);
-                                }
-                                else if (key == "parent_id")
-                                {
-                                    UUID.TryParse(value, out parentID);
-                                }
-                                else if (key == "permissions")
-                                {
-                                    #region permissions
-
-                                    while (lineNum < lines.Length)
-                                    {
-                                        if (ParseLine(lines[lineNum++], out key, out value))
-                                        {
-                                            if (key == "{")
-                                            {
-                                                continue;
-                                            }
-                                            else if (key == "}")
-                                            {
-                                                break;
-                                            }
-                                            else if (key == "creator_mask")
-                                            {
-                                                // Deprecated
-                                                uint val;
-                                                if (Utils.TryParseHex(value, out val))
-                                                    perms.BaseMask = (PermissionMask)val;
-                                            }
-                                            else if (key == "base_mask")
-                                            {
-                                                uint val;
-                                                if (Utils.TryParseHex(value, out val))
-                                                    perms.BaseMask = (PermissionMask)val;
-                                            }
-                                            else if (key == "owner_mask")
-                                            {
-                                                uint val;
-                                                if (Utils.TryParseHex(value, out val))
-                                                    perms.OwnerMask = (PermissionMask)val;
-                                            }
-                                            else if (key == "group_mask")
-                                            {
-                                                uint val;
-                                                if (Utils.TryParseHex(value, out val))
-                                                    perms.GroupMask = (PermissionMask)val;
-                                            }
-                                            else if (key == "everyone_mask")
-                                            {
-                                                uint val;
-                                                if (Utils.TryParseHex(value, out val))
-                                                    perms.EveryoneMask = (PermissionMask)val;
-                                            }
-                                            else if (key == "next_owner_mask")
-                                            {
-                                                uint val;
-                                                if (Utils.TryParseHex(value, out val))
-                                                    perms.NextOwnerMask = (PermissionMask)val;
-                                            }
-                                            else if (key == "creator_id")
-                                            {
-                                                
-                                                UUID.TryParse(value, out creatorID);
-                                            }
-                                            else if (key == "owner_id")
-                                            {
-                                                UUID.TryParse(value, out ownerID);
-                                            }
-                                            else if (key == "last_owner_id")
-                                            {
-                                                UUID.TryParse(value, out lastOwnerID);
-                                            }
-                                            else if (key == "group_id")
-                                            {
-                                                UUID.TryParse(value, out groupID);
-                                            }
-                                            else if (key == "group_owned")
-                                            {
-                                                uint val;
-                                                if (UInt32.TryParse(value, out val))
-                                                    groupOwned = (val != 0);
-                                            }
-                                        }
-                                    }
-
-                                    #endregion permissions
-                                }
-                                else if (key == "sale_info")
-                                {
-                                    #region sale_info
-
-                                    while (lineNum < lines.Length)
-                                    {
-                                        if (ParseLine(lines[lineNum++], out key, out value))
-                                        {
-                                            if (key == "{")
-                                            {
-                                                continue;
-                                            }
-                                            else if (key == "}")
-                                            {
-                                                break;
-                                            }
-                                            else if (key == "sale_type")
-                                            {
-                                                saleType = StringToSaleType(value);
-                                            }
-                                            else if (key == "sale_price")
-                                            {
-                                                Int32.TryParse(value, out salePrice);
-                                            }
-                                        }
-                                    }
-
-                                    #endregion sale_info
-                                }
-                                else if (key == "shadow_id")
-                                {
-                                    //FIXME:
-                                }
-                                else if (key == "asset_id")
-                                {
-                                    UUID.TryParse(value, out assetID);
-                                }
-                                else if (key == "type")
-                                {
-                                    assetType = StringToAssetType(value);
-                                }
-                                else if (key == "inv_type")
-                                {
-                                    inventoryType = StringToInventoryType(value);
-                                }
-                                else if (key == "flags")
-                                {
-                                    UInt32.TryParse(value, out flags);
-                                }
-                                else if (key == "name")
-                                {
-                                    name = value.Substring(0, value.IndexOf('|'));
-                                }
-                                else if (key == "desc")
-                                {
-                                    desc = value.Substring(0, value.IndexOf('|'));
-                                }
-                                else if (key == "creation_date")
-                                {
-                                    uint timestamp;
-                                    if (UInt32.TryParse(value, out timestamp))
-                                        creationDate = Utils.UnixTimeToDateTime(timestamp);
-                                    else
-                                        Logger.Log("Failed to parse creation_date " + value, Helpers.LogLevel.Warning);
-                                }
-                            }
-                        }
-
-                        InventoryItem item = CreateInventoryItem(inventoryType, itemID);
-                        item.AssetUUID = assetID;
-                        item.AssetType = assetType;
-                        item.CreationDate = creationDate;
-                        item.CreatorID = creatorID;
-                        item.Description = desc;
-                        item.Flags = flags;
-                        item.GroupID = groupID;
-                        item.GroupOwned = groupOwned;
-                        item.Name = name;
-                        item.OwnerID = ownerID;
-                        item.ParentUUID = parentID;
-                        item.Permissions = perms;
-                        item.SalePrice = salePrice;
-                        item.SaleType = saleType;
-
-                        items.Add(item);
-
-                        #endregion inv_item
-                    }
-                    else
-                    {
-                        Logger.Log("Unrecognized token " + key + " in: " + Environment.NewLine + taskData,
-                            Helpers.LogLevel.Error);
-                    }
-                }
-            }
-
-            return items;
-        }
-        
-        #endregion Helper Functions
-
-        #region Callbacks
-
-        private void CreateItemFromAssetResponse(CapsClient client, OSD result, Exception error)
-        {
-            object[] args = (object[])client.UserData;
-            CapsClient.ProgressCallback progCallback = (CapsClient.ProgressCallback)args[0];
-            ItemCreatedFromAssetCallback callback = (ItemCreatedFromAssetCallback)args[1];
-            byte[] itemData = (byte[])args[2];
-
-            if (result == null)
-            {
-                try { callback(false, error.Message, UUID.Zero, UUID.Zero); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-                return;
-            }
-
-            OSDMap contents = (OSDMap)result;
-
-            string status = contents["state"].AsString().ToLower();
-
-            if (status == "upload")
-            {
-                string uploadURL = contents["uploader"].AsString();
-
-                Logger.DebugLog("CreateItemFromAsset: uploading to " + uploadURL);
-
-                // This makes the assumption that all uploads go to CurrentSim, to avoid
-                // the problem of HttpRequestState not knowing anything about simulators
-                CapsClient upload = new CapsClient(new Uri(uploadURL));
-                upload.OnProgress += progCallback;
-                upload.OnComplete += new CapsClient.CompleteCallback(CreateItemFromAssetResponse);
-                upload.UserData = new object[] { null, callback, itemData };
-                upload.StartRequest(itemData, "application/octet-stream");
-            }
-            else if (status == "complete")
-            {
-                Logger.DebugLog("CreateItemFromAsset: completed"); 
-
-                if (contents.ContainsKey("new_inventory_item") && contents.ContainsKey("new_asset"))
-                {
-                    try { callback(true, String.Empty, contents["new_inventory_item"].AsUUID(), contents["new_asset"].AsUUID()); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-                }
-                else
-                {
-                    try { callback(false, "Failed to parse asset and item UUIDs", UUID.Zero, UUID.Zero); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-                }
-            }
-            else
-            {
-                // Failure
-                try { callback(false, status, UUID.Zero, UUID.Zero); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-            }
-        }
-
-        private void SaveAssetIntoInventoryHandler(Packet packet, Simulator simulator)
-        {
-            //SaveAssetIntoInventoryPacket save = (SaveAssetIntoInventoryPacket)packet;
-
-            // FIXME: Find this item in the inventory structure and mark the parent as needing an update
-            //save.InventoryData.ItemID;
-            Logger.Log("SaveAssetIntoInventory packet received, someone write this function!", Helpers.LogLevel.Error, _Client);
-        }
-
-        private void InventoryDescendentsHandler(Packet packet, Simulator simulator)
-        {
-            InventoryDescendentsPacket reply = (InventoryDescendentsPacket)packet;
-
-            if (reply.AgentData.Descendents > 0)
-            {
-                // InventoryDescendantsReply sends a null folder if the parent doesnt contain any folders
-                if (reply.FolderData[0].FolderID != UUID.Zero)
-                {
-                    // Iterate folders in this packet
-                    for (int i = 0; i < reply.FolderData.Length; i++)
-                    {
-                        InventoryFolder folder = new InventoryFolder(reply.FolderData[i].FolderID);
-                        folder.ParentUUID = reply.FolderData[i].ParentID;
-                        folder.Name = Utils.BytesToString(reply.FolderData[i].Name);
-                        folder.PreferredType = (AssetType)reply.FolderData[i].Type;
-                        folder.OwnerID = reply.AgentData.OwnerID;
-
-                        _Store[folder.UUID] = folder;
-                    }
-                }
-
-                // InventoryDescendantsReply sends a null item if the parent doesnt contain any items.
-                if (reply.ItemData[0].ItemID != UUID.Zero)
-                {
-                    // Iterate items in this packet
-                    for (int i = 0; i < reply.ItemData.Length; i++)
-                    {
-                        if (reply.ItemData[i].ItemID != UUID.Zero)
-                        {
-                            InventoryItem item;
-                            /* 
-                             * Objects that have been attached in-world prior to being stored on the 
-                             * asset server are stored with the InventoryType of 0 (Texture) 
-                             * instead of 17 (Attachment) 
-                             * 
-                             * This corrects that behavior by forcing Object Asset types that have an 
-                             * invalid InventoryType with the proper InventoryType of Attachment.
-                             */
-                            if ((AssetType)reply.ItemData[i].Type == AssetType.Object 
-                                && (InventoryType)reply.ItemData[i].InvType == InventoryType.Texture)
-                            {
-                                item = CreateInventoryItem(InventoryType.Attachment, reply.ItemData[i].ItemID);
-                                item.InventoryType = InventoryType.Attachment;
-                            }
-                            else
-                            {
-                                item = CreateInventoryItem((InventoryType)reply.ItemData[i].InvType, reply.ItemData[i].ItemID);
-                                item.InventoryType = (InventoryType)reply.ItemData[i].InvType;
-                            }
-                            
-                            item.ParentUUID = reply.ItemData[i].FolderID;
-                            item.CreatorID = reply.ItemData[i].CreatorID;
-                            item.AssetType = (AssetType)reply.ItemData[i].Type;
-                            item.AssetUUID = reply.ItemData[i].AssetID;
-                            item.CreationDate = Utils.UnixTimeToDateTime((uint)reply.ItemData[i].CreationDate);
-                            item.Description = Utils.BytesToString(reply.ItemData[i].Description);
-                            item.Flags = reply.ItemData[i].Flags;
-                            item.Name = Utils.BytesToString(reply.ItemData[i].Name);
-                            item.GroupID = reply.ItemData[i].GroupID;
-                            item.GroupOwned = reply.ItemData[i].GroupOwned;
-                            item.Permissions = new Permissions(
-                                reply.ItemData[i].BaseMask,
-                                reply.ItemData[i].EveryoneMask,
-                                reply.ItemData[i].GroupMask,
-                                reply.ItemData[i].NextOwnerMask,
-                                reply.ItemData[i].OwnerMask);
-                            item.SalePrice = reply.ItemData[i].SalePrice;
-                            item.SaleType = (SaleType)reply.ItemData[i].SaleType;
-                            item.OwnerID = reply.AgentData.OwnerID;
-
-                            _Store[item.UUID] = item;
-                        }
-                    }
-                }
-            }
-
-            InventoryFolder parentFolder = null;
-
-            if (_Store.Contains(reply.AgentData.FolderID) &&
-                _Store[reply.AgentData.FolderID] is InventoryFolder)
-            {
-                parentFolder = _Store[reply.AgentData.FolderID] as InventoryFolder;
-            }
-            else
-            {
-                Logger.Log("Don't have a reference to FolderID " + reply.AgentData.FolderID.ToString() +
-                    " or it is not a folder", Helpers.LogLevel.Error, _Client);
-                return;
-            }
-
-            if (reply.AgentData.Version < parentFolder.Version)
-            {
-                Logger.Log("Got an outdated InventoryDescendents packet for folder " + parentFolder.Name +
-                    ", this version = " + reply.AgentData.Version + ", latest version = " + parentFolder.Version,
-                    Helpers.LogLevel.Warning, _Client);
-                return;
-            }
-
-            parentFolder.Version = reply.AgentData.Version;
-            // FIXME: reply.AgentData.Descendants is not parentFolder.DescendentCount if we didn't 
-            // request items and folders
-            parentFolder.DescendentCount = reply.AgentData.Descendents;
-
-            #region FindObjectsByPath Handling
-
-            if (_Searches.Count > 0)
-            {
-                lock (_Searches)
-                {
-                StartSearch:
-
-                    // Iterate over all of the outstanding searches
-                    for (int i = 0; i < _Searches.Count; i++)
-                    {
-                        InventorySearch search = _Searches[i];
-                        List<InventoryBase> folderContents = _Store.GetContents(search.Folder);
-
-                        // Iterate over all of the inventory objects in the base search folder
-                        for (int j = 0; j < folderContents.Count; j++)
-                        {
-                            // Check if this inventory object matches the current path node
-                            if (folderContents[j].Name == search.Path[search.Level])
-                            {
-                                if (search.Level == search.Path.Length - 1)
-                                {
-                                    Logger.DebugLog("Finished path search of " + String.Join("/", search.Path), _Client);
-
-                                    // This is the last node in the path, fire the callback and clean up
-                                    if (OnFindObjectByPath != null)
-                                    {
-                                        try { OnFindObjectByPath(String.Join("/", search.Path), folderContents[j].UUID); }
-                                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-                                    }
-
-                                    // Remove this entry and restart the loop since we are changing the collection size
-                                    _Searches.RemoveAt(i);
-                                    goto StartSearch;
-                                }
-                                else
-                                {
-                                    // We found a match but it is not the end of the path, request the next level
-                                    Logger.DebugLog(String.Format("Matched level {0}/{1} in a path search of {2}",
-                                        search.Level, search.Path.Length - 1, String.Join("/", search.Path)), _Client);
-
-                                    search.Folder = folderContents[j].UUID;
-                                    search.Level++;
-                                    _Searches[i] = search;
-
-                                    RequestFolderContents(search.Folder, search.Owner, true, true, 
-                                        InventorySortOrder.ByName);
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-
-            #endregion FindObjectsByPath Handling
-
-            // Callback for inventory folder contents being updated
-            if (OnFolderUpdated != null)
-            {
-                try { OnFolderUpdated(parentFolder.UUID); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-            }
-        }
-
-        /// <summary>
-        /// UpdateCreateInventoryItem packets are received when a new inventory item 
-        /// is created. This may occur when an object that's rezzed in world is
-        /// taken into inventory, when an item is created using the CreateInventoryItem
-        /// packet, or when an object is purchased
-        /// </summary>
-        private void UpdateCreateInventoryItemHandler(Packet packet, Simulator simulator)
-        {
-            UpdateCreateInventoryItemPacket reply = packet as UpdateCreateInventoryItemPacket;
-
-            foreach (UpdateCreateInventoryItemPacket.InventoryDataBlock dataBlock in reply.InventoryData)
-            {
-                if (dataBlock.InvType == (sbyte)InventoryType.Folder)
-                {
-                    Logger.Log("Received InventoryFolder in an UpdateCreateInventoryItem packet, this should not happen!",
-                        Helpers.LogLevel.Error, _Client);
-                    continue;
-                }
-
-                InventoryItem item = CreateInventoryItem((InventoryType)dataBlock.InvType,dataBlock.ItemID);
-                item.AssetType = (AssetType)dataBlock.Type;
-                item.AssetUUID = dataBlock.AssetID;
-                item.CreationDate = Utils.UnixTimeToDateTime(dataBlock.CreationDate);
-                item.CreatorID = dataBlock.CreatorID;
-                item.Description = Utils.BytesToString(dataBlock.Description);
-                item.Flags = dataBlock.Flags;
-                item.GroupID = dataBlock.GroupID;
-                item.GroupOwned = dataBlock.GroupOwned;
-                item.Name = Utils.BytesToString(dataBlock.Name);
-                item.OwnerID = dataBlock.OwnerID;
-                item.ParentUUID = dataBlock.FolderID;
-                item.Permissions = new Permissions(
-                        dataBlock.BaseMask,
-                        dataBlock.EveryoneMask,
-                        dataBlock.GroupMask,
-                        dataBlock.NextOwnerMask,
-                        dataBlock.OwnerMask);
-                item.SalePrice = dataBlock.SalePrice;
-                item.SaleType = (SaleType)dataBlock.SaleType;
-
-                /* 
-                 * When attaching new objects, an UpdateCreateInventoryItem packet will be
-                 * returned by the server that has a FolderID/ParentUUID of zero. It is up
-                 * to the client to make sure that the item gets a good folder, otherwise
-                 * it will end up inaccesible in inventory.
-                 */
-                if (item.ParentUUID == UUID.Zero)
-                {
-                    // assign default folder for type
-                    item.ParentUUID = FindFolderForType(item.AssetType);
-
-                    // send update to the sim
-                    RequestUpdateItem(item);
-                }
-
-                // Update the local copy
-                _Store[item.UUID] = item;
-
-                // Look for an "item created" callback
-                ItemCreatedCallback createdCallback;
-                if (_ItemCreatedCallbacks.TryGetValue(dataBlock.CallbackID, out createdCallback))
-                {
-                    _ItemCreatedCallbacks.Remove(dataBlock.CallbackID);
-
-                    try { createdCallback(true, item); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-                }
-
-                // TODO: Is this callback even triggered when items are copied?
-                // Look for an "item copied" callback
-                ItemCopiedCallback copyCallback;
-                if (_ItemCopiedCallbacks.TryGetValue(dataBlock.CallbackID, out copyCallback))
-                {
-                    _ItemCopiedCallbacks.Remove(dataBlock.CallbackID);
-
-                    try { copyCallback(item); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-                }
-                
-                //This is triggered when an item is received from a task
-                if (OnTaskItemReceived != null)
-                {
-                    try { OnTaskItemReceived(item.UUID, dataBlock.FolderID, item.CreatorID, item.AssetUUID, 
-                        item.InventoryType); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-                }
-            }
-        }
-
-        private void MoveInventoryItemHandler(Packet packet, Simulator simulator)
-        {
-            MoveInventoryItemPacket move = (MoveInventoryItemPacket)packet;
-
-            for (int i = 0; i < move.InventoryData.Length; i++)
-            {
-                // FIXME: Do something here
-                string newName = Utils.BytesToString(move.InventoryData[i].NewName);
-
-                Logger.Log(String.Format(
-                    "MoveInventoryItemHandler: Item {0} is moving to Folder {1} with new name \"{2}\". Someone write this function!",
-                    move.InventoryData[i].ItemID.ToString(), move.InventoryData[i].FolderID.ToString(),
-                    newName), Helpers.LogLevel.Warning, _Client);
-            }
-        }
-
-        private void BulkUpdateInventoryHandler(Packet packet, Simulator simulator)
-        {
-            BulkUpdateInventoryPacket update = packet as BulkUpdateInventoryPacket;
-
-            if (update.FolderData.Length > 0 && update.FolderData[0].FolderID != UUID.Zero)
-            {
-                foreach (BulkUpdateInventoryPacket.FolderDataBlock dataBlock in update.FolderData)
-                {
-                    if (!_Store.Contains(dataBlock.FolderID))
-                        Logger.Log("Received BulkUpdate for unknown folder: " + dataBlock.FolderID, Helpers.LogLevel.Warning, _Client);
-
-                    InventoryFolder folder = new InventoryFolder(dataBlock.FolderID);
-                    folder.Name = Utils.BytesToString(dataBlock.Name);
-                    folder.OwnerID = update.AgentData.AgentID;
-                    folder.ParentUUID = dataBlock.ParentID;
-                    _Store[folder.UUID] = folder;
-                }
-            }
-
-            if (update.ItemData.Length > 0 && update.ItemData[0].ItemID != UUID.Zero)
-            {
-                for (int i = 0; i < update.ItemData.Length; i++)
-                {
-                    BulkUpdateInventoryPacket.ItemDataBlock dataBlock = update.ItemData[i];
-
-                    // If we are given a folder of items, the item information might arrive before the folder
-                    // (parent) is in the store
-                    if (!_Store.Contains(dataBlock.ItemID))
-                        Logger.Log("Received BulkUpdate for unknown item: " + dataBlock.ItemID, Helpers.LogLevel.Warning, _Client);
-
-                    InventoryItem item = SafeCreateInventoryItem((InventoryType)dataBlock.InvType, dataBlock.ItemID);
-
-                    item.AssetType = (AssetType)dataBlock.Type;
-                    if (dataBlock.AssetID != UUID.Zero) item.AssetUUID = dataBlock.AssetID;
-                    item.CreationDate = Utils.UnixTimeToDateTime(dataBlock.CreationDate);
-                    item.CreatorID = dataBlock.CreatorID;
-                    item.Description = Utils.BytesToString(dataBlock.Description);
-                    item.Flags = dataBlock.Flags;
-                    item.GroupID = dataBlock.GroupID;
-                    item.GroupOwned = dataBlock.GroupOwned;
-                    item.Name = Utils.BytesToString(dataBlock.Name);
-                    item.OwnerID = dataBlock.OwnerID;
-                    item.ParentUUID = dataBlock.FolderID;
-                    item.Permissions = new Permissions(
-                        dataBlock.BaseMask,
-                        dataBlock.EveryoneMask,
-                        dataBlock.GroupMask,
-                        dataBlock.NextOwnerMask,
-                        dataBlock.OwnerMask);
-                    item.SalePrice = dataBlock.SalePrice;
-                    item.SaleType = (SaleType)dataBlock.SaleType;
-
-                    _Store[item.UUID] = item;
-
-                    // Look for an "item created" callback
-                    ItemCreatedCallback callback;
-                    if (_ItemCreatedCallbacks.TryGetValue(dataBlock.CallbackID, out callback))
-                    {
-                        _ItemCreatedCallbacks.Remove(dataBlock.CallbackID);
-
-                        try { callback(true, item); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-                    }
-
-                    // Look for an "item copied" callback
-                    ItemCopiedCallback copyCallback;
-                    if (_ItemCopiedCallbacks.TryGetValue(dataBlock.CallbackID, out copyCallback))
-                    {
-                        _ItemCopiedCallbacks.Remove(dataBlock.CallbackID);
-
-                        try { copyCallback(item); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-                    }
-                }
-            }
-        }
-
-        private void FetchInventoryReplyHandler(Packet packet, Simulator simulator)
-        {
-            FetchInventoryReplyPacket reply = packet as FetchInventoryReplyPacket;
-
-            foreach (FetchInventoryReplyPacket.InventoryDataBlock dataBlock in reply.InventoryData) 
-            {
-                if (dataBlock.InvType == (sbyte)InventoryType.Folder)
-                {
-                    Logger.Log("Received FetchInventoryReply for an inventory folder, this should not happen!",
-                        Helpers.LogLevel.Error, _Client);
-                    continue;
-                }
-
-                InventoryItem item = CreateInventoryItem((InventoryType)dataBlock.InvType,dataBlock.ItemID);
-                item.AssetType = (AssetType)dataBlock.Type;
-                item.AssetUUID = dataBlock.AssetID;
-                item.CreationDate = Utils.UnixTimeToDateTime(dataBlock.CreationDate);
-                item.CreatorID = dataBlock.CreatorID;
-                item.Description = Utils.BytesToString(dataBlock.Description);
-                item.Flags = dataBlock.Flags;
-                item.GroupID = dataBlock.GroupID;
-                item.GroupOwned = dataBlock.GroupOwned;
-                item.Name = Utils.BytesToString(dataBlock.Name);
-                item.OwnerID = dataBlock.OwnerID;
-                item.ParentUUID = dataBlock.FolderID;
-                item.Permissions = new Permissions(
-                    dataBlock.BaseMask, 
-                    dataBlock.EveryoneMask, 
-                    dataBlock.GroupMask, 
-                    dataBlock.NextOwnerMask, 
-                    dataBlock.OwnerMask);
-                item.SalePrice = dataBlock.SalePrice;
-                item.SaleType = (SaleType)dataBlock.SaleType;
-
-                _Store[item.UUID] = item;
-
-                // Fire the callback for an item being fetched
-                if (OnItemReceived != null)
-                {
-                    try { OnItemReceived(item); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-                }
-            }
-        }
-
-        private void ReplyTaskInventoryHandler(Packet packet, Simulator simulator)
-        {
-            if (OnTaskInventoryReply != null)
-            {
-                ReplyTaskInventoryPacket reply = (ReplyTaskInventoryPacket)packet;
-
-                try
-                {
-                    OnTaskInventoryReply(reply.InventoryData.TaskID, reply.InventoryData.Serial,
-                        Utils.BytesToString(reply.InventoryData.Filename));
-                }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-            }
-        }
-
-        private void Self_OnInstantMessage(InstantMessage im, Simulator simulator)
-        {
-            // TODO: MainAvatar.InstantMessageDialog.GroupNotice can also be an inventory offer, should we
-            // handle it here?
-
-            if (OnObjectOffered != null && 
-                (im.Dialog == InstantMessageDialog.InventoryOffered 
-                || im.Dialog == InstantMessageDialog.TaskInventoryOffered))
-            {
-                AssetType type = AssetType.Unknown;
-                UUID objectID = UUID.Zero;
-                bool fromTask = false;
-
-                if (im.Dialog == InstantMessageDialog.InventoryOffered)
-                {
-                    if (im.BinaryBucket.Length == 17)
-                    {
-                        type = (AssetType)im.BinaryBucket[0];
-                        objectID = new UUID(im.BinaryBucket, 1);
-                        fromTask = false;
-                    }
-                    else
-                    {
-                        Logger.Log("Malformed inventory offer from agent", Helpers.LogLevel.Warning, _Client);
-                        return;
-                    }
-                }
-                else if (im.Dialog == InstantMessageDialog.TaskInventoryOffered)
-                {
-                    if (im.BinaryBucket.Length == 1)
-                    {
-                        type = (AssetType)im.BinaryBucket[0];
-                        fromTask = true;
-                    }
-                    else
-                    {
-                        Logger.Log("Malformed inventory offer from object", Helpers.LogLevel.Warning, _Client);
-                        return;
-                    }
-                }
-
-                // Find the folder where this is going to go
-                UUID destinationFolderID = FindFolderForType(type);
-
-                // Fire the callback
-                try
-                {
-                    ImprovedInstantMessagePacket imp = new ImprovedInstantMessagePacket();
-                    imp.AgentData.AgentID = _Client.Self.AgentID;
-                    imp.AgentData.SessionID = _Client.Self.SessionID;
-                    imp.MessageBlock.FromGroup = false;
-                    imp.MessageBlock.ToAgentID = im.FromAgentID;
-                    imp.MessageBlock.Offline = 0;
-                    imp.MessageBlock.ID = im.IMSessionID;
-                    imp.MessageBlock.Timestamp = 0;
-                    imp.MessageBlock.FromAgentName = Utils.StringToBytes(_Client.Self.Name);
-                    imp.MessageBlock.Message = new byte[0];
-                    imp.MessageBlock.ParentEstateID = 0;
-                    imp.MessageBlock.RegionID = UUID.Zero;
-                    imp.MessageBlock.Position = _Client.Self.SimPosition;
-
-                    if (OnObjectOffered(im, type, objectID, fromTask))
-                    {
-                        // Accept the inventory offer
-                        switch (im.Dialog)
-                        {
-                            case InstantMessageDialog.InventoryOffered:
-                                imp.MessageBlock.Dialog = (byte)InstantMessageDialog.InventoryAccepted;
-                                break;
-                            case InstantMessageDialog.TaskInventoryOffered:
-                                imp.MessageBlock.Dialog = (byte)InstantMessageDialog.TaskInventoryAccepted;
-                                break;
-                            case InstantMessageDialog.GroupNotice:
-                                imp.MessageBlock.Dialog = (byte)InstantMessageDialog.GroupNoticeInventoryAccepted;
-                                break;
-                        }
-
-                        imp.MessageBlock.BinaryBucket = destinationFolderID.GetBytes();
-                    }
-                    else
-                    {
-                        // Decline the inventory offer
-                        switch (im.Dialog)
-                        {
-                            case InstantMessageDialog.InventoryOffered:
-                                imp.MessageBlock.Dialog = (byte)InstantMessageDialog.InventoryDeclined;
-                                break;
-                            case InstantMessageDialog.TaskInventoryOffered:
-                                imp.MessageBlock.Dialog = (byte)InstantMessageDialog.TaskInventoryDeclined;
-                                break;
-                            case InstantMessageDialog.GroupNotice:
-                                imp.MessageBlock.Dialog = (byte)InstantMessageDialog.GroupNoticeInventoryDeclined;
-                                break;
-                        }
-
-                        imp.MessageBlock.BinaryBucket = new byte[0];
-                    }
-
-                    _Client.Network.SendPacket(imp, simulator);
-                }
-                catch (Exception e)
-                {
-                    Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e);
-                }
-            }
-        }
-        
-        private void Network_OnLoginResponse(bool loginSuccess, bool redirect, string message, string reason, LoginResponseData replyData)
-        {
-            if (loginSuccess)
-            {
-                // Initialize the store here so we know who owns it:
-                _Store = new Inventory(_Client, this, _Client.Self.AgentID);
-                Logger.DebugLog("Setting InventoryRoot to " + replyData.InventoryRoot.ToString(), _Client);
-                InventoryFolder rootFolder = new InventoryFolder(replyData.InventoryRoot);
-                rootFolder.Name = String.Empty;
-                rootFolder.ParentUUID = UUID.Zero;
-                _Store.RootFolder = rootFolder;
-
-                for (int i = 0; i < replyData.InventorySkeleton.Length; i++)
-                    _Store.UpdateNodeFor(replyData.InventorySkeleton[i]);
-
-                InventoryFolder libraryRootFolder = new InventoryFolder(replyData.LibraryRoot);
-                libraryRootFolder.Name = String.Empty;
-                libraryRootFolder.ParentUUID = UUID.Zero;
-                _Store.LibraryFolder = libraryRootFolder;
-
-                for(int i = 0; i < replyData.LibrarySkeleton.Length; i++)
-                    _Store.UpdateNodeFor(replyData.LibrarySkeleton[i]);
-            }
-        }
-
-        private void UploadNotecardAssetResponse(CapsClient client, OSD result, Exception error)
-        {
-            OSDMap contents = (OSDMap)result;
-            KeyValuePair<NotecardUploadedAssetCallback, byte[]> kvp = (KeyValuePair<NotecardUploadedAssetCallback, byte[]>)(((object[])client.UserData)[0]);
-            NotecardUploadedAssetCallback callback = kvp.Key;
-            byte[] itemData = (byte[])kvp.Value;
-
-            string status = contents["state"].AsString();
-
-            if (status == "upload")
-            {
-                string uploadURL = contents["uploader"].AsString();
-
-                // This makes the assumption that all uploads go to CurrentSim, to avoid
-                // the problem of HttpRequestState not knowing anything about simulators
-                CapsClient upload = new CapsClient(new Uri(uploadURL));
-                upload.OnComplete += new CapsClient.CompleteCallback(UploadNotecardAssetResponse);
-                upload.UserData = new object[2] { kvp, (UUID)(((object[])client.UserData)[1]) };
-                upload.StartRequest(itemData, "application/octet-stream");
-            }
-            else if (status == "complete")
-            {
-                if (contents.ContainsKey("new_asset"))
-                {
-                    try { callback(true, String.Empty, (UUID)(((object[])client.UserData)[1]), contents["new_asset"].AsUUID()); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-                }
-                else
-                {
-                    try { callback(false, "Failed to parse asset and item UUIDs", UUID.Zero, UUID.Zero); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-                }
-            }
-            else
-            {
-                // Failure
-                try { callback(false, status, UUID.Zero, UUID.Zero); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
-            }
-        }
-
-        #endregion Callbacks
-    }
-}
+/*
+ * Copyright (c) 2006-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Text.RegularExpressions;
+using System.Threading;
+using System.Text;
+using System.Runtime.Serialization;
+using System.IO;
+using System.Runtime.Serialization.Formatters.Binary;
+using OpenMetaverse.Http;
+using OpenMetaverse.StructuredData;
+using OpenMetaverse.Packets;
+
+namespace OpenMetaverse
+{
+    #region Enums
+    /// <summary>
+    /// Inventory Item Types, eg Script, Notecard, Folder, etc
+    /// </summary>
+    public enum InventoryType : sbyte
+    {
+        /// <summary>Unknown</summary>
+        Unknown = -1,
+        /// <summary>Texture</summary>
+        Texture = 0,
+        /// <summary>Sound</summary>
+        Sound = 1,
+        /// <summary>Calling Card</summary>
+        CallingCard = 2,
+        /// <summary>Landmark</summary>
+        Landmark = 3,
+        /*
+        /// <summary>Script</summary>
+        //[Obsolete("See LSL")] Script = 4,
+        /// <summary>Clothing</summary>
+        //[Obsolete("See Wearable")] Clothing = 5,
+        /// <summary>Object, both single and coalesced</summary>
+         */
+        Object = 6,
+        /// <summary>Notecard</summary>
+        Notecard = 7,
+        /// <summary></summary>
+        Category = 8,
+        /// <summary>Folder</summary>
+        Folder = 8,
+        /// <summary></summary>
+        RootCategory = 9,
+        /// <summary>an LSL Script</summary>
+        LSL = 10,
+        /*
+        /// <summary></summary>
+        //[Obsolete("See LSL")] LSLBytecode = 11,
+        /// <summary></summary>
+        //[Obsolete("See Texture")] TextureTGA = 12,
+        /// <summary></summary>
+        //[Obsolete] Bodypart = 13,
+        /// <summary></summary>
+        //[Obsolete] Trash = 14,
+         */
+        /// <summary></summary>
+        Snapshot = 15,
+        /*
+        /// <summary></summary>
+        //[Obsolete] LostAndFound = 16,
+         */
+        /// <summary></summary>
+        Attachment = 17,
+        /// <summary></summary>
+        Wearable = 18,
+        /// <summary></summary>
+        Animation = 19,
+        /// <summary></summary>
+        Gesture = 20
+    }
+
+    /// <summary>
+    /// Item Sale Status
+    /// </summary>
+    public enum SaleType : byte
+    {
+        /// <summary>Not for sale</summary>
+        Not = 0,
+        /// <summary>The original is for sale</summary>
+        Original = 1,
+        /// <summary>Copies are for sale</summary>
+        Copy = 2,
+        /// <summary>The contents of the object are for sale</summary>
+        Contents = 3
+    }
+
+    [Flags]
+    public enum InventorySortOrder : int
+    {
+        /// <summary>Sort by name</summary>
+        ByName = 0,
+        /// <summary>Sort by date</summary>
+        ByDate = 1,
+        /// <summary>Sort folders by name, regardless of whether items are
+        /// sorted by name or date</summary>
+        FoldersByName = 2,
+        /// <summary>Place system folders at the top</summary>
+        SystemFoldersToTop = 4
+    }
+
+    /// <summary>
+    /// Possible destinations for DeRezObject request
+    /// </summary>
+    public enum DeRezDestination : byte
+    {
+        /// <summary></summary>
+        AgentInventorySave = 0,
+        /// <summary>Copy from in-world to agent inventory</summary>
+        AgentInventoryCopy = 1,
+        /// <summary>Derez to TaskInventory</summary>
+        TaskInventory = 2,
+        /// <summary></summary>
+        Attachment = 3,
+        /// <summary>Take Object</summary>
+        AgentInventoryTake = 4,
+        /// <summary></summary>
+        ForceToGodInventory = 5,
+        /// <summary>Delete Object</summary>
+        TrashFolder = 6,
+        /// <summary>Put an avatar attachment into agent inventory</summary>
+        AttachmentToInventory = 7,
+        /// <summary></summary>
+        AttachmentExists = 8,
+        /// <summary>Return an object back to the owner's inventory</summary>
+        ReturnToOwner = 9,
+        /// <summary>Return a deeded object back to the last owner's inventory</summary>
+        ReturnToLastOwner = 10
+    }
+
+    #endregion Enums
+
+    #region Inventory Object Classes
+    /// <summary>
+    /// Base Class for Inventory Items
+    /// </summary>
+    [Serializable()]
+    public abstract class InventoryBase : ISerializable
+    {
+        /// <summary><seealso cref="OpenMetaverse.UUID"/> of item/folder</summary>
+        public readonly UUID UUID;
+        /// <summary><seealso cref="OpenMetaverse.UUID"/> of parent folder</summary>
+        public UUID ParentUUID;
+        /// <summary>Name of item/folder</summary>
+        public string Name;
+        /// <summary>Item/Folder Owners <seealso cref="OpenMetaverse.UUID"/></summary>
+        public UUID OwnerID;
+
+        /// <summary>
+        /// Constructor, takes an itemID as a parameter
+        /// </summary>
+        /// <param name="itemID">The <seealso cref="OpenMetaverse.UUID"/> of the item</param>
+        public InventoryBase(UUID itemID)
+        {
+            if (itemID == UUID.Zero)
+                Logger.Log("Initializing an InventoryBase with UUID.Zero", Helpers.LogLevel.Warning);
+            UUID = itemID;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public void GetObjectData(SerializationInfo info, StreamingContext ctxt)
+        {
+            info.AddValue("UUID", UUID);
+            info.AddValue("ParentUUID",ParentUUID );
+            info.AddValue("Name", Name);
+            info.AddValue("OwnerID", OwnerID);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public InventoryBase(SerializationInfo info, StreamingContext ctxt)
+        {
+            UUID = (UUID)info.GetValue("UUID", typeof(UUID));
+            ParentUUID = (UUID)info.GetValue("ParentUUID", typeof(UUID));
+            Name = (string)info.GetValue("Name", typeof(string));
+            OwnerID = (UUID)info.GetValue("OwnerID", typeof(UUID));
+        }
+
+        /// <summary>
+        /// Generates a number corresponding to the value of the object to support the use of a hash table,
+        /// suitable for use in hashing algorithms and data structures such as a hash table
+        /// </summary>
+        /// <returns>A Hashcode of all the combined InventoryBase fields</returns>
+        public override int GetHashCode()
+        {
+            return UUID.GetHashCode() ^ ParentUUID.GetHashCode() ^ Name.GetHashCode() ^ OwnerID.GetHashCode();
+        }
+
+        /// <summary>
+        /// Determine whether the specified <seealso cref="OpenMetaverse.InventoryBase"/> object is equal to the current object
+        /// </summary>
+        /// <param name="o">InventoryBase object to compare against</param>
+        /// <returns>true if objects are the same</returns>
+        public override bool Equals(object o)
+        {
+            InventoryBase inv = o as InventoryBase;
+            return inv != null && Equals(inv);
+        }
+
+        /// <summary>
+        /// Determine whether the specified <seealso cref="OpenMetaverse.InventoryBase"/> object is equal to the current object
+        /// </summary>
+        /// <param name="o">InventoryBase object to compare against</param>
+        /// <returns>true if objects are the same</returns>
+        public virtual bool Equals(InventoryBase o)
+        {
+            return o.UUID == UUID
+                && o.ParentUUID == ParentUUID
+                && o.Name == Name
+                && o.OwnerID == OwnerID;
+        }
+    }
+
+    /// <summary>
+    /// An Item in Inventory
+    /// </summary>
+    public class InventoryItem : InventoryBase
+    {
+        /// <summary>The <seealso cref="OpenMetaverse.UUID"/> of this item</summary>
+        public UUID AssetUUID;
+        /// <summary>The combined <seealso cref="OpenMetaverse.Permissions"/> of this item</summary>
+        public Permissions Permissions;
+        /// <summary>The type of item from <seealso cref="OpenMetaverse.AssetType"/></summary>
+        public AssetType AssetType;
+        /// <summary>The type of item from the <seealso cref="OpenMetaverse.InventoryType"/> enum</summary>
+        public InventoryType InventoryType;
+        /// <summary>The <seealso cref="OpenMetaverse.UUID"/> of the creator of this item</summary>
+        public UUID CreatorID;
+        /// <summary>A Description of this item</summary>
+        public string Description;
+        /// <summary>The <seealso cref="OpenMetaverse.Group"/>s <seealso cref="OpenMetaverse.UUID"/> this item is set to or owned by</summary>
+        public UUID GroupID;
+        /// <summary>If true, item is owned by a group</summary>
+        public bool GroupOwned;
+        /// <summary>The price this item can be purchased for</summary>
+        public int SalePrice;
+        /// <summary>The type of sale from the <seealso cref="OpenMetaverse.SaleType"/> enum</summary>
+        public SaleType SaleType;
+        /// <summary>Combined flags from <seealso cref="OpenMetaverse.InventoryItemFlags"/></summary>
+        public uint Flags;
+        /// <summary>Time and date this inventory item was created, stored as
+        /// UTC (Coordinated Universal Time)</summary>
+        public DateTime CreationDate;
+
+        /// <summary>
+        ///  Construct a new InventoryItem object
+        /// </summary>
+        /// <param name="itemID">The <seealso cref="OpenMetaverse.UUID"/> of the item</param>
+        public InventoryItem(UUID itemID) 
+            : base(itemID) { }
+
+        /// <summary>
+        /// Construct a new InventoryItem object of a specific Type
+        /// </summary>
+        /// <param name="type">The type of item from <seealso cref="OpenMetaverse.InventoryType"/></param>
+        /// <param name="itemID"><seealso cref="OpenMetaverse.UUID"/> of the item</param>
+        public InventoryItem(InventoryType type, UUID itemID) : base(itemID) { InventoryType = type; }
+
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        new public void GetObjectData(SerializationInfo info, StreamingContext ctxt) 
+        {
+            base.GetObjectData(info,ctxt);
+            info.AddValue("AssetUUID",AssetUUID,typeof(UUID));
+            info.AddValue("Permissions", Permissions,typeof(Permissions));
+            info.AddValue("AssetType", AssetType);
+            info.AddValue("InventoryType", InventoryType);
+            info.AddValue("CreatorID", CreatorID);
+            info.AddValue("Description", Description);
+            info.AddValue("GroupID", GroupID);
+            info.AddValue("GroupOwned", GroupOwned);
+            info.AddValue("SalePrice", SalePrice);
+            info.AddValue("SaleType", SaleType);
+            info.AddValue("Flags", Flags);
+            info.AddValue("CreationDate", CreationDate);  
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public InventoryItem(SerializationInfo info, StreamingContext ctxt) : base (info,ctxt)
+        {
+           AssetUUID = (UUID)info.GetValue("AssetUUID", typeof(UUID));
+           Permissions =(Permissions)info.GetValue("Permissions",typeof(Permissions));
+           AssetType = (AssetType)info.GetValue("AssetType", typeof(AssetType));
+           InventoryType = (InventoryType)info.GetValue("InventoryType", typeof(InventoryType));
+           CreatorID = (UUID)info.GetValue("CreatorID", typeof(UUID));
+           Description = (string)info.GetValue("Description", typeof(string));
+           GroupID= (UUID)info.GetValue("GroupID", typeof(UUID));
+           GroupOwned = (bool)info.GetValue("GroupOwned", typeof(bool));
+           SalePrice = (int)info.GetValue("SalePrice", typeof(int));
+           SaleType = (SaleType)info.GetValue("SaleType", typeof(SaleType));
+           Flags = (uint)info.GetValue("Flags", typeof(uint));
+           CreationDate = (DateTime)info.GetValue("CreationDate", typeof(DateTime));
+        }
+
+        /// <summary>
+        /// Generates a number corresponding to the value of the object to support the use of a hash table.
+        /// Suitable for use in hashing algorithms and data structures such as a hash table
+        /// </summary>
+        /// <returns>A Hashcode of all the combined InventoryItem fields</returns>
+        public override int GetHashCode()
+        {
+            return AssetUUID.GetHashCode() ^ Permissions.GetHashCode() ^ AssetType.GetHashCode() ^
+                InventoryType.GetHashCode() ^ Description.GetHashCode() ^ GroupID.GetHashCode() ^
+                GroupOwned.GetHashCode() ^ SalePrice.GetHashCode() ^ SaleType.GetHashCode() ^
+                Flags.GetHashCode() ^ CreationDate.GetHashCode();
+        }
+
+        /// <summary>
+        /// Compares an object
+        /// </summary>
+        /// <param name="o">The object to compare</param>
+        /// <returns>true if comparison object matches</returns>
+        public override bool Equals(object o)
+        {
+            InventoryItem item = o as InventoryItem;
+            return item != null && Equals(item);
+        }
+
+        /// <summary>
+        /// Determine whether the specified <seealso cref="OpenMetaverse.InventoryBase"/> object is equal to the current object
+        /// </summary>
+        /// <param name="o">The <seealso cref="OpenMetaverse.InventoryBase"/> object to compare against</param>
+        /// <returns>true if objects are the same</returns>
+        public override bool Equals(InventoryBase o)
+        {
+            InventoryItem item = o as InventoryItem;
+            return item != null && Equals(item);
+        }
+
+        /// <summary>
+        /// Determine whether the specified <seealso cref="OpenMetaverse.InventoryItem"/> object is equal to the current object
+        /// </summary>
+        /// <param name="o">The <seealso cref="OpenMetaverse.InventoryItem"/> object to compare against</param>
+        /// <returns>true if objects are the same</returns>
+        public bool Equals(InventoryItem o)
+        {
+            return base.Equals(o as InventoryBase)
+                && o.AssetType == AssetType
+                && o.AssetUUID == AssetUUID
+                && o.CreationDate == CreationDate
+                && o.Description == Description
+                && o.Flags == Flags
+                && o.GroupID == GroupID
+                && o.GroupOwned == GroupOwned
+                && o.InventoryType == InventoryType
+                && o.Permissions.Equals(Permissions)
+                && o.SalePrice == SalePrice
+                && o.SaleType == SaleType;
+        }
+    }
+
+    /// <summary>
+    /// InventoryTexture Class representing a graphical image
+    /// </summary>
+    /// <seealso cref="ManagedImage"/>
+    public class InventoryTexture : InventoryItem 
+    { 
+        /// <summary>
+        /// Construct an InventoryTexture object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventoryTexture(UUID itemID) : base(itemID) 
+        { 
+            InventoryType = InventoryType.Texture; 
+        } 
+
+        public InventoryTexture(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Texture; 
+        }
+    }
+
+    /// <summary>
+    /// InventorySound Class representing a playable sound
+    /// </summary>
+    public class InventorySound : InventoryItem 
+    {
+        /// <summary>
+        /// Construct an InventorySound object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventorySound(UUID itemID) : base(itemID) 
+        { 
+            InventoryType = InventoryType.Sound; 
+        } 
+
+        public InventorySound(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Sound; 
+        }
+    }
+
+    /// <summary>
+    /// InventoryCallingCard Class, contains information on another avatar
+    /// </summary>
+    public class InventoryCallingCard : InventoryItem 
+    {
+        /// <summary>
+        /// Construct an InventoryCallingCard object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventoryCallingCard(UUID itemID) : base(itemID) 
+        { 
+            InventoryType = InventoryType.CallingCard; 
+        }
+        public InventoryCallingCard(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.CallingCard; 
+        }
+    }
+
+    /// <summary>
+    /// InventoryLandmark Class, contains details on a specific location
+    /// </summary>
+    public class InventoryLandmark : InventoryItem 
+    {
+        /// <summary>
+        /// Construct an InventoryLandmark object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventoryLandmark(UUID itemID) : base(itemID) 
+        { 
+            InventoryType = InventoryType.Landmark; 
+        }
+
+        public InventoryLandmark(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Landmark;
+
+        }
+
+        /// <summary>
+        /// Landmarks use the ObjectType struct and will have a flag of 1 set if they have been visited
+        /// </summary>
+        public ObjectType LandmarkType
+        {
+            get { return (ObjectType)Flags; }
+            set { Flags = (uint)value; }
+        }
+    }
+
+    /// <summary>
+    /// InventoryObject Class contains details on a primitive or coalesced set of primitives
+    /// </summary>
+    public class InventoryObject : InventoryItem 
+    {
+        /// <summary>
+        /// Construct an InventoryObject object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventoryObject(UUID itemID) : base(itemID) 
+        { 
+            InventoryType = InventoryType.Object; 
+        }
+
+        public InventoryObject(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Object; 
+        }
+
+        /// <summary>
+        /// Get the Objects permission override settings
+        /// 
+        /// These will indicate the which permissions that 
+        /// will be overwritten when the object is rezzed in-world
+        /// </summary>
+        public ObjectType ObjectType
+        {
+            get { return (ObjectType)Flags; }
+            set { Flags = (uint)value; }
+        }
+    }
+
+    /// <summary>
+    /// InventoryNotecard Class, contains details on an encoded text document
+    /// </summary>
+    public class InventoryNotecard : InventoryItem 
+    {
+        /// <summary>
+        /// Construct an InventoryNotecard object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventoryNotecard(UUID itemID) : base(itemID) 
+        { 
+            InventoryType = InventoryType.Notecard; 
+        }
+        public InventoryNotecard(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Notecard; 
+        }
+    }
+
+    /// <summary>
+    /// InventoryCategory Class
+    /// </summary>
+    /// <remarks>TODO: Is this even used for anything?</remarks>
+    public class InventoryCategory : InventoryItem 
+    {
+        /// <summary>
+        /// Construct an InventoryCategory object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventoryCategory(UUID itemID) : base(itemID) 
+        { 
+            InventoryType = InventoryType.Category; 
+        } 
+
+        public InventoryCategory(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Category; 
+        }
+    }
+
+    /// <summary>
+    /// InventoryLSL Class, represents a Linden Scripting Language object
+    /// </summary>
+    public class InventoryLSL : InventoryItem 
+    {
+        /// <summary>
+        /// Construct an InventoryLSL object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventoryLSL(UUID itemID) : base(itemID) 
+        { 
+            InventoryType = InventoryType.LSL; 
+        } 
+
+        public InventoryLSL(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.LSL; 
+        }
+    }
+
+    /// <summary>
+    /// InventorySnapshot Class, an image taken with the viewer
+    /// </summary>
+    public class InventorySnapshot : InventoryItem 
+    {
+        /// <summary>
+        /// Construct an InventorySnapshot object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventorySnapshot(UUID itemID) : base(itemID) 
+        { 
+            InventoryType = InventoryType.Snapshot; 
+        } 
+
+        public InventorySnapshot(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Snapshot; 
+        }
+    }
+
+    /// <summary>
+    /// InventoryAttachment Class, contains details on an attachable object
+    /// </summary>
+    public class InventoryAttachment  : InventoryItem 
+    {
+        /// <summary>
+        /// Construct an InventoryAttachment object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventoryAttachment(UUID itemID) : base(itemID) 
+        { 
+            InventoryType = InventoryType.Attachment; 
+        }
+
+        public InventoryAttachment(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Attachment; 
+        }
+
+        /// <summary>
+        /// Get the last AttachmentPoint this object was attached to
+        /// </summary>
+        public AttachmentPoint AttachmentPoint
+        {
+            get { return (AttachmentPoint)Flags; }
+            set { Flags = (uint)value; }
+        }
+    }
+
+    /// <summary>
+    /// InventoryWearable Class, details on a clothing item or body part
+    /// </summary>
+    public class InventoryWearable : InventoryItem
+    {
+        /// <summary>
+        /// Construct an InventoryWearable object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventoryWearable(UUID itemID) : base(itemID) { InventoryType = InventoryType.Wearable; }
+
+        public InventoryWearable(SerializationInfo info, StreamingContext ctxt) : base(info, ctxt)
+        {
+            InventoryType = InventoryType.Wearable; 
+        }
+
+        /// <summary>
+        /// The <seealso cref="OpenMetaverse.WearableType"/>, Skin, Shape, Skirt, Etc
+        /// </summary>
+        public WearableType WearableType
+        {
+            get { return (WearableType)Flags; }
+            set { Flags = (uint)value; }
+        }
+    }
+
+    /// <summary>
+    /// InventoryAnimation Class, A bvh encoded object which animates an avatar
+    /// </summary>
+    public class InventoryAnimation : InventoryItem 
+    {
+        /// <summary>
+        /// Construct an InventoryAnimation object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventoryAnimation(UUID itemID) : base(itemID) 
+        { 
+            InventoryType = InventoryType.Animation; 
+        }
+
+        public InventoryAnimation(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Animation; 
+        }
+ 
+
+    }
+
+    /// <summary>
+    /// InventoryGesture Class, details on a series of animations, sounds, and actions
+    /// </summary>
+    public class InventoryGesture : InventoryItem 
+    {
+        /// <summary>
+        /// Construct an InventoryGesture object
+        /// </summary>
+        /// <param name="itemID">A <seealso cref="OpenMetaverse.UUID"/> which becomes the 
+        /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
+        public InventoryGesture(UUID itemID) : base(itemID) 
+        { 
+            InventoryType = InventoryType.Gesture; 
+        } 
+
+        public InventoryGesture(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Gesture; 
+        }
+    }
+    
+    /// <summary>
+    /// A folder contains <seealso cref="T:OpenMetaverse.InventoryItem"/>s and has certain attributes specific 
+    /// to itself
+    /// </summary>
+    public class InventoryFolder : InventoryBase
+    {
+        /// <summary>The Preferred <seealso cref="T:OpenMetaverse.AssetType"/> for a folder.</summary>
+        public AssetType PreferredType;
+        /// <summary>The Version of this folder</summary>
+        public int Version;
+        /// <summary>Number of child items this folder contains.</summary>
+        public int DescendentCount;
+
+        /// <summary>
+        /// Constructor
+        /// </summary>
+        /// <param name="itemID">UUID of the folder</param>
+        public InventoryFolder(UUID itemID)
+            : base(itemID) { }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public override string ToString()
+        {
+            return Name;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        new public void GetObjectData(SerializationInfo info, StreamingContext ctxt)
+        {
+            base.GetObjectData(info,ctxt);
+            info.AddValue("PreferredType", PreferredType, typeof(AssetType));
+            info.AddValue("Version", Version);
+            info.AddValue("DescendentCount", DescendentCount);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public InventoryFolder(SerializationInfo info, StreamingContext ctxt) : base (info, ctxt)
+        {
+            PreferredType = (AssetType)info.GetValue("PreferredType", typeof(AssetType));
+            Version=(int)info.GetValue("Version",typeof(int));
+            DescendentCount = (int)info.GetValue("DescendentCount", typeof(int));
+        }
+
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public override int GetHashCode()
+        {
+            return PreferredType.GetHashCode() ^ Version.GetHashCode() ^ DescendentCount.GetHashCode();
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="o"></param>
+        /// <returns></returns>
+        public override bool Equals(object o)
+        {
+            InventoryFolder folder = o as InventoryFolder;
+            return folder != null && Equals(folder);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="o"></param>
+        /// <returns></returns>
+        public override bool Equals(InventoryBase o)
+        {
+            InventoryFolder folder = o as InventoryFolder;
+            return folder != null && Equals(folder);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="o"></param>
+        /// <returns></returns>
+        public bool Equals(InventoryFolder o)
+        {
+            return base.Equals(o as InventoryBase)
+                && o.DescendentCount == DescendentCount
+                && o.PreferredType == PreferredType
+                && o.Version == Version;
+        }
+    }
+
+    #endregion Inventory Object Classes
+
+    /// <summary>
+    /// Tools for dealing with agents inventory
+    /// </summary>
+    public class InventoryManager
+    {
+        protected struct InventorySearch
+        {
+            public UUID Folder;
+            public UUID Owner;
+            public string[] Path;
+            public int Level;
+        }
+
+        #region Delegates
+
+        /// <summary>
+        /// Callback for inventory item creation finishing
+        /// </summary>
+        /// <param name="success">Whether the request to create an inventory
+        /// item succeeded or not</param>
+        /// <param name="item">Inventory item being created. If success is
+        /// false this will be null</param>
+        public delegate void ItemCreatedCallback(bool success, InventoryItem item);
+
+        /// <summary>
+        /// Callback for an inventory item being create from an uploaded asset
+        /// </summary>
+        /// <param name="success">true if inventory item creation was successful</param>
+        /// <param name="status"></param>
+        /// <param name="itemID"></param>
+        /// <param name="assetID"></param>
+        public delegate void ItemCreatedFromAssetCallback(bool success, string status, UUID itemID, UUID assetID);
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="item"></param>
+        public delegate void ItemCopiedCallback(InventoryBase item);
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="item"></param>
+        public delegate void ItemReceivedCallback(InventoryItem item);
+
+        /// <summary>
+        /// Callback for an inventory folder updating
+        /// </summary>
+        /// <param name="folderID">UUID of the folder that was updated</param>
+        public delegate void FolderUpdatedCallback(UUID folderID);
+
+        /// <summary>
+        /// Callback for when an inventory item is offered to us by another avatar or an object
+        /// </summary>
+        /// <param name="offerDetails">A <seealso cref="InstantMessage"/> object containing specific
+        /// details on the item being offered, eg who its from</param>
+        /// <param name="type">The <seealso cref="AssetType"/>AssetType being offered</param>
+        /// <param name="objectID">Will be null if item is offered from an object</param>
+        /// <param name="fromTask">will be true of item is offered from an object</param>
+        /// <returns>Return true to accept the offer, or false to decline it</returns>
+        public delegate bool ObjectOfferedCallback(InstantMessage offerDetails, AssetType type, UUID objectID, bool fromTask);
+
+        /// <summary>
+        /// Callback when an inventory object is accepted and received from a
+        /// task inventory. This is the callback in which you actually get
+        /// the ItemID, as in ObjectOfferedCallback it is null when received
+        /// from a task.
+        /// </summary>
+        /// <param name="itemID"></param>
+        /// <param name="folderID"></param>
+        /// <param name="creatorID"></param>
+        /// <param name="assetID"></param>
+        /// <param name="type"></param>
+        public delegate void TaskItemReceivedCallback(UUID itemID, UUID folderID, UUID creatorID, 
+            UUID assetID, InventoryType type);
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="path"></param>
+        /// <param name="inventoryObjectID"></param>
+        public delegate void FindObjectByPathCallback(string path, UUID inventoryObjectID);
+
+        /// <summary>
+        /// Reply received after calling <code>RequestTaskInventory</code>,
+        /// contains a filename that can be used in an asset download request
+        /// </summary>
+        /// <param name="itemID">UUID of the inventory item</param>
+        /// <param name="serial">Version number of the task inventory asset</param>
+        /// <param name="assetFilename">Filename of the task inventory asset</param>
+        public delegate void TaskInventoryReplyCallback(UUID itemID, short serial, string assetFilename);
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="success"></param>
+        /// <param name="status"></param>
+        /// <param name="itemID"></param>
+        /// <param name="assetID"></param>
+        public delegate void NotecardUploadedAssetCallback(bool success, string status, UUID itemID, UUID assetID);
+
+        #endregion Delegates
+
+        #region Events
+
+        /// <summary>
+        /// Fired when a reply to a RequestFetchInventory() is received
+        /// </summary>
+        /// <seealso cref="InventoryManager.RequestFetchInventory"/>
+        public event ItemReceivedCallback OnItemReceived;
+
+        /// <summary>
+        /// Fired when a response to a RequestFolderContents() is received 
+        /// </summary>
+        /// <seealso cref="InventoryManager.RequestFolderContents"/>
+        public event FolderUpdatedCallback OnFolderUpdated;
+
+        /// <summary>
+        /// Fired when an object or another avatar offers us an inventory item
+        /// </summary>
+        public event ObjectOfferedCallback OnObjectOffered;
+       
+        /// <summary>
+        /// Fired when a response to FindObjectByPath() is received
+        /// </summary>
+        /// <seealso cref="InventoryManager.FindObjectByPath"/>
+        public event FindObjectByPathCallback OnFindObjectByPath;
+
+        /// <summary>
+        /// Fired when a task inventory item is received
+        /// 
+        /// This may occur when an object that's rezzed in world is
+        /// taken into inventory, when an item is created using the CreateInventoryItem
+        /// packet, or when an object is purchased
+        /// </summary>
+        public event TaskItemReceivedCallback OnTaskItemReceived;
+
+        /// <summary>
+        /// Fired in response to a request for a tasks (primitive) inventory
+        /// </summary>
+        /// <seealso cref="InventoryManager.GetTaskInventory"/>
+        /// <seealso cref="InventoryManager.RequestTaskInventory"/>
+        public event TaskInventoryReplyCallback OnTaskInventoryReply;
+
+        #endregion Events
+
+        private GridClient _Client;
+        private Inventory _Store;
+        //private Random _RandNumbers = new Random();
+        private object _CallbacksLock = new object();
+        private uint _CallbackPos;
+        private Dictionary<uint, ItemCreatedCallback> _ItemCreatedCallbacks = new Dictionary<uint, ItemCreatedCallback>();
+        private Dictionary<uint, ItemCopiedCallback> _ItemCopiedCallbacks = new Dictionary<uint,ItemCopiedCallback>();
+        private List<InventorySearch> _Searches = new List<InventorySearch>();
+
+        #region String Arrays
+
+        /// <summary>Partial mapping of AssetTypes to folder names</summary>
+        private static readonly string[] _NewFolderNames = new string[]
+        {
+            "Textures",
+            "Sounds",
+            "Calling Cards",
+            "Landmarks",
+            "Scripts",
+            "Clothing",
+            "Objects",
+            "Notecards",
+            "New Folder",
+            "Inventory",
+            "Scripts",
+            "Scripts",
+            "Uncompressed Images",
+            "Body Parts",
+            "Trash",
+            "Photo Album",
+            "Lost And Found",
+            "Uncompressed Sounds",
+            "Uncompressed Images",
+            "Uncompressed Images",
+            "Animations",
+            "Gestures"
+        };
+
+        private static readonly string[] _AssetTypeNames = new string[]
+        {
+            "texture",
+	        "sound",
+	        "callcard",
+	        "landmark",
+	        "script",
+	        "clothing",
+	        "object",
+	        "notecard",
+	        "category",
+	        "root",
+	        "lsltext",
+	        "lslbyte",
+	        "txtr_tga",
+	        "bodypart",
+	        "trash",
+	        "snapshot",
+	        "lstndfnd",
+	        "snd_wav",
+	        "img_tga",
+	        "jpeg",
+	        "animatn",
+	        "gesture",
+	        "simstate"
+        };
+
+        private static readonly string[] _InventoryTypeNames = new string[]
+        {
+            "texture",
+	        "sound",
+	        "callcard",
+	        "landmark",
+	        String.Empty,
+	        String.Empty,
+	        "object",
+	        "notecard",
+	        "category",
+	        "root",
+	        "script",
+	        String.Empty,
+	        String.Empty,
+	        String.Empty,
+	        String.Empty,
+	        "snapshot",
+	        String.Empty,
+	        "attach",
+	        "wearable",
+	        "animation",
+	        "gesture",
+        };
+
+        private static readonly string[] _SaleTypeNames = new string[]
+        {
+            "not",
+            "orig",
+            "copy",
+            "cntn"
+        };
+
+        #endregion String Arrays
+
+        #region Properties
+
+        /// <summary>
+        /// Get this agents Inventory data
+        /// </summary>
+        public Inventory Store { get { return _Store; } }
+
+        #endregion Properties
+
+        /// <summary>
+        /// Default constructor
+        /// </summary>
+        /// <param name="client">Reference to the GridClient object</param>
+        public InventoryManager(GridClient client)
+        {
+            _Client = client;
+
+            _Client.Network.RegisterCallback(PacketType.UpdateCreateInventoryItem, new NetworkManager.PacketCallback(UpdateCreateInventoryItemHandler));
+            _Client.Network.RegisterCallback(PacketType.SaveAssetIntoInventory, new NetworkManager.PacketCallback(SaveAssetIntoInventoryHandler));
+            _Client.Network.RegisterCallback(PacketType.BulkUpdateInventory, new NetworkManager.PacketCallback(BulkUpdateInventoryHandler));
+            _Client.Network.RegisterCallback(PacketType.MoveInventoryItem, new NetworkManager.PacketCallback(MoveInventoryItemHandler));
+            _Client.Network.RegisterCallback(PacketType.InventoryDescendents, new NetworkManager.PacketCallback(InventoryDescendentsHandler));
+            _Client.Network.RegisterCallback(PacketType.FetchInventoryReply, new NetworkManager.PacketCallback(FetchInventoryReplyHandler));
+            _Client.Network.RegisterCallback(PacketType.ReplyTaskInventory, new NetworkManager.PacketCallback(ReplyTaskInventoryHandler));
+            
+            // Watch for inventory given to us through instant message
+            _Client.Self.OnInstantMessage += new AgentManager.InstantMessageCallback(Self_OnInstantMessage);
+
+            // Register extra parameters with login and parse the inventory data that comes back
+            _Client.Network.RegisterLoginResponseCallback(
+                new NetworkManager.LoginResponseCallback(Network_OnLoginResponse),
+                new string[] {
+                    "inventory-root", "inventory-skeleton", "inventory-lib-root",
+                    "inventory-lib-owner", "inventory-skel-lib"});
+        }
+
+        #region Fetch
+
+        /// <summary>
+        /// Fetch an inventory item from the dataserver
+        /// </summary>
+        /// <param name="itemID">The items <seealso cref="UUID"/></param>
+        /// <param name="ownerID">The item Owners <seealso cref="OpenMetaverse.UUID"/></param>
+        /// <param name="timeoutMS">a integer representing the number of milliseconds to wait for results</param>
+        /// <returns>An <seealso cref="InventoryItem"/> object on success, or null if no item was found</returns>
+        /// <remarks>Items will also be sent to the <seealso cref="InventoryManager.OnItemReceived"/> event</remarks>
+        public InventoryItem FetchItem(UUID itemID, UUID ownerID, int timeoutMS)
+        {
+            AutoResetEvent fetchEvent = new AutoResetEvent(false);
+            InventoryItem fetchedItem = null;
+
+            ItemReceivedCallback callback =
+                delegate(InventoryItem item)
+                {
+                    if (item.UUID == itemID)
+                    {
+                        fetchedItem = item;
+                        fetchEvent.Set();
+                    }
+                };
+
+            OnItemReceived += callback;
+            RequestFetchInventory(itemID, ownerID);
+
+            fetchEvent.WaitOne(timeoutMS, false);
+            OnItemReceived -= callback;
+
+            return fetchedItem;
+        }
+
+        /// <summary>
+        /// Request A single inventory item
+        /// </summary>
+        /// <param name="itemID">The items <seealso cref="OpenMetaverse.UUID"/></param>
+        /// <param name="ownerID">The item Owners <seealso cref="OpenMetaverse.UUID"/></param>
+        /// <seealso cref="InventoryManager.OnItemReceived"/>
+        public void RequestFetchInventory(UUID itemID, UUID ownerID)
+        {
+            FetchInventoryPacket fetch = new FetchInventoryPacket();
+            fetch.AgentData = new FetchInventoryPacket.AgentDataBlock();
+            fetch.AgentData.AgentID = _Client.Self.AgentID;
+            fetch.AgentData.SessionID = _Client.Self.SessionID;
+
+            fetch.InventoryData = new FetchInventoryPacket.InventoryDataBlock[1];
+            fetch.InventoryData[0] = new FetchInventoryPacket.InventoryDataBlock();
+            fetch.InventoryData[0].ItemID = itemID;
+            fetch.InventoryData[0].OwnerID = ownerID;
+
+            _Client.Network.SendPacket(fetch);
+        }
+
+        /// <summary>
+        /// Request inventory items
+        /// </summary>
+        /// <param name="itemIDs">Inventory items to request</param>
+        /// <param name="ownerIDs">Owners of the inventory items</param>
+        /// <seealso cref="InventoryManager.OnItemReceived"/>
+        public void RequestFetchInventory(List<UUID> itemIDs, List<UUID> ownerIDs)
+        {
+            if (itemIDs.Count != ownerIDs.Count)
+                throw new ArgumentException("itemIDs and ownerIDs must contain the same number of entries");
+
+            FetchInventoryPacket fetch = new FetchInventoryPacket();
+            fetch.AgentData = new FetchInventoryPacket.AgentDataBlock();
+            fetch.AgentData.AgentID = _Client.Self.AgentID;
+            fetch.AgentData.SessionID = _Client.Self.SessionID;
+
+            fetch.InventoryData = new FetchInventoryPacket.InventoryDataBlock[itemIDs.Count];
+            for (int i = 0; i < itemIDs.Count; i++)
+            {
+                fetch.InventoryData[i] = new FetchInventoryPacket.InventoryDataBlock();
+                fetch.InventoryData[i].ItemID = itemIDs[i];
+                fetch.InventoryData[i].OwnerID = ownerIDs[i];
+            }
+
+            _Client.Network.SendPacket(fetch);
+        }
+
+        /// <summary>
+        /// Get contents of a folder
+        /// </summary>
+        /// <param name="folder">The <seealso cref="UUID"/> of the folder to search</param>
+        /// <param name="owner">The <seealso cref="UUID"/> of the folders owner</param>
+        /// <param name="folders">true to retrieve folders</param>
+        /// <param name="items">true to retrieve items</param>
+        /// <param name="order">sort order to return results in</param>
+        /// <param name="timeoutMS">a integer representing the number of milliseconds to wait for results</param>
+        /// <returns>A list of inventory items matching search criteria within folder</returns>
+        /// <seealso cref="InventoryManager.RequestFolderContents"/>
+        /// <remarks>InventoryFolder.DescendentCount will only be accurate if both folders and items are
+        /// requested</remarks>
+        public List<InventoryBase> FolderContents(UUID folder, UUID owner, bool folders, bool items,
+            InventorySortOrder order, int timeoutMS)
+        {
+            List<InventoryBase> objects = null;
+            AutoResetEvent fetchEvent = new AutoResetEvent(false);
+
+            FolderUpdatedCallback callback =
+                delegate(UUID folderID)
+                {
+                    if (folderID == folder
+                        && _Store[folder] is InventoryFolder)
+                    {
+                        // InventoryDescendentsHandler only stores DescendendCount if both folders and items are fetched.
+                        if (_Store.GetContents(folder).Count >= ((InventoryFolder)_Store[folder]).DescendentCount)
+                        {
+                            
+                            fetchEvent.Set();
+                        }
+                    }
+                    else
+                    {
+                        fetchEvent.Set();
+                    }
+                };
+
+            OnFolderUpdated += callback;
+
+            RequestFolderContents(folder, owner, folders, items, order);
+            if (fetchEvent.WaitOne(timeoutMS, false))
+                objects = _Store.GetContents(folder);
+
+            OnFolderUpdated -= callback;
+
+            return objects;
+        }
+
+        /// <summary>
+        /// Request the contents of an inventory folder
+        /// </summary>
+        /// <param name="folder">The folder to search</param>
+        /// <param name="owner">The folder owners <seealso cref="UUID"/></param>
+        /// <param name="folders">true to return <seealso cref="InventoryManager.InventoryFolder"/>s contained in folder</param>
+        /// <param name="items">true to return <seealso cref="InventoryManager.InventoryItem"/>s containd in folder</param>
+        /// <param name="order">the sort order to return items in</param>
+        /// <seealso cref="InventoryManager.FolderContents"/>
+        public void RequestFolderContents(UUID folder, UUID owner, bool folders, bool items, 
+            InventorySortOrder order)
+        {
+            FetchInventoryDescendentsPacket fetch = new FetchInventoryDescendentsPacket();
+            fetch.AgentData.AgentID = _Client.Self.AgentID;
+            fetch.AgentData.SessionID = _Client.Self.SessionID;
+
+            fetch.InventoryData.FetchFolders = folders;
+            fetch.InventoryData.FetchItems = items;
+            fetch.InventoryData.FolderID = folder;
+            fetch.InventoryData.OwnerID = owner;
+            fetch.InventoryData.SortOrder = (int)order;
+
+            _Client.Network.SendPacket(fetch);
+        }
+
+        #endregion Fetch
+
+        #region Find
+
+        /// <summary>
+        /// Returns the UUID of the folder (category) that defaults to
+        /// containing 'type'. The folder is not necessarily only for that
+        /// type
+        /// </summary>
+        /// <remarks>This will return the root folder if one does not exist</remarks>
+        /// <param name="type"></param>
+        /// <returns>The UUID of the desired folder if found, the UUID of the RootFolder
+        /// if not found, or UUID.Zero on failure</returns>
+        public UUID FindFolderForType(AssetType type)
+        {
+            if (_Store == null)
+            {
+                Logger.Log("Inventory is null, FindFolderForType() lookup cannot continue",
+                    Helpers.LogLevel.Error, _Client);
+                return UUID.Zero;
+            }
+
+            // Folders go in the root
+            if (type == AssetType.Folder)
+                return _Store.RootFolder.UUID;
+
+            // Loop through each top-level directory and check if PreferredType
+            // matches the requested type
+            List<InventoryBase> contents = _Store.GetContents(_Store.RootFolder.UUID);
+            foreach (InventoryBase inv in contents)
+            {
+                if (inv is InventoryFolder)
+                {
+                    InventoryFolder folder = inv as InventoryFolder;
+
+                    if (folder.PreferredType == type)
+                        return folder.UUID;
+                }
+            }
+
+            // No match found, return Root Folder ID
+            return _Store.RootFolder.UUID;
+        }
+
+        /// <summary>
+        /// Find an object in inventory using a specific path to search
+        /// </summary>
+        /// <param name="baseFolder">The folder to begin the search in</param>
+        /// <param name="inventoryOwner">The object owners <seealso cref="UUID"/></param>
+        /// <param name="path">A string path to search</param>
+        /// <param name="timeoutMS">milliseconds to wait for a reply</param>
+        /// <returns>Found items <seealso cref="UUID"/> or <seealso cref="UUID.Zero"/> if 
+        /// timeout occurs or item is not found</returns>
+        public UUID FindObjectByPath(UUID baseFolder, UUID inventoryOwner, string path, int timeoutMS)
+        {
+            AutoResetEvent findEvent = new AutoResetEvent(false);
+            UUID foundItem = UUID.Zero;
+
+            FindObjectByPathCallback callback =
+                delegate(string thisPath, UUID inventoryObjectID)
+                {
+                    if (thisPath == path)
+                    {
+                        foundItem = inventoryObjectID;
+                        findEvent.Set();
+                    }
+                };
+
+            OnFindObjectByPath += callback;
+
+            RequestFindObjectByPath(baseFolder, inventoryOwner, path);
+            findEvent.WaitOne(timeoutMS, false);
+
+            OnFindObjectByPath -= callback;
+
+            return foundItem;
+        }
+
+        /// <summary>
+        /// Find inventory items by path
+        /// </summary>
+        /// <param name="baseFolder">The folder to begin the search in</param>
+        /// <param name="inventoryOwner">The object owners <seealso cref="UUID"/></param>
+        /// <param name="path">A string path to search, folders/objects separated by a '/'</param>
+        /// <remarks>Results are sent to the <seealso cref="InventoryManager.OnFindObjectByPath"/> event</remarks>
+        public void RequestFindObjectByPath(UUID baseFolder, UUID inventoryOwner, string path)
+        {
+            if (path == null || path.Length == 0)
+                throw new ArgumentException("Empty path is not supported");
+
+            // Store this search
+            InventorySearch search;
+            search.Folder = baseFolder;
+            search.Owner = inventoryOwner;
+            search.Path = path.Split('/');
+            search.Level = 0;
+            lock (_Searches) _Searches.Add(search);
+
+            // Start the search
+            RequestFolderContents(baseFolder, inventoryOwner, true, true, InventorySortOrder.ByName);
+        }
+
+        /// <summary>
+        /// Search inventory Store object for an item or folder
+        /// </summary>
+        /// <param name="baseFolder">The folder to begin the search in</param>
+        /// <param name="path">An array which creates a path to search</param>
+        /// <param name="level">Number of levels below baseFolder to conduct searches</param>
+        /// <param name="firstOnly">if True, will stop searching after first match is found</param>
+        /// <returns>A list of inventory items found</returns>
+        public List<InventoryBase> LocalFind(UUID baseFolder, string[] path, int level, bool firstOnly)
+        {
+            List<InventoryBase> objects = new List<InventoryBase>();
+            //List<InventoryFolder> folders = new List<InventoryFolder>();
+            List<InventoryBase> contents = _Store.GetContents(baseFolder);
+
+            foreach (InventoryBase inv in contents)
+            {
+                if (inv.Name.CompareTo(path[level]) == 0)
+                {
+                    if (level == path.Length - 1)
+                    {
+                        objects.Add(inv);
+                        if (firstOnly) return objects;
+                    }
+                    else if (inv is InventoryFolder)
+                        objects.AddRange(LocalFind(inv.UUID, path, level + 1, firstOnly));
+                }
+            }
+
+            return objects;
+        }
+
+        #endregion Find
+
+        #region Move/Rename
+        
+        /// <summary>
+        /// Move an inventory item or folder to a new location
+        /// </summary>
+        /// <param name="item">The <seealso cref="T:InventoryBase"/> item or folder to move</param>
+        /// <param name="newParent">The <seealso cref="T:InventoryFolder"/> to move item or folder to</param>
+        public void Move(InventoryBase item, InventoryFolder newParent)
+        {
+            if (item is InventoryFolder)
+                MoveFolder(item.UUID, newParent.UUID);
+            else
+                MoveItem(item.UUID, newParent.UUID);
+        }
+
+        /// <summary>
+        /// Move an inventory item or folder to a new location and change its name
+        /// </summary>
+        /// <param name="item">The <seealso cref="T:InventoryBase"/> item or folder to move</param>
+        /// <param name="newParent">The <seealso cref="T:InventoryFolder"/> to move item or folder to</param>
+        /// <param name="newName">The name to change the item or folder to</param>
+        public void Move(InventoryBase item, InventoryFolder newParent, string newName)
+        {
+            if (item is InventoryFolder)
+                MoveFolder(item.UUID, newParent.UUID, newName);
+            else
+                MoveItem(item.UUID, newParent.UUID, newName);
+        }
+
+        /// <summary>
+        /// Move and rename a folder
+        /// </summary>
+        /// <param name="folderID">The source folders <seealso cref="UUID"/></param>
+        /// <param name="newparentID">The destination folders <seealso cref="UUID"/></param>
+        /// <param name="newName">The name to change the folder to</param>
+        public void MoveFolder(UUID folderID, UUID newparentID, string newName)
+        {
+            lock (Store)
+            {
+                if (_Store.Contains(folderID))
+                {
+                    InventoryBase inv = Store[folderID];
+                    inv.Name = newName;
+                    _Store.UpdateNodeFor(inv);
+                }
+            }
+
+            UpdateInventoryFolderPacket move = new UpdateInventoryFolderPacket();
+            move.AgentData.AgentID = _Client.Self.AgentID;
+            move.AgentData.SessionID = _Client.Self.SessionID;
+            move.FolderData = new UpdateInventoryFolderPacket.FolderDataBlock[1];
+            move.FolderData[0] = new UpdateInventoryFolderPacket.FolderDataBlock();
+            move.FolderData[0].FolderID = folderID;
+            move.FolderData[0].ParentID = newparentID;
+            move.FolderData[0].Name = Utils.StringToBytes(newName);
+            move.FolderData[0].Type = -1;
+
+            _Client.Network.SendPacket(move);
+        }
+
+        /// <summary>
+        /// Move a folder
+        /// </summary>
+        /// <param name="folderID">The source folders <seealso cref="UUID"/></param>
+        /// <param name="newParentID">The destination folders <seealso cref="UUID"/></param>
+        public void MoveFolder(UUID folderID, UUID newParentID)
+        {
+            lock (Store)
+            {
+                if (_Store.Contains(folderID))
+                {
+                    InventoryBase inv = Store[folderID];
+                    inv.ParentUUID = newParentID;
+                    _Store.UpdateNodeFor(inv);
+                }
+            }
+
+            MoveInventoryFolderPacket move = new MoveInventoryFolderPacket();
+            move.AgentData.AgentID = _Client.Self.AgentID;
+            move.AgentData.SessionID = _Client.Self.SessionID;
+            move.AgentData.Stamp = false; //FIXME: ??
+
+            move.InventoryData = new MoveInventoryFolderPacket.InventoryDataBlock[1];
+            move.InventoryData[0] = new MoveInventoryFolderPacket.InventoryDataBlock();
+            move.InventoryData[0].FolderID = folderID;
+            move.InventoryData[0].ParentID = newParentID;
+            
+            _Client.Network.SendPacket(move);
+        }
+ 
+        /// <summary>
+        /// Move multiple folders, the keys in the Dictionary parameter,
+        /// to a new parents, the value of that folder's key.
+        /// </summary>
+        /// <param name="foldersNewParents">A Dictionary containing the 
+        /// <seealso cref="UUID"/> of the source as the key, and the 
+        /// <seealso cref="UUID"/> of the destination as the value</param>
+        public void MoveFolders(Dictionary<UUID, UUID> foldersNewParents)
+        {
+            // FIXME: Use two List<UUID> to stay consistent
+
+            lock (Store)
+            {
+                foreach (KeyValuePair<UUID, UUID> entry in foldersNewParents)
+                {
+                    if (_Store.Contains(entry.Key))
+                    {
+                        InventoryBase inv = _Store[entry.Key];
+                        inv.ParentUUID = entry.Value;
+                        _Store.UpdateNodeFor(inv);
+                    }
+                }
+            }
+
+            //TODO: Test if this truly supports multiple-folder move
+            MoveInventoryFolderPacket move = new MoveInventoryFolderPacket();
+            move.AgentData.AgentID = _Client.Self.AgentID;
+            move.AgentData.SessionID = _Client.Self.SessionID;
+            move.AgentData.Stamp = false; //FIXME: ??
+
+            move.InventoryData = new MoveInventoryFolderPacket.InventoryDataBlock[foldersNewParents.Count];
+
+            int index = 0;
+            foreach (KeyValuePair<UUID, UUID> folder in foldersNewParents)
+            {
+                MoveInventoryFolderPacket.InventoryDataBlock block = new MoveInventoryFolderPacket.InventoryDataBlock();
+                block.FolderID = folder.Key;
+                block.ParentID = folder.Value;
+                move.InventoryData[index++] = block;
+            }
+
+            _Client.Network.SendPacket(move);
+        }
+
+
+        /// <summary>
+        /// Move an inventory item to a new folder
+        /// </summary>
+        /// <param name="itemID">The <seealso cref="UUID"/> of the source item to move</param>
+        /// <param name="folderID">The <seealso cref="UUID"/> of the destination folder</param>
+        public void MoveItem(UUID itemID, UUID folderID)
+        {
+            MoveItem(itemID, folderID, String.Empty);
+        }
+
+        /// <summary>
+        /// Move and rename an inventory item
+        /// </summary>
+        /// <param name="itemID">The <seealso cref="UUID"/> of the source item to move</param>
+        /// <param name="folderID">The <seealso cref="UUID"/> of the destination folder</param>
+        /// <param name="newName">The name to change the folder to</param>
+        public void MoveItem(UUID itemID, UUID folderID, string newName)
+        {
+            lock (_Store)
+            {
+                    if (_Store.Contains(itemID))
+                    {
+                        InventoryBase inv = _Store[itemID];
+                        inv.ParentUUID = folderID;
+                        _Store.UpdateNodeFor(inv);
+                    }
+            }
+
+            MoveInventoryItemPacket move = new MoveInventoryItemPacket();
+            move.AgentData.AgentID = _Client.Self.AgentID;
+            move.AgentData.SessionID = _Client.Self.SessionID;
+            move.AgentData.Stamp = false; //FIXME: ??
+
+            move.InventoryData = new MoveInventoryItemPacket.InventoryDataBlock[1];
+            move.InventoryData[0] = new MoveInventoryItemPacket.InventoryDataBlock();
+            move.InventoryData[0].ItemID = itemID;
+            move.InventoryData[0].FolderID = folderID;
+            move.InventoryData[0].NewName = Utils.StringToBytes(newName);
+
+            _Client.Network.SendPacket(move);
+        }
+
+        /// <summary>
+        /// Move multiple inventory items to new locations
+        /// </summary>
+        /// <param name="itemsNewParents">A Dictionary containing the 
+        /// <seealso cref="UUID"/> of the source item as the key, and the 
+        /// <seealso cref="UUID"/> of the destination folder as the value</param>
+        public void MoveItems(Dictionary<UUID, UUID> itemsNewParents)
+        {
+            lock (_Store)
+            {
+                foreach (KeyValuePair<UUID, UUID> entry in itemsNewParents)
+                {
+                    if (_Store.Contains(entry.Key))
+                    {
+                        InventoryBase inv = _Store[entry.Key];
+                        inv.ParentUUID = entry.Value;
+                        _Store.UpdateNodeFor(inv);
+                    }
+                }
+            }
+
+            MoveInventoryItemPacket move = new MoveInventoryItemPacket();
+            move.AgentData.AgentID = _Client.Self.AgentID;
+            move.AgentData.SessionID = _Client.Self.SessionID;
+            move.AgentData.Stamp = false; //FIXME: ??
+
+            move.InventoryData = new MoveInventoryItemPacket.InventoryDataBlock[itemsNewParents.Count];
+
+            int index = 0;
+            foreach (KeyValuePair<UUID, UUID> entry in itemsNewParents)
+            {
+                MoveInventoryItemPacket.InventoryDataBlock block = new MoveInventoryItemPacket.InventoryDataBlock();
+                block.ItemID = entry.Key;
+                block.FolderID = entry.Value;
+                block.NewName = new byte[0];
+                move.InventoryData[index++] = block;
+            }
+
+            _Client.Network.SendPacket(move);
+        }
+
+        #endregion Move
+
+        #region Remove
+
+        /// <summary>
+        /// Remove descendants of a folder
+        /// </summary>
+        /// <param name="folder">The <seealso cref="UUID"/> of the folder</param>
+        public void RemoveDescendants(UUID folder)
+        {
+            PurgeInventoryDescendentsPacket purge = new PurgeInventoryDescendentsPacket();
+            purge.AgentData.AgentID = _Client.Self.AgentID;
+            purge.AgentData.SessionID = _Client.Self.SessionID;
+            purge.InventoryData.FolderID = folder;
+            _Client.Network.SendPacket(purge);
+
+            // Update our local copy
+            lock (_Store)
+            {
+                if (_Store.Contains(folder))
+                {
+                    List<InventoryBase> contents = _Store.GetContents(folder);
+                    foreach (InventoryBase obj in contents)
+                    {
+                        _Store.RemoveNodeFor(obj);
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Remove a single item from inventory
+        /// </summary>
+        /// <param name="item">The <seealso cref="UUID"/> of the inventory item to remove</param>
+        public void RemoveItem(UUID item)
+        {
+            List<UUID> items = new List<UUID>(1);
+            items.Add(item);
+
+            Remove(items, null);
+        }
+
+        /// <summary>
+        /// Remove a folder from inventory
+        /// </summary>
+        /// <param name="folder">The <seealso cref="UUID"/> of the folder to remove</param>
+        public void RemoveFolder(UUID folder)
+        {
+            List<UUID> folders = new List<UUID>(1);
+            folders.Add(folder);
+
+            Remove(null, folders);
+        }
+
+        /// <summary>
+        /// Remove multiple items or folders from inventory
+        /// </summary>
+        /// <param name="items">A List containing the <seealso cref="UUID"/>s of items to remove</param>
+        /// <param name="folders">A List containing the <seealso cref="UUID"/>s of the folders to remove</param>
+        public void Remove(List<UUID> items, List<UUID> folders)
+        {
+            if ((items == null || items.Count == 0) && (folders == null || folders.Count == 0))
+                return;
+
+            RemoveInventoryObjectsPacket rem = new RemoveInventoryObjectsPacket();
+            rem.AgentData.AgentID = _Client.Self.AgentID;
+            rem.AgentData.SessionID = _Client.Self.SessionID;
+
+            if (items == null || items.Count == 0)
+            {
+                // To indicate that we want no items removed:
+                rem.ItemData = new RemoveInventoryObjectsPacket.ItemDataBlock[1];
+                rem.ItemData[0] = new RemoveInventoryObjectsPacket.ItemDataBlock();
+                rem.ItemData[0].ItemID = UUID.Zero;
+            }
+            else
+            {
+                lock (_Store)
+                {
+                    rem.ItemData = new RemoveInventoryObjectsPacket.ItemDataBlock[items.Count];
+                    for (int i = 0; i < items.Count; i++)
+                    {
+                        rem.ItemData[i] = new RemoveInventoryObjectsPacket.ItemDataBlock();
+                        rem.ItemData[i].ItemID = items[i];
+
+                        // Update local copy
+                        if (_Store.Contains(items[i]))
+                            _Store.RemoveNodeFor(Store[items[i]]);
+                    }
+                }
+            }
+
+            if (folders == null || folders.Count == 0)
+            {
+                // To indicate we want no folders removed:
+                rem.FolderData = new RemoveInventoryObjectsPacket.FolderDataBlock[1];
+                rem.FolderData[0] = new RemoveInventoryObjectsPacket.FolderDataBlock();
+                rem.FolderData[0].FolderID = UUID.Zero;
+            }
+            else
+            {
+                lock (_Store)
+                {
+                    rem.FolderData = new RemoveInventoryObjectsPacket.FolderDataBlock[folders.Count];
+                    for (int i = 0; i < folders.Count; i++)
+                    {
+                        rem.FolderData[i] = new RemoveInventoryObjectsPacket.FolderDataBlock();
+                        rem.FolderData[i].FolderID = folders[i];
+
+                        // Update local copy
+                        if (_Store.Contains(folders[i]))
+                            _Store.RemoveNodeFor(Store[folders[i]]);
+                    }
+                }
+            }
+            _Client.Network.SendPacket(rem);
+        }
+    
+        /// <summary>
+        /// Empty the Lost and Found folder
+        /// </summary>
+        public void EmptyLostAndFound()
+        {
+            EmptySystemFolder(AssetType.LostAndFoundFolder);
+        }
+
+        /// <summary>
+        /// Empty the Trash folder
+        /// </summary>
+        public void EmptyTrash()
+        {
+            EmptySystemFolder(AssetType.TrashFolder);
+        }
+
+        private void EmptySystemFolder(AssetType folderType)
+        {
+            List<InventoryBase> items = _Store.GetContents(_Store.RootFolder);
+
+            UUID folderKey = UUID.Zero;
+            foreach (InventoryBase item in items)
+            {
+                if ((item as InventoryFolder) != null)
+                {
+                    InventoryFolder folder = item as InventoryFolder;
+                    if (folder.PreferredType == folderType)
+                    {
+                        folderKey = folder.UUID;
+                        break;
+                    }
+                }
+            }
+            items = _Store.GetContents(folderKey);
+            List<UUID> remItems = new List<UUID>();
+            List<UUID> remFolders = new List<UUID>();
+            foreach (InventoryBase item in items)
+            {
+                if ((item as InventoryFolder) != null)
+                {
+                    remFolders.Add(item.UUID);
+                }
+                else
+                {
+                    remItems.Add(item.UUID);
+                }
+            }
+            Remove(remItems, remFolders);
+        }   
+        #endregion Remove
+
+        #region Create
+        
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="parentFolder"></param>
+        /// <param name="name"></param>
+        /// <param name="description"></param>
+        /// <param name="type"></param>
+        /// <param name="assetTransactionID">Proper use is to upload the inventory's asset first, then provide the Asset's TransactionID here.</param>
+        /// <param name="invType"></param>
+        /// <param name="nextOwnerMask"></param>
+        /// <param name="callback"></param>
+        public void RequestCreateItem(UUID parentFolder, string name, string description, AssetType type, UUID assetTransactionID,
+            InventoryType invType, PermissionMask nextOwnerMask, ItemCreatedCallback callback)
+        {
+            // Even though WearableType 0 is Shape, in this context it is treated as NOT_WEARABLE
+            RequestCreateItem(parentFolder, name, description, type, assetTransactionID, invType, (WearableType)0, nextOwnerMask, 
+                callback);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="parentFolder"></param>
+        /// <param name="name"></param>
+        /// <param name="description"></param>
+        /// <param name="type"></param>
+        /// <param name="assetTransactionID">Proper use is to upload the inventory's asset first, then provide the Asset's TransactionID here.</param>
+        /// <param name="invType"></param>
+        /// <param name="wearableType"></param>
+        /// <param name="nextOwnerMask"></param>
+        /// <param name="callback"></param>
+        public void RequestCreateItem(UUID parentFolder, string name, string description, AssetType type, UUID assetTransactionID,
+            InventoryType invType, WearableType wearableType, PermissionMask nextOwnerMask, ItemCreatedCallback callback)
+        {
+            CreateInventoryItemPacket create = new CreateInventoryItemPacket();
+            create.AgentData.AgentID = _Client.Self.AgentID;
+            create.AgentData.SessionID = _Client.Self.SessionID;
+
+            create.InventoryBlock.CallbackID = RegisterItemCreatedCallback(callback);
+            create.InventoryBlock.FolderID = parentFolder;
+            create.InventoryBlock.TransactionID = assetTransactionID;
+            create.InventoryBlock.NextOwnerMask = (uint)nextOwnerMask;
+            create.InventoryBlock.Type = (sbyte)type;
+            create.InventoryBlock.InvType = (sbyte)invType;
+            create.InventoryBlock.WearableType = (byte)wearableType;
+            create.InventoryBlock.Name = Utils.StringToBytes(name);
+            create.InventoryBlock.Description = Utils.StringToBytes(description);
+
+            _Client.Network.SendPacket(create);
+        }
+
+        /// <summary>
+        /// Creates a new inventory folder
+        /// </summary>
+        /// <param name="parentID">ID of the folder to put this folder in</param>
+        /// <param name="name">Name of the folder to create</param>
+        /// <returns>The UUID of the newly created folder</returns>
+        public UUID CreateFolder(UUID parentID, string name)
+        {
+            return CreateFolder(parentID, name, AssetType.Unknown);
+        }
+
+        /// <summary>
+        /// Creates a new inventory folder
+        /// </summary>
+        /// <param name="parentID">ID of the folder to put this folder in</param>
+        /// <param name="name">Name of the folder to create</param>
+        /// <param name="preferredType">Sets this folder as the default folder
+        /// for new assets of the specified type. Use <code>AssetType.Unknown</code>
+        /// to create a normal folder, otherwise it will likely create a
+        /// duplicate of an existing folder type</param>
+        /// <returns>The UUID of the newly created folder</returns>
+        /// <remarks>If you specify a preferred type of <code>AsseType.Folder</code>
+        /// it will create a new root folder which may likely cause all sorts
+        /// of strange problems</remarks>
+        public UUID CreateFolder(UUID parentID, string name, AssetType preferredType)
+        {
+            UUID id = UUID.Random();
+
+            // Assign a folder name if one is not already set
+            if (String.IsNullOrEmpty(name))
+            {
+                if (preferredType >= AssetType.Texture && preferredType <= AssetType.Gesture)
+                {
+                    name = _NewFolderNames[(int)preferredType];
+                }
+                else
+                {
+                    name = "New Folder";
+                }
+            }
+
+            // Create the new folder locally
+            InventoryFolder newFolder = new InventoryFolder(id);
+            newFolder.Version = 1;
+            newFolder.DescendentCount = 0;
+            newFolder.ParentUUID = parentID;
+            newFolder.PreferredType = preferredType;
+            newFolder.Name = name;
+            newFolder.OwnerID = _Client.Self.AgentID;
+
+            // Update the local store
+            try { _Store[newFolder.UUID] = newFolder; }
+            catch (InventoryException ie) { Logger.Log(ie.Message, Helpers.LogLevel.Warning, _Client, ie); }
+
+            // Create the create folder packet and send it
+            CreateInventoryFolderPacket create = new CreateInventoryFolderPacket();
+            create.AgentData.AgentID = _Client.Self.AgentID;
+            create.AgentData.SessionID = _Client.Self.SessionID;
+
+            create.FolderData.FolderID = id;
+            create.FolderData.ParentID = parentID;
+            create.FolderData.Type = (sbyte)preferredType;
+            create.FolderData.Name = Utils.StringToBytes(name);
+
+            _Client.Network.SendPacket(create);
+
+            return id;
+        }
+
+        public void RequestCreateItemFromAsset(byte[] data, string name, string description, AssetType assetType,
+            InventoryType invType, UUID folderID, CapsClient.ProgressCallback progCallback, ItemCreatedFromAssetCallback callback)
+        {
+            if (_Client.Network.CurrentSim == null || _Client.Network.CurrentSim.Caps == null)
+                throw new Exception("NewFileAgentInventory capability is not currently available");
+
+            Uri url = _Client.Network.CurrentSim.Caps.CapabilityURI("NewFileAgentInventory");
+
+            if (url != null)
+            {
+                OSDMap query = new OSDMap();
+                query.Add("folder_id", OSD.FromUUID(folderID));
+                query.Add("asset_type", OSD.FromString(AssetTypeToString(assetType)));
+                query.Add("inventory_type", OSD.FromString(InventoryTypeToString(invType)));
+                query.Add("name", OSD.FromString(name));
+                query.Add("description", OSD.FromString(description));
+
+                // Make the request
+                CapsClient request = new CapsClient(url);
+                request.OnComplete += new CapsClient.CompleteCallback(CreateItemFromAssetResponse);
+                request.UserData = new object[] { progCallback, callback, data };
+
+                request.StartRequest(query);
+            }
+            else
+            {
+                throw new Exception("NewFileAgentInventory capability is not currently available");
+            }
+        }
+
+        #endregion Create
+
+        #region Copy
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="item"></param>
+        /// <param name="newParent"></param>
+        /// <param name="newName"></param>
+        /// <param name="callback"></param>
+        public void RequestCopyItem(UUID item, UUID newParent, string newName, ItemCopiedCallback callback)
+        {
+            RequestCopyItem(item, newParent, newName, _Client.Self.AgentID, callback);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="item"></param>
+        /// <param name="newParent"></param>
+        /// <param name="newName"></param>
+        /// <param name="oldOwnerID"></param>
+        /// <param name="callback"></param>
+        public void RequestCopyItem(UUID item, UUID newParent, string newName, UUID oldOwnerID,
+            ItemCopiedCallback callback)
+        {
+            List<UUID> items = new List<UUID>(1);
+            items.Add(item);
+
+            List<UUID> folders = new List<UUID>(1);
+            folders.Add(newParent);
+
+            List<string> names = new List<string>(1);
+            names.Add(newName);
+
+            RequestCopyItems(items, folders, names, oldOwnerID, callback);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="items"></param>
+        /// <param name="targetFolders"></param>
+        /// <param name="newNames"></param>
+        /// <param name="oldOwnerID"></param>
+        /// <param name="callback"></param>
+        public void RequestCopyItems(List<UUID> items, List<UUID> targetFolders, List<string> newNames,
+            UUID oldOwnerID, ItemCopiedCallback callback)
+        {
+            if (items.Count != targetFolders.Count || (newNames != null && items.Count != newNames.Count))
+                throw new ArgumentException("All list arguments must have an equal number of entries");
+
+            uint callbackID = RegisterItemsCopiedCallback(callback);
+
+            CopyInventoryItemPacket copy = new CopyInventoryItemPacket();
+            copy.AgentData.AgentID = _Client.Self.AgentID;
+            copy.AgentData.SessionID = _Client.Self.SessionID;
+
+            copy.InventoryData = new CopyInventoryItemPacket.InventoryDataBlock[items.Count];
+            for (int i = 0; i < items.Count; ++i)
+            {
+                copy.InventoryData[i] = new CopyInventoryItemPacket.InventoryDataBlock();
+                copy.InventoryData[i].CallbackID = callbackID;
+                copy.InventoryData[i].NewFolderID = targetFolders[i];
+                copy.InventoryData[i].OldAgentID = oldOwnerID;
+                copy.InventoryData[i].OldItemID = items[i];
+
+                if (newNames != null && !String.IsNullOrEmpty(newNames[i]))
+                    copy.InventoryData[i].NewName = Utils.StringToBytes(newNames[i]);
+                else
+                    copy.InventoryData[i].NewName = new byte[0];
+            }
+
+            _Client.Network.SendPacket(copy);
+        }
+
+        /// <summary>
+        /// Request a copy of an asset embedded within a notecard
+        /// </summary>
+        /// <param name="objectID">Usually UUID.Zero for copying an asset from a notecard</param>
+        /// <param name="notecardID">UUID of the notecard to request an asset from</param>
+        /// <param name="folderID">Target folder for asset to go to in your inventory</param>
+        /// <param name="itemID">UUID of the embedded asset</param>
+        /// <param name="callback">callback to run when item is copied to inventory</param>
+        public void RequestCopyItemFromNotecard(UUID objectID, UUID notecardID, UUID folderID, UUID itemID, ItemCopiedCallback callback)
+        {
+            CopyInventoryFromNotecardPacket copy = new CopyInventoryFromNotecardPacket();
+            copy.AgentData.AgentID = _Client.Self.AgentID;
+            copy.AgentData.SessionID = _Client.Self.SessionID;
+
+            copy.NotecardData.ObjectID = objectID;
+            copy.NotecardData.NotecardItemID = notecardID;
+
+            copy.InventoryData = new CopyInventoryFromNotecardPacket.InventoryDataBlock[1];
+            copy.InventoryData[0] = new CopyInventoryFromNotecardPacket.InventoryDataBlock();
+            copy.InventoryData[0].FolderID = folderID;
+            copy.InventoryData[0].ItemID = itemID;
+           
+            _ItemCopiedCallbacks[0] = callback; //Notecards always use callback ID 0
+
+            _Client.Network.SendPacket(copy);
+        }
+
+        #endregion Copy
+
+        #region Update
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="item"></param>
+        public void RequestUpdateItem(InventoryItem item)
+        {
+            List<InventoryItem> items = new List<InventoryItem>(1);
+            items.Add(item);
+
+            RequestUpdateItems(items, UUID.Random());
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="items"></param>
+        public void RequestUpdateItems(List<InventoryItem> items)
+        {
+            RequestUpdateItems(items, UUID.Random());
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="items"></param>
+        /// <param name="transactionID"></param>
+        public void RequestUpdateItems(List<InventoryItem> items, UUID transactionID)
+        {
+            UpdateInventoryItemPacket update = new UpdateInventoryItemPacket();
+            update.AgentData.AgentID = _Client.Self.AgentID;
+            update.AgentData.SessionID = _Client.Self.SessionID;
+            update.AgentData.TransactionID = transactionID;
+
+            update.InventoryData = new UpdateInventoryItemPacket.InventoryDataBlock[items.Count];
+            for (int i = 0; i < items.Count; i++)
+            {
+                InventoryItem item = items[i];
+
+                UpdateInventoryItemPacket.InventoryDataBlock block = new UpdateInventoryItemPacket.InventoryDataBlock();
+                block.BaseMask = (uint)item.Permissions.BaseMask;
+                block.CRC = ItemCRC(item);
+                block.CreationDate = (int)Utils.DateTimeToUnixTime(item.CreationDate);
+                block.CreatorID = item.CreatorID;
+                block.Description = Utils.StringToBytes(item.Description);
+                block.EveryoneMask = (uint)item.Permissions.EveryoneMask;
+                block.Flags = (uint)item.Flags;
+                block.FolderID = item.ParentUUID;
+                block.GroupID = item.GroupID;
+                block.GroupMask = (uint)item.Permissions.GroupMask;
+                block.GroupOwned = item.GroupOwned;
+                block.InvType = (sbyte)item.InventoryType;
+                block.ItemID = item.UUID;
+                block.Name = Utils.StringToBytes(item.Name);
+                block.NextOwnerMask = (uint)item.Permissions.NextOwnerMask;
+                block.OwnerID = item.OwnerID;
+                block.OwnerMask = (uint)item.Permissions.OwnerMask;
+                block.SalePrice = item.SalePrice;
+                block.SaleType = (byte)item.SaleType;
+                block.TransactionID = UUID.Zero;
+                block.Type = (sbyte)item.AssetType;
+
+                update.InventoryData[i] = block;
+            }
+
+            _Client.Network.SendPacket(update);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="data"></param>
+        /// <param name="notecardID"></param>
+        /// <param name="callback"></param>
+        public void RequestUploadNotecardAsset(byte[] data, UUID notecardID, NotecardUploadedAssetCallback callback)
+        {
+            if (_Client.Network.CurrentSim == null || _Client.Network.CurrentSim.Caps == null)
+                throw new Exception("UpdateNotecardAgentInventory capability is not currently available");
+
+            Uri url = _Client.Network.CurrentSim.Caps.CapabilityURI("UpdateNotecardAgentInventory");
+
+            if (url != null)
+            {
+                OSDMap query = new OSDMap();
+                query.Add("item_id", OSD.FromUUID(notecardID));
+
+                byte[] postData = StructuredData.OSDParser.SerializeLLSDXmlBytes(query);
+
+                // Make the request
+                CapsClient request = new CapsClient(url);
+                request.OnComplete += new CapsClient.CompleteCallback(UploadNotecardAssetResponse);
+                request.UserData = new object[2] { new KeyValuePair<NotecardUploadedAssetCallback, byte[]>(callback, data), notecardID };
+                request.StartRequest(postData);
+            }
+            else
+            {
+                throw new Exception("UpdateNotecardAgentInventory capability is not currently available");
+            }
+        }
+        #endregion Update
+
+        #region Rez/Give
+
+        /// <summary>
+        /// Rez an object from inventory
+        /// </summary>
+        /// <param name="simulator">Simulator to place object in</param>
+        /// <param name="rotation">Rotation of the object when rezzed</param>
+        /// <param name="position">Vector of where to place object</param>
+        /// <param name="item">InventoryItem object containing item details</param>
+        public UUID RequestRezFromInventory(Simulator simulator, Quaternion rotation, Vector3 position,
+            InventoryItem item)
+        {
+            return RequestRezFromInventory(simulator, rotation, position, item, _Client.Self.ActiveGroup,
+                UUID.Random(), false);
+        }
+
+        /// <summary>
+        /// Rez an object from inventory
+        /// </summary>
+        /// <param name="simulator">Simulator to place object in</param>
+        /// <param name="rotation">Rotation of the object when rezzed</param>
+        /// <param name="position">Vector of where to place object</param>
+        /// <param name="item">InventoryItem object containing item details</param>
+        /// <param name="groupOwner">UUID of group to own the object</param>
+        public UUID RequestRezFromInventory(Simulator simulator, Quaternion rotation, Vector3 position,
+            InventoryItem item, UUID groupOwner)
+        {
+            return RequestRezFromInventory(simulator, rotation, position, item, groupOwner, UUID.Random(), false);
+        }
+
+        /// <summary>
+        /// Rez an object from inventory
+        /// </summary>
+        /// <param name="simulator">Simulator to place object in</param>
+        /// <param name="rotation">Rotation of the object when rezzed</param>
+        /// <param name="position">Vector of where to place object</param>
+        /// <param name="item">InventoryItem object containing item details</param>
+        /// <param name="groupOwner">UUID of group to own the object</param>        
+        /// <param name="queryID">User defined queryID to correlate replies</param>
+        /// <param name="requestObjectDetails">if set to true the simulator
+        /// will automatically send object detail packet(s) back to the client</param>
+        public UUID RequestRezFromInventory(Simulator simulator, Quaternion rotation, Vector3 position,
+            InventoryItem item, UUID groupOwner, UUID queryID, bool requestObjectDetails)
+        {
+            RezObjectPacket add = new RezObjectPacket();
+
+            add.AgentData.AgentID = _Client.Self.AgentID;
+            add.AgentData.SessionID = _Client.Self.SessionID;
+            add.AgentData.GroupID = groupOwner;
+
+            add.RezData.FromTaskID = UUID.Zero;
+            add.RezData.BypassRaycast = 1;
+            add.RezData.RayStart = position;
+            add.RezData.RayEnd = position;
+            add.RezData.RayTargetID = UUID.Zero;
+            add.RezData.RayEndIsIntersection = false;
+            add.RezData.RezSelected = requestObjectDetails;
+            add.RezData.RemoveItem = false;
+            add.RezData.ItemFlags = (uint)item.Flags;
+            add.RezData.GroupMask = (uint)item.Permissions.GroupMask;
+            add.RezData.EveryoneMask = (uint)item.Permissions.EveryoneMask;
+            add.RezData.NextOwnerMask = (uint)item.Permissions.NextOwnerMask;
+
+            add.InventoryData.ItemID = item.UUID;
+            add.InventoryData.FolderID = item.ParentUUID;
+            add.InventoryData.CreatorID = item.CreatorID;
+            add.InventoryData.OwnerID = item.OwnerID;
+            add.InventoryData.GroupID = item.GroupID;
+            add.InventoryData.BaseMask = (uint)item.Permissions.BaseMask;
+            add.InventoryData.OwnerMask = (uint)item.Permissions.OwnerMask;
+            add.InventoryData.GroupMask = (uint)item.Permissions.GroupMask;
+            add.InventoryData.EveryoneMask = (uint)item.Permissions.EveryoneMask;
+            add.InventoryData.NextOwnerMask = (uint)item.Permissions.NextOwnerMask;
+            add.InventoryData.GroupOwned = item.GroupOwned;
+            add.InventoryData.TransactionID = queryID;
+            add.InventoryData.Type = (sbyte)item.InventoryType;
+            add.InventoryData.InvType = (sbyte)item.InventoryType;
+            add.InventoryData.Flags = (uint)item.Flags;
+            add.InventoryData.SaleType = (byte)item.SaleType;
+            add.InventoryData.SalePrice = item.SalePrice;
+            add.InventoryData.Name = Utils.StringToBytes(item.Name);
+            add.InventoryData.Description = Utils.StringToBytes(item.Description);
+            add.InventoryData.CreationDate = (int)Utils.DateTimeToUnixTime(item.CreationDate);
+
+            _Client.Network.SendPacket(add, simulator);
+
+            return queryID;
+        }
+
+        /// <summary>
+        /// DeRez an object from the simulator to the agents Objects folder in the agents Inventory
+        /// </summary>
+        /// <param name="objectLocalID">The simulator Local ID of the object</param>
+        public void RequestDeRezToInventory(uint objectLocalID)
+        {
+            RequestDeRezToInventory(objectLocalID, DeRezDestination.AgentInventoryTake, 
+                _Client.Inventory.FindFolderForType(AssetType.Object), UUID.Random());
+        }
+
+        /// <summary>
+        /// DeRez an object from the simulator and return to inventory
+        /// </summary>
+        /// <param name="objectLocalID">The simulator Local ID of the object</param>
+        /// <param name="destType">The type of destination from the <seealso cref="DeRezDestination"/> enum</param>
+        /// <param name="destFolder">The destination inventory folders <seealso cref="UUID"/> -or- 
+        /// if DeRezzing object to a tasks Inventory, the Tasks <seealso cref="UUID"/></param>
+        /// <param name="transactionID">The transaction ID for this request which
+        /// can be used to correlate this request with other packets</param>
+        public void RequestDeRezToInventory(uint objectLocalID, DeRezDestination destType, UUID destFolder, UUID transactionID)
+        {
+            DeRezObjectPacket take = new DeRezObjectPacket();
+
+            take.AgentData.AgentID = _Client.Self.AgentID;
+            take.AgentData.SessionID = _Client.Self.SessionID;
+            take.AgentBlock = new DeRezObjectPacket.AgentBlockBlock();
+            take.AgentBlock.GroupID = UUID.Zero;
+            take.AgentBlock.Destination = (byte)destType;
+            take.AgentBlock.DestinationID = destFolder;
+            take.AgentBlock.PacketCount = 1;
+            take.AgentBlock.PacketNumber = 1;
+            take.AgentBlock.TransactionID = transactionID;
+
+            take.ObjectData = new DeRezObjectPacket.ObjectDataBlock[1];
+            take.ObjectData[0] = new DeRezObjectPacket.ObjectDataBlock();
+            take.ObjectData[0].ObjectLocalID = objectLocalID;
+            
+            _Client.Network.SendPacket(take);
+        }
+
+
+        /// <summary>
+        /// Give an inventory item to another avatar
+        /// </summary>
+        /// <param name="itemID">The <seealso cref="UUID"/> of the item to give</param>
+        /// <param name="itemName">The name of the item</param>
+        /// <param name="assetType">The type of the item from the <seealso cref="AssetType"/> enum</param>
+        /// <param name="recipient">The <seealso cref="UUID"/> of the recipient</param>
+        /// <param name="doEffect">true to generate a beameffect during transfer</param>
+        public void GiveItem(UUID itemID, string itemName, AssetType assetType, UUID recipient,
+            bool doEffect)
+        {
+            byte[] bucket;
+
+
+                bucket = new byte[17];
+                bucket[0] = (byte)assetType;
+                Buffer.BlockCopy(itemID.GetBytes(), 0, bucket, 1, 16);
+
+            _Client.Self.InstantMessage(
+                    _Client.Self.Name,
+                    recipient,
+                    itemName,
+                    UUID.Random(),
+                    InstantMessageDialog.InventoryOffered,
+                    InstantMessageOnline.Online,
+                    _Client.Self.SimPosition,
+                    _Client.Network.CurrentSim.ID,
+                    bucket);
+
+            if (doEffect)
+            {
+                _Client.Self.BeamEffect(_Client.Self.AgentID, recipient, Vector3d.Zero,
+                    _Client.Settings.DEFAULT_EFFECT_COLOR, 1f, UUID.Random());
+            }
+        }
+
+        /// <summary>
+        /// Give an inventory Folder with contents to another avatar
+        /// </summary>
+        /// <param name="folderID">The <seealso cref="UUID"/> of the Folder to give</param>
+        /// <param name="folderName">The name of the folder</param>
+        /// <param name="assetType">The type of the item from the <seealso cref="AssetType"/> enum</param>
+        /// <param name="recipient">The <seealso cref="UUID"/> of the recipient</param>
+        /// <param name="doEffect">true to generate a beameffect during transfer</param>
+        public void GiveFolder(UUID folderID, string folderName, AssetType assetType, UUID recipient,
+            bool doEffect)
+        {
+            byte[] bucket;
+
+                List<InventoryItem> folderContents = new List<InventoryItem>();
+
+                _Client.Inventory.FolderContents(folderID, _Client.Self.AgentID, false, true, InventorySortOrder.ByDate, 1000 * 15).ForEach(
+                    delegate(InventoryBase ib)
+                    {
+                        folderContents.Add(_Client.Inventory.FetchItem(ib.UUID, _Client.Self.AgentID, 1000 * 10));
+                    });
+                bucket = new byte[17 * (folderContents.Count + 1)];
+
+                //Add parent folder (first item in bucket)
+                bucket[0] = (byte)assetType;
+                Buffer.BlockCopy(folderID.GetBytes(), 0, bucket, 1, 16);
+
+                //Add contents to bucket after folder
+                for (int i = 1; i <= folderContents.Count; ++i)
+                {
+                    bucket[i * 17] = (byte)folderContents[i - 1].AssetType;
+                    Buffer.BlockCopy(folderContents[i - 1].UUID.GetBytes(), 0, bucket, i * 17 + 1, 16);
+                }
+
+            _Client.Self.InstantMessage(
+                    _Client.Self.Name,
+                    recipient,
+                    folderName,
+                    UUID.Random(),
+                    InstantMessageDialog.InventoryOffered,
+                    InstantMessageOnline.Online,
+                    _Client.Self.SimPosition,
+                    _Client.Network.CurrentSim.ID,
+                    bucket);
+
+            if (doEffect)
+            {
+                _Client.Self.BeamEffect(_Client.Self.AgentID, recipient, Vector3d.Zero,
+                    _Client.Settings.DEFAULT_EFFECT_COLOR, 1f, UUID.Random());
+            }
+        }
+
+        #endregion Rez/Give
+
+        #region Task
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="objectLocalID"></param>
+        /// <param name="item"></param>
+        /// <returns></returns>
+        public UUID UpdateTaskInventory(uint objectLocalID, InventoryItem item)
+        {
+            UUID transactionID = UUID.Random();
+
+            UpdateTaskInventoryPacket update = new UpdateTaskInventoryPacket();
+            update.AgentData.AgentID = _Client.Self.AgentID;
+            update.AgentData.SessionID = _Client.Self.SessionID;
+            update.UpdateData.Key = 0;
+            update.UpdateData.LocalID = objectLocalID;
+
+            update.InventoryData.ItemID = item.UUID;
+            update.InventoryData.FolderID = item.ParentUUID;
+            update.InventoryData.CreatorID = item.CreatorID;
+            update.InventoryData.OwnerID = item.OwnerID;
+            update.InventoryData.GroupID = item.GroupID;
+            update.InventoryData.BaseMask = (uint)item.Permissions.BaseMask;
+            update.InventoryData.OwnerMask = (uint)item.Permissions.OwnerMask;
+            update.InventoryData.GroupMask = (uint)item.Permissions.GroupMask;
+            update.InventoryData.EveryoneMask = (uint)item.Permissions.EveryoneMask;
+            update.InventoryData.NextOwnerMask = (uint)item.Permissions.NextOwnerMask;
+            update.InventoryData.GroupOwned = item.GroupOwned;
+            update.InventoryData.TransactionID = transactionID;
+            update.InventoryData.Type = (sbyte)item.AssetType;
+            update.InventoryData.InvType = (sbyte)item.InventoryType;
+            update.InventoryData.Flags = (uint)item.Flags;
+            update.InventoryData.SaleType = (byte)item.SaleType;
+            update.InventoryData.SalePrice = item.SalePrice;
+            update.InventoryData.Name = Utils.StringToBytes(item.Name);
+            update.InventoryData.Description = Utils.StringToBytes(item.Description);
+            update.InventoryData.CreationDate = (int)Utils.DateTimeToUnixTime(item.CreationDate);
+            update.InventoryData.CRC = ItemCRC(item);
+
+            _Client.Network.SendPacket(update);
+
+            return transactionID;
+        }
+
+        /// <summary>
+        /// Get the inventory of a Task (Primitive)
+        /// </summary>
+        /// <param name="objectID">The tasks <seealso cref="UUID"/></param>
+        /// <param name="objectLocalID">The tasks simulator local ID</param>
+        /// <param name="timeoutMS">milliseconds to wait for reply from simulator</param>
+        /// <returns>A List containing the inventory items inside the task</returns>
+        public List<InventoryBase> GetTaskInventory(UUID objectID, uint objectLocalID, int timeoutMS)
+        {
+            string filename = null;
+            AutoResetEvent taskReplyEvent = new AutoResetEvent(false);
+
+            TaskInventoryReplyCallback callback =
+                delegate(UUID itemID, short serial, string assetFilename)
+                {
+                    if (itemID == objectID)
+                    {
+                        filename = assetFilename;
+                        taskReplyEvent.Set();
+                    }
+                };
+
+            OnTaskInventoryReply += callback;
+
+            RequestTaskInventory(objectLocalID);
+
+            if (taskReplyEvent.WaitOne(timeoutMS, false))
+            {
+                OnTaskInventoryReply -= callback;
+
+                if (!String.IsNullOrEmpty(filename))
+                {
+                    byte[] assetData = null;
+                    ulong xferID = 0;
+                    AutoResetEvent taskDownloadEvent = new AutoResetEvent(false);
+
+                    AssetManager.XferReceivedCallback xferCallback =
+                        delegate(XferDownload xfer)
+                        {
+                            if (xfer.XferID == xferID)
+                            {
+                                assetData = xfer.AssetData;
+                                taskDownloadEvent.Set();
+                            }
+                        };
+
+                    _Client.Assets.OnXferReceived += xferCallback;
+
+                    // Start the actual asset xfer
+                    xferID = _Client.Assets.RequestAssetXfer(filename, true, false, UUID.Zero, AssetType.Unknown, true);
+
+                    if (taskDownloadEvent.WaitOne(timeoutMS, false))
+                    {
+                        _Client.Assets.OnXferReceived -= xferCallback;
+
+                        string taskList = Utils.BytesToString(assetData);
+                        return ParseTaskInventory(taskList);
+                    }
+                    else
+                    {
+                        Logger.Log("Timed out waiting for task inventory download for " + filename, Helpers.LogLevel.Warning, _Client);
+                        _Client.Assets.OnXferReceived -= xferCallback;
+                        return null;
+                    }
+                }
+                else
+                {
+                    Logger.DebugLog("Task is empty for " + objectLocalID, _Client);
+                    return null;
+                }
+            }
+            else
+            {
+                Logger.Log("Timed out waiting for task inventory reply for " + objectLocalID, Helpers.LogLevel.Warning, _Client);
+                OnTaskInventoryReply -= callback;
+                return null;
+            }
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="objectLocalID"></param>
+        public void RequestTaskInventory(uint objectLocalID)
+        {
+            RequestTaskInventory(objectLocalID, _Client.Network.CurrentSim);
+        }
+
+        /// <summary>
+        /// Request the contents of a tasks (primitives) inventory
+        /// </summary>
+        /// <param name="objectLocalID">The simulator Local ID of the object</param>
+        /// <param name="simulator">A reference to the simulator object that contains the object</param>
+        public void RequestTaskInventory(uint objectLocalID, Simulator simulator)
+        {
+            RequestTaskInventoryPacket request = new RequestTaskInventoryPacket();
+            request.AgentData.AgentID = _Client.Self.AgentID;
+            request.AgentData.SessionID = _Client.Self.SessionID;
+            request.InventoryData.LocalID = objectLocalID;
+
+            _Client.Network.SendPacket(request, simulator);
+        }
+        
+        /// <summary>
+        /// Moves an Item from an objects (Prim) Inventory to the specified folder in the avatars inventory
+        /// </summary>
+        /// <param name="objectLocalID">LocalID of the object in the simulator</param>
+        /// <param name="taskItemID">UUID of the task item to move</param>
+        /// <param name="inventoryFolderID">UUID of the folder to move the item to</param>
+        /// <param name="simulator">Simulator Object</param>
+        public void MoveTaskInventory(uint objectLocalID, UUID taskItemID, UUID inventoryFolderID, Simulator simulator)
+        {
+            MoveTaskInventoryPacket request = new MoveTaskInventoryPacket();
+            request.AgentData.AgentID = _Client.Self.AgentID;
+            request.AgentData.SessionID = _Client.Self.SessionID;
+
+            request.AgentData.FolderID = inventoryFolderID;
+
+            request.InventoryData.ItemID = taskItemID;
+            request.InventoryData.LocalID = objectLocalID;
+
+            _Client.Network.SendPacket(request, simulator);
+        }
+        
+        /// <summary>
+        /// Remove an item from an objects (Prim) Inventory
+        /// </summary>
+        /// <param name="objectLocalID">LocalID of the object in the simulator</param>
+        /// <param name="taskItemID">UUID of the task item to remove</param>
+        /// <param name="simulator">Simulator Object</param>
+        public void RemoveTaskInventory(uint objectLocalID, UUID taskItemID, Simulator simulator)
+        {
+            RemoveTaskInventoryPacket remove = new RemoveTaskInventoryPacket();
+            remove.AgentData.AgentID = _Client.Self.AgentID;
+            remove.AgentData.SessionID = _Client.Self.SessionID;
+
+            remove.InventoryData.ItemID = taskItemID;
+            remove.InventoryData.LocalID = objectLocalID;
+
+            _Client.Network.SendPacket(remove, simulator);
+        }
+
+        #endregion Task
+
+        #region Helper Functions
+
+        /// <summary>
+        /// Takes an AssetType and returns the string representation
+        /// </summary>
+        /// <param name="type">The source <seealso cref="AssetType"/></param>
+        /// <returns>The string version of the AssetType</returns>
+        public static string AssetTypeToString(AssetType type)
+        {
+            return _AssetTypeNames[(int)type];
+        }
+
+        /// <summary>
+        /// Translate a string name of an AssetType into the proper Type
+        /// </summary>
+        /// <param name="type">A string containing the AssetType name</param>
+        /// <returns>The AssetType which matches the string name, or AssetType.Unknown if no match was found</returns>
+        public static AssetType StringToAssetType(string type)
+        {
+            for (int i = 0; i < _AssetTypeNames.Length; i++)
+            {
+                if (_AssetTypeNames[i] == type)
+                    return (AssetType)i;
+            }
+
+            return AssetType.Unknown;
+        }
+
+        /// <summary>
+        /// Convert an InventoryType to a string
+        /// </summary>
+        /// <param name="type">The <seealso cref="T:InventoryType"/> to convert</param>
+        /// <returns>A string representation of the source </returns>
+        public static string InventoryTypeToString(InventoryType type)
+        {
+            return _InventoryTypeNames[(int)type];
+        }
+
+        /// <summary>
+        /// Convert a string into a valid InventoryType
+        /// </summary>
+        /// <param name="type">A string representation of the InventoryType to convert</param>
+        /// <returns>A InventoryType object which matched the type</returns>
+        public static InventoryType StringToInventoryType(string type)
+        {
+            for (int i = 0; i < _InventoryTypeNames.Length; i++)
+            {
+                if (_InventoryTypeNames[i] == type)
+                    return (InventoryType)i;
+            }
+
+            return InventoryType.Unknown;
+        }
+
+        public static string SaleTypeToString(SaleType type)
+        {
+            return _SaleTypeNames[(int)type];
+        }
+
+        public static SaleType StringToSaleType(string value)
+        {
+            for (int i = 0; i < _SaleTypeNames.Length; i++)
+            {
+                if (value == _SaleTypeNames[i])
+                    return (SaleType)i;
+            }
+
+            return SaleType.Not;
+        }
+
+        private uint RegisterItemCreatedCallback(ItemCreatedCallback callback)
+        {
+            lock (_CallbacksLock)
+            {
+                if (_CallbackPos == UInt32.MaxValue)
+                    _CallbackPos = 0;
+
+                _CallbackPos++;
+
+                if (_ItemCreatedCallbacks.ContainsKey(_CallbackPos))
+                    Logger.Log("Overwriting an existing ItemCreatedCallback", Helpers.LogLevel.Warning, _Client);
+
+                _ItemCreatedCallbacks[_CallbackPos] = callback;
+
+                return _CallbackPos;
+            }
+        }
+
+        private uint RegisterItemsCopiedCallback(ItemCopiedCallback callback)
+        {
+            lock (_CallbacksLock)
+            {
+                if (_CallbackPos == UInt32.MaxValue)
+                    _CallbackPos = 0;
+
+                _CallbackPos++;
+
+                if (_ItemCopiedCallbacks.ContainsKey(_CallbackPos))
+                    Logger.Log("Overwriting an existing ItemsCopiedCallback", Helpers.LogLevel.Warning, _Client);
+
+                _ItemCopiedCallbacks[_CallbackPos] = callback;
+
+                return _CallbackPos;
+            }
+        }
+
+        /// <summary>
+        /// Create a CRC from an InventoryItem
+        /// </summary>
+        /// <param name="iitem">The source InventoryItem</param>
+        /// <returns>A uint representing the source InventoryItem as a CRC</returns>
+        public static uint ItemCRC(InventoryItem iitem)
+        {
+            uint CRC = 0;
+
+            // IDs
+            CRC += iitem.AssetUUID.CRC(); // AssetID
+            CRC += iitem.ParentUUID.CRC(); // FolderID
+            CRC += iitem.UUID.CRC(); // ItemID
+
+            // Permission stuff
+            CRC += iitem.CreatorID.CRC(); // CreatorID
+            CRC += iitem.OwnerID.CRC(); // OwnerID
+            CRC += iitem.GroupID.CRC(); // GroupID
+
+            // CRC += another 4 words which always seem to be zero -- unclear if this is a UUID or what
+            CRC += (uint)iitem.Permissions.OwnerMask; //owner_mask;      // Either owner_mask or next_owner_mask may need to be
+            CRC += (uint)iitem.Permissions.NextOwnerMask; //next_owner_mask; // switched with base_mask -- 2 values go here and in my
+            CRC += (uint)iitem.Permissions.EveryoneMask; //everyone_mask;   // study item, the three were identical.
+            CRC += (uint)iitem.Permissions.GroupMask; //group_mask;
+
+            // The rest of the CRC fields
+            CRC += (uint)iitem.Flags; // Flags
+            CRC += (uint)iitem.InventoryType; // InvType
+            CRC += (uint)iitem.AssetType; // Type 
+            CRC += (uint)Utils.DateTimeToUnixTime(iitem.CreationDate); // CreationDate
+            CRC += (uint)iitem.SalePrice;    // SalePrice
+            CRC += (uint)((uint)iitem.SaleType * 0x07073096); // SaleType
+
+            return CRC;
+        }
+
+        /// <summary>
+        /// Wrapper for creating a new <seealso cref="InventoryItem"/> object
+        /// </summary>
+        /// <param name="type">The type of item from the <seealso cref="InventoryType"/> enum</param>
+        /// <param name="id">The <seealso cref="UUID"/> of the newly created object</param>
+        /// <returns>An <seealso cref="InventoryItem"/> object with the type and id passed</returns>
+        public static InventoryItem CreateInventoryItem(InventoryType type, UUID id)
+        {
+            switch (type)
+            {
+                case InventoryType.Texture: return new InventoryTexture(id);
+                case InventoryType.Sound: return new InventorySound(id);
+                case InventoryType.CallingCard: return new InventoryCallingCard(id);
+                case InventoryType.Landmark: return new InventoryLandmark(id);
+                case InventoryType.Object: return new InventoryObject(id);
+                case InventoryType.Notecard: return new InventoryNotecard(id);
+                case InventoryType.Category: return new InventoryCategory(id);
+                case InventoryType.LSL: return new InventoryLSL(id);
+                case InventoryType.Snapshot: return new InventorySnapshot(id);
+                case InventoryType.Attachment: return new InventoryAttachment(id);
+                case InventoryType.Wearable: return new InventoryWearable(id);
+                case InventoryType.Animation: return new InventoryAnimation(id);
+                case InventoryType.Gesture: return new InventoryGesture(id);
+                default: return new InventoryItem(type, id);
+            }
+        }
+
+        private InventoryItem SafeCreateInventoryItem(InventoryType InvType, UUID ItemID)
+        {
+            InventoryItem ret = null;
+
+            if (_Store.Contains(ItemID))
+                ret = _Store[ItemID] as InventoryItem;
+
+            if (ret == null)
+                ret = CreateInventoryItem(InvType, ItemID);
+
+            return ret;
+        }
+
+        private static bool ParseLine(string line, out string key, out string value)
+        {
+            // Clean up and convert tabs to spaces
+            line = line.Trim();
+            line = line.Replace('\t', ' ');
+
+            // Shrink all whitespace down to single spaces
+            while (line.IndexOf("  ") > 0)
+                line = line.Replace("  ", " ");
+
+            if (line.Length > 2)
+            {
+                int sep = line.IndexOf(' ');
+                if (sep > 0)
+                {
+                    key = line.Substring(0, sep);
+                    value = line.Substring(sep + 1);
+
+                    return true;
+                }
+            }
+            else if (line.Length == 1)
+            {
+                key = line;
+                value = String.Empty;
+                return true;
+            }
+
+            key = null;
+            value = null;
+            return false;
+        }
+
+        /// <summary>
+        /// Parse the results of a RequestTaskInventory() response
+        /// </summary>
+        /// <param name="taskData">A string which contains the data from the task reply</param>
+        /// <returns>A List containing the items contained within the tasks inventory</returns>
+        public static List<InventoryBase> ParseTaskInventory(string taskData)
+        {
+            List<InventoryBase> items = new List<InventoryBase>();
+            int lineNum = 0;
+            string[] lines = taskData.Replace("\r\n", "\n").Split('\n');
+
+            while (lineNum < lines.Length)
+            {
+                string key, value;
+                if (ParseLine(lines[lineNum++], out key, out value))
+                {
+                    if (key == "inv_object")
+                    {
+                        #region inv_object
+
+                        // In practice this appears to only be used for folders
+                        UUID itemID = UUID.Zero;
+                        UUID parentID = UUID.Zero;
+                        string name = String.Empty;
+                        AssetType assetType = AssetType.Unknown;
+
+                        while (lineNum < lines.Length)
+                        {
+                            if (ParseLine(lines[lineNum++], out key, out value))
+                            {
+                                if (key == "{")
+                                {
+                                    continue;
+                                }
+                                else if (key == "}")
+                                {
+                                    break;
+                                }
+                                else if (key == "obj_id")
+                                {
+                                    UUID.TryParse(value, out itemID);
+                                }
+                                else if (key == "parent_id")
+                                {
+                                    UUID.TryParse(value, out parentID);
+                                }
+                                else if (key == "type")
+                                {
+                                    assetType = StringToAssetType(value);
+                                }
+                                else if (key == "name")
+                                {
+                                    name = value.Substring(0, value.IndexOf('|'));
+                                }
+                            }
+                        }
+
+                        if (assetType == AssetType.Folder)
+                        {
+                            InventoryFolder folder = new InventoryFolder(itemID);
+                            folder.Name = name;
+                            folder.ParentUUID = parentID;
+
+                            items.Add(folder);
+                        }
+                        else
+                        {
+                            InventoryItem item = new InventoryItem(itemID);
+                            item.Name = name;
+                            item.ParentUUID = parentID;
+                            item.AssetType = assetType;
+
+                            items.Add(item);
+                        }
+
+                        #endregion inv_object
+                    }
+                    else if (key == "inv_item")
+                    {
+                        #region inv_item
+
+                        // Any inventory item that links to an assetID, has permissions, etc
+                        UUID itemID = UUID.Zero;
+                        UUID assetID = UUID.Zero;
+                        UUID parentID = UUID.Zero;
+                        UUID creatorID = UUID.Zero;
+                        UUID ownerID = UUID.Zero;
+                        UUID lastOwnerID = UUID.Zero;
+                        UUID groupID = UUID.Zero;
+                        bool groupOwned = false;
+                        string name = String.Empty;
+                        string desc = String.Empty;
+                        AssetType assetType = AssetType.Unknown;
+                        InventoryType inventoryType = InventoryType.Unknown;
+                        DateTime creationDate = Utils.Epoch;
+                        uint flags = 0;
+                        Permissions perms = Permissions.NoPermissions;
+                        SaleType saleType = SaleType.Not;
+                        int salePrice = 0;
+
+                        while (lineNum < lines.Length)
+                        {
+                            if (ParseLine(lines[lineNum++], out key, out value))
+                            {
+                                if (key == "{")
+                                {
+                                    continue;
+                                }
+                                else if (key == "}")
+                                {
+                                    break;
+                                }
+                                else if (key == "item_id")
+                                {
+                                    UUID.TryParse(value, out itemID);
+                                }
+                                else if (key == "parent_id")
+                                {
+                                    UUID.TryParse(value, out parentID);
+                                }
+                                else if (key == "permissions")
+                                {
+                                    #region permissions
+
+                                    while (lineNum < lines.Length)
+                                    {
+                                        if (ParseLine(lines[lineNum++], out key, out value))
+                                        {
+                                            if (key == "{")
+                                            {
+                                                continue;
+                                            }
+                                            else if (key == "}")
+                                            {
+                                                break;
+                                            }
+                                            else if (key == "creator_mask")
+                                            {
+                                                // Deprecated
+                                                uint val;
+                                                if (Utils.TryParseHex(value, out val))
+                                                    perms.BaseMask = (PermissionMask)val;
+                                            }
+                                            else if (key == "base_mask")
+                                            {
+                                                uint val;
+                                                if (Utils.TryParseHex(value, out val))
+                                                    perms.BaseMask = (PermissionMask)val;
+                                            }
+                                            else if (key == "owner_mask")
+                                            {
+                                                uint val;
+                                                if (Utils.TryParseHex(value, out val))
+                                                    perms.OwnerMask = (PermissionMask)val;
+                                            }
+                                            else if (key == "group_mask")
+                                            {
+                                                uint val;
+                                                if (Utils.TryParseHex(value, out val))
+                                                    perms.GroupMask = (PermissionMask)val;
+                                            }
+                                            else if (key == "everyone_mask")
+                                            {
+                                                uint val;
+                                                if (Utils.TryParseHex(value, out val))
+                                                    perms.EveryoneMask = (PermissionMask)val;
+                                            }
+                                            else if (key == "next_owner_mask")
+                                            {
+                                                uint val;
+                                                if (Utils.TryParseHex(value, out val))
+                                                    perms.NextOwnerMask = (PermissionMask)val;
+                                            }
+                                            else if (key == "creator_id")
+                                            {
+                                                
+                                                UUID.TryParse(value, out creatorID);
+                                            }
+                                            else if (key == "owner_id")
+                                            {
+                                                UUID.TryParse(value, out ownerID);
+                                            }
+                                            else if (key == "last_owner_id")
+                                            {
+                                                UUID.TryParse(value, out lastOwnerID);
+                                            }
+                                            else if (key == "group_id")
+                                            {
+                                                UUID.TryParse(value, out groupID);
+                                            }
+                                            else if (key == "group_owned")
+                                            {
+                                                uint val;
+                                                if (UInt32.TryParse(value, out val))
+                                                    groupOwned = (val != 0);
+                                            }
+                                        }
+                                    }
+
+                                    #endregion permissions
+                                }
+                                else if (key == "sale_info")
+                                {
+                                    #region sale_info
+
+                                    while (lineNum < lines.Length)
+                                    {
+                                        if (ParseLine(lines[lineNum++], out key, out value))
+                                        {
+                                            if (key == "{")
+                                            {
+                                                continue;
+                                            }
+                                            else if (key == "}")
+                                            {
+                                                break;
+                                            }
+                                            else if (key == "sale_type")
+                                            {
+                                                saleType = StringToSaleType(value);
+                                            }
+                                            else if (key == "sale_price")
+                                            {
+                                                Int32.TryParse(value, out salePrice);
+                                            }
+                                        }
+                                    }
+
+                                    #endregion sale_info
+                                }
+                                else if (key == "shadow_id")
+                                {
+                                    //FIXME:
+                                }
+                                else if (key == "asset_id")
+                                {
+                                    UUID.TryParse(value, out assetID);
+                                }
+                                else if (key == "type")
+                                {
+                                    assetType = StringToAssetType(value);
+                                }
+                                else if (key == "inv_type")
+                                {
+                                    inventoryType = StringToInventoryType(value);
+                                }
+                                else if (key == "flags")
+                                {
+                                    UInt32.TryParse(value, out flags);
+                                }
+                                else if (key == "name")
+                                {
+                                    name = value.Substring(0, value.IndexOf('|'));
+                                }
+                                else if (key == "desc")
+                                {
+                                    desc = value.Substring(0, value.IndexOf('|'));
+                                }
+                                else if (key == "creation_date")
+                                {
+                                    uint timestamp;
+                                    if (UInt32.TryParse(value, out timestamp))
+                                        creationDate = Utils.UnixTimeToDateTime(timestamp);
+                                    else
+                                        Logger.Log("Failed to parse creation_date " + value, Helpers.LogLevel.Warning);
+                                }
+                            }
+                        }
+
+                        InventoryItem item = CreateInventoryItem(inventoryType, itemID);
+                        item.AssetUUID = assetID;
+                        item.AssetType = assetType;
+                        item.CreationDate = creationDate;
+                        item.CreatorID = creatorID;
+                        item.Description = desc;
+                        item.Flags = flags;
+                        item.GroupID = groupID;
+                        item.GroupOwned = groupOwned;
+                        item.Name = name;
+                        item.OwnerID = ownerID;
+                        item.ParentUUID = parentID;
+                        item.Permissions = perms;
+                        item.SalePrice = salePrice;
+                        item.SaleType = saleType;
+
+                        items.Add(item);
+
+                        #endregion inv_item
+                    }
+                    else
+                    {
+                        Logger.Log("Unrecognized token " + key + " in: " + Environment.NewLine + taskData,
+                            Helpers.LogLevel.Error);
+                    }
+                }
+            }
+
+            return items;
+        }
+
+        /// <summary>
+        /// Save the current inventory structure to a cache file
+        /// </summary>
+        /// <param name="filename">Name of the cache file to save to</param>
+        public void cache_inventory_to_disk(string filename)
+        {
+            Stream stream = File.Open("filename", FileMode.Create);
+            BinaryFormatter bformatter = new BinaryFormatter();
+            Console.WriteLine("Writing Inventory Information");
+            foreach (KeyValuePair<UUID, InventoryNode> kvp in Store.Items)
+            {
+                bformatter.Serialize(stream, kvp.Value);
+            }
+            stream.Close();
+        }
+
+        /// <summary>
+        /// Loads in inventory cache file into the inventory structure. Note only valid to call after login has been successful.
+        /// </summary>
+        /// <param name="filename">Name of the cache file to load</param>
+        public void read_inventory_cache(string filename)
+        {
+            List<InventoryNode> nodes = new List<InventoryNode>();
+            int item_count = 0;
+
+            try
+            {
+                Stream stream = File.Open("filename", FileMode.Open);
+                BinaryFormatter bformatter = new BinaryFormatter();
+
+                while (stream.Position < stream.Length)
+                {
+                    OpenMetaverse.InventoryNode node = (InventoryNode)bformatter.Deserialize(stream);
+                    nodes.Add(node);
+                    item_count++;
+                }
+
+                stream.Close();
+            }
+            catch (Exception e)
+            {
+                Logger.Log("Error accessing inventory cache file :" + e.Message,Helpers.LogLevel.Error);
+                return;
+            }
+
+            Logger.Log("Read " + item_count.ToString() + " items from inventory cache file", Helpers.LogLevel.Info);
+
+            item_count = 0;
+
+            List<InventoryNode> del_nodes = new List<InventoryNode>();
+
+            // Becuase we could get child nodes before parents we must itterate around and only add nodes who have
+            // a parent already in the list because we must update both child and parent to link together
+            while (nodes.Count != 0)
+            {
+                foreach (InventoryNode node in nodes)
+                {
+                    InventoryNode pnode;
+                    if (node.ParentID == UUID.Zero)
+                    {
+                        //We don't need the root nodes "My Inventory" etc as they will already exist for the correct
+                        // user of this cache.
+                        del_nodes.Add(node);
+                    }
+                    else if (Store.Items.TryGetValue(node.ParentID, out pnode))
+                    {
+                        if (node.Data != null)
+                        {
+                            //Only add new items, this is most likely to be run at login time before any inventory
+                            //nodes other than the root are populated.
+                            if (!Store.Items.ContainsKey(node.Data.UUID))
+                            {
+                                Store.Items.Add(node.Data.UUID, node);
+                                node.Parent = pnode; //Update this node with its parent
+                                pnode.Nodes.Add(node.Data.UUID, node); // Add to the parents child list
+                                item_count++;
+                            }
+                        }
+                       
+                        del_nodes.Add(node);
+                    }
+
+                }
+
+                //Clean up processed nodes this loop around.
+                foreach (InventoryNode node in del_nodes)
+                    nodes.Remove(node);
+             
+                del_nodes.Clear();
+            }
+
+            Logger.Log("Reassembled " + item_count.ToString() + " items from inventory cache file", Helpers.LogLevel.Info);
+        }
+
+        #endregion Helper Functions
+
+        #region Callbacks
+
+        private void CreateItemFromAssetResponse(CapsClient client, OSD result, Exception error)
+        {
+            object[] args = (object[])client.UserData;
+            CapsClient.ProgressCallback progCallback = (CapsClient.ProgressCallback)args[0];
+            ItemCreatedFromAssetCallback callback = (ItemCreatedFromAssetCallback)args[1];
+            byte[] itemData = (byte[])args[2];
+
+            if (result == null)
+            {
+                try { callback(false, error.Message, UUID.Zero, UUID.Zero); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+                return;
+            }
+
+            OSDMap contents = (OSDMap)result;
+
+            string status = contents["state"].AsString().ToLower();
+
+            if (status == "upload")
+            {
+                string uploadURL = contents["uploader"].AsString();
+
+                Logger.DebugLog("CreateItemFromAsset: uploading to " + uploadURL);
+
+                // This makes the assumption that all uploads go to CurrentSim, to avoid
+                // the problem of HttpRequestState not knowing anything about simulators
+                CapsClient upload = new CapsClient(new Uri(uploadURL));
+                upload.OnProgress += progCallback;
+                upload.OnComplete += new CapsClient.CompleteCallback(CreateItemFromAssetResponse);
+                upload.UserData = new object[] { null, callback, itemData };
+                upload.StartRequest(itemData, "application/octet-stream");
+            }
+            else if (status == "complete")
+            {
+                Logger.DebugLog("CreateItemFromAsset: completed"); 
+
+                if (contents.ContainsKey("new_inventory_item") && contents.ContainsKey("new_asset"))
+                {
+                    try { callback(true, String.Empty, contents["new_inventory_item"].AsUUID(), contents["new_asset"].AsUUID()); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+                }
+                else
+                {
+                    try { callback(false, "Failed to parse asset and item UUIDs", UUID.Zero, UUID.Zero); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+                }
+            }
+            else
+            {
+                // Failure
+                try { callback(false, status, UUID.Zero, UUID.Zero); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+            }
+        }
+
+        private void SaveAssetIntoInventoryHandler(Packet packet, Simulator simulator)
+        {
+            //SaveAssetIntoInventoryPacket save = (SaveAssetIntoInventoryPacket)packet;
+
+            // FIXME: Find this item in the inventory structure and mark the parent as needing an update
+            //save.InventoryData.ItemID;
+            Logger.Log("SaveAssetIntoInventory packet received, someone write this function!", Helpers.LogLevel.Error, _Client);
+        }
+
+        private void InventoryDescendentsHandler(Packet packet, Simulator simulator)
+        {
+            InventoryDescendentsPacket reply = (InventoryDescendentsPacket)packet;
+
+            if (reply.AgentData.Descendents > 0)
+            {
+                // InventoryDescendantsReply sends a null folder if the parent doesnt contain any folders
+                if (reply.FolderData[0].FolderID != UUID.Zero)
+                {
+                    // Iterate folders in this packet
+                    for (int i = 0; i < reply.FolderData.Length; i++)
+                    {
+                        InventoryFolder folder = new InventoryFolder(reply.FolderData[i].FolderID);
+                        folder.ParentUUID = reply.FolderData[i].ParentID;
+                        folder.Name = Utils.BytesToString(reply.FolderData[i].Name);
+                        folder.PreferredType = (AssetType)reply.FolderData[i].Type;
+                        folder.OwnerID = reply.AgentData.OwnerID;
+
+                        _Store[folder.UUID] = folder;
+                    }
+                }
+
+                // InventoryDescendantsReply sends a null item if the parent doesnt contain any items.
+                if (reply.ItemData[0].ItemID != UUID.Zero)
+                {
+                    // Iterate items in this packet
+                    for (int i = 0; i < reply.ItemData.Length; i++)
+                    {
+                        if (reply.ItemData[i].ItemID != UUID.Zero)
+                        {
+                            InventoryItem item;
+                            /* 
+                             * Objects that have been attached in-world prior to being stored on the 
+                             * asset server are stored with the InventoryType of 0 (Texture) 
+                             * instead of 17 (Attachment) 
+                             * 
+                             * This corrects that behavior by forcing Object Asset types that have an 
+                             * invalid InventoryType with the proper InventoryType of Attachment.
+                             */
+                            if ((AssetType)reply.ItemData[i].Type == AssetType.Object 
+                                && (InventoryType)reply.ItemData[i].InvType == InventoryType.Texture)
+                            {
+                                item = CreateInventoryItem(InventoryType.Attachment, reply.ItemData[i].ItemID);
+                                item.InventoryType = InventoryType.Attachment;
+                            }
+                            else
+                            {
+                                item = CreateInventoryItem((InventoryType)reply.ItemData[i].InvType, reply.ItemData[i].ItemID);
+                                item.InventoryType = (InventoryType)reply.ItemData[i].InvType;
+                            }
+                            
+                            item.ParentUUID = reply.ItemData[i].FolderID;
+                            item.CreatorID = reply.ItemData[i].CreatorID;
+                            item.AssetType = (AssetType)reply.ItemData[i].Type;
+                            item.AssetUUID = reply.ItemData[i].AssetID;
+                            item.CreationDate = Utils.UnixTimeToDateTime((uint)reply.ItemData[i].CreationDate);
+                            item.Description = Utils.BytesToString(reply.ItemData[i].Description);
+                            item.Flags = reply.ItemData[i].Flags;
+                            item.Name = Utils.BytesToString(reply.ItemData[i].Name);
+                            item.GroupID = reply.ItemData[i].GroupID;
+                            item.GroupOwned = reply.ItemData[i].GroupOwned;
+                            item.Permissions = new Permissions(
+                                reply.ItemData[i].BaseMask,
+                                reply.ItemData[i].EveryoneMask,
+                                reply.ItemData[i].GroupMask,
+                                reply.ItemData[i].NextOwnerMask,
+                                reply.ItemData[i].OwnerMask);
+                            item.SalePrice = reply.ItemData[i].SalePrice;
+                            item.SaleType = (SaleType)reply.ItemData[i].SaleType;
+                            item.OwnerID = reply.AgentData.OwnerID;
+
+                            _Store[item.UUID] = item;
+                        }
+                    }
+                }
+            }
+
+            InventoryFolder parentFolder = null;
+
+            if (_Store.Contains(reply.AgentData.FolderID) &&
+                _Store[reply.AgentData.FolderID] is InventoryFolder)
+            {
+                parentFolder = _Store[reply.AgentData.FolderID] as InventoryFolder;
+            }
+            else
+            {
+                Logger.Log("Don't have a reference to FolderID " + reply.AgentData.FolderID.ToString() +
+                    " or it is not a folder", Helpers.LogLevel.Error, _Client);
+                return;
+            }
+
+            if (reply.AgentData.Version < parentFolder.Version)
+            {
+                Logger.Log("Got an outdated InventoryDescendents packet for folder " + parentFolder.Name +
+                    ", this version = " + reply.AgentData.Version + ", latest version = " + parentFolder.Version,
+                    Helpers.LogLevel.Warning, _Client);
+                return;
+            }
+
+            parentFolder.Version = reply.AgentData.Version;
+            // FIXME: reply.AgentData.Descendants is not parentFolder.DescendentCount if we didn't 
+            // request items and folders
+            parentFolder.DescendentCount = reply.AgentData.Descendents;
+
+            #region FindObjectsByPath Handling
+
+            if (_Searches.Count > 0)
+            {
+                lock (_Searches)
+                {
+                StartSearch:
+
+                    // Iterate over all of the outstanding searches
+                    for (int i = 0; i < _Searches.Count; i++)
+                    {
+                        InventorySearch search = _Searches[i];
+                        List<InventoryBase> folderContents = _Store.GetContents(search.Folder);
+
+                        // Iterate over all of the inventory objects in the base search folder
+                        for (int j = 0; j < folderContents.Count; j++)
+                        {
+                            // Check if this inventory object matches the current path node
+                            if (folderContents[j].Name == search.Path[search.Level])
+                            {
+                                if (search.Level == search.Path.Length - 1)
+                                {
+                                    Logger.DebugLog("Finished path search of " + String.Join("/", search.Path), _Client);
+
+                                    // This is the last node in the path, fire the callback and clean up
+                                    if (OnFindObjectByPath != null)
+                                    {
+                                        try { OnFindObjectByPath(String.Join("/", search.Path), folderContents[j].UUID); }
+                                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+                                    }
+
+                                    // Remove this entry and restart the loop since we are changing the collection size
+                                    _Searches.RemoveAt(i);
+                                    goto StartSearch;
+                                }
+                                else
+                                {
+                                    // We found a match but it is not the end of the path, request the next level
+                                    Logger.DebugLog(String.Format("Matched level {0}/{1} in a path search of {2}",
+                                        search.Level, search.Path.Length - 1, String.Join("/", search.Path)), _Client);
+
+                                    search.Folder = folderContents[j].UUID;
+                                    search.Level++;
+                                    _Searches[i] = search;
+
+                                    RequestFolderContents(search.Folder, search.Owner, true, true, 
+                                        InventorySortOrder.ByName);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            #endregion FindObjectsByPath Handling
+
+            // Callback for inventory folder contents being updated
+            if (OnFolderUpdated != null)
+            {
+                try { OnFolderUpdated(parentFolder.UUID); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+            }
+        }
+
+        /// <summary>
+        /// UpdateCreateInventoryItem packets are received when a new inventory item 
+        /// is created. This may occur when an object that's rezzed in world is
+        /// taken into inventory, when an item is created using the CreateInventoryItem
+        /// packet, or when an object is purchased
+        /// </summary>
+        private void UpdateCreateInventoryItemHandler(Packet packet, Simulator simulator)
+        {
+            UpdateCreateInventoryItemPacket reply = packet as UpdateCreateInventoryItemPacket;
+
+            foreach (UpdateCreateInventoryItemPacket.InventoryDataBlock dataBlock in reply.InventoryData)
+            {
+                if (dataBlock.InvType == (sbyte)InventoryType.Folder)
+                {
+                    Logger.Log("Received InventoryFolder in an UpdateCreateInventoryItem packet, this should not happen!",
+                        Helpers.LogLevel.Error, _Client);
+                    continue;
+                }
+
+                InventoryItem item = CreateInventoryItem((InventoryType)dataBlock.InvType,dataBlock.ItemID);
+                item.AssetType = (AssetType)dataBlock.Type;
+                item.AssetUUID = dataBlock.AssetID;
+                item.CreationDate = Utils.UnixTimeToDateTime(dataBlock.CreationDate);
+                item.CreatorID = dataBlock.CreatorID;
+                item.Description = Utils.BytesToString(dataBlock.Description);
+                item.Flags = dataBlock.Flags;
+                item.GroupID = dataBlock.GroupID;
+                item.GroupOwned = dataBlock.GroupOwned;
+                item.Name = Utils.BytesToString(dataBlock.Name);
+                item.OwnerID = dataBlock.OwnerID;
+                item.ParentUUID = dataBlock.FolderID;
+                item.Permissions = new Permissions(
+                        dataBlock.BaseMask,
+                        dataBlock.EveryoneMask,
+                        dataBlock.GroupMask,
+                        dataBlock.NextOwnerMask,
+                        dataBlock.OwnerMask);
+                item.SalePrice = dataBlock.SalePrice;
+                item.SaleType = (SaleType)dataBlock.SaleType;
+
+                /* 
+                 * When attaching new objects, an UpdateCreateInventoryItem packet will be
+                 * returned by the server that has a FolderID/ParentUUID of zero. It is up
+                 * to the client to make sure that the item gets a good folder, otherwise
+                 * it will end up inaccesible in inventory.
+                 */
+                if (item.ParentUUID == UUID.Zero)
+                {
+                    // assign default folder for type
+                    item.ParentUUID = FindFolderForType(item.AssetType);
+
+                    // send update to the sim
+                    RequestUpdateItem(item);
+                }
+
+                // Update the local copy
+                _Store[item.UUID] = item;
+
+                // Look for an "item created" callback
+                ItemCreatedCallback createdCallback;
+                if (_ItemCreatedCallbacks.TryGetValue(dataBlock.CallbackID, out createdCallback))
+                {
+                    _ItemCreatedCallbacks.Remove(dataBlock.CallbackID);
+
+                    try { createdCallback(true, item); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+                }
+
+                // TODO: Is this callback even triggered when items are copied?
+                // Look for an "item copied" callback
+                ItemCopiedCallback copyCallback;
+                if (_ItemCopiedCallbacks.TryGetValue(dataBlock.CallbackID, out copyCallback))
+                {
+                    _ItemCopiedCallbacks.Remove(dataBlock.CallbackID);
+
+                    try { copyCallback(item); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+                }
+                
+                //This is triggered when an item is received from a task
+                if (OnTaskItemReceived != null)
+                {
+                    try { OnTaskItemReceived(item.UUID, dataBlock.FolderID, item.CreatorID, item.AssetUUID, 
+                        item.InventoryType); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+                }
+            }
+        }
+
+        private void MoveInventoryItemHandler(Packet packet, Simulator simulator)
+        {
+            MoveInventoryItemPacket move = (MoveInventoryItemPacket)packet;
+
+            for (int i = 0; i < move.InventoryData.Length; i++)
+            {
+                // FIXME: Do something here
+                string newName = Utils.BytesToString(move.InventoryData[i].NewName);
+
+                Logger.Log(String.Format(
+                    "MoveInventoryItemHandler: Item {0} is moving to Folder {1} with new name \"{2}\". Someone write this function!",
+                    move.InventoryData[i].ItemID.ToString(), move.InventoryData[i].FolderID.ToString(),
+                    newName), Helpers.LogLevel.Warning, _Client);
+            }
+        }
+
+        private void BulkUpdateInventoryHandler(Packet packet, Simulator simulator)
+        {
+            BulkUpdateInventoryPacket update = packet as BulkUpdateInventoryPacket;
+
+            if (update.FolderData.Length > 0 && update.FolderData[0].FolderID != UUID.Zero)
+            {
+                foreach (BulkUpdateInventoryPacket.FolderDataBlock dataBlock in update.FolderData)
+                {
+                    if (!_Store.Contains(dataBlock.FolderID))
+                        Logger.Log("Received BulkUpdate for unknown folder: " + dataBlock.FolderID, Helpers.LogLevel.Warning, _Client);
+
+                    InventoryFolder folder = new InventoryFolder(dataBlock.FolderID);
+                    folder.Name = Utils.BytesToString(dataBlock.Name);
+                    folder.OwnerID = update.AgentData.AgentID;
+                    folder.ParentUUID = dataBlock.ParentID;
+                    _Store[folder.UUID] = folder;
+                }
+            }
+
+            if (update.ItemData.Length > 0 && update.ItemData[0].ItemID != UUID.Zero)
+            {
+                for (int i = 0; i < update.ItemData.Length; i++)
+                {
+                    BulkUpdateInventoryPacket.ItemDataBlock dataBlock = update.ItemData[i];
+
+                    // If we are given a folder of items, the item information might arrive before the folder
+                    // (parent) is in the store
+                    if (!_Store.Contains(dataBlock.ItemID))
+                        Logger.Log("Received BulkUpdate for unknown item: " + dataBlock.ItemID, Helpers.LogLevel.Warning, _Client);
+
+                    InventoryItem item = SafeCreateInventoryItem((InventoryType)dataBlock.InvType, dataBlock.ItemID);
+
+                    item.AssetType = (AssetType)dataBlock.Type;
+                    if (dataBlock.AssetID != UUID.Zero) item.AssetUUID = dataBlock.AssetID;
+                    item.CreationDate = Utils.UnixTimeToDateTime(dataBlock.CreationDate);
+                    item.CreatorID = dataBlock.CreatorID;
+                    item.Description = Utils.BytesToString(dataBlock.Description);
+                    item.Flags = dataBlock.Flags;
+                    item.GroupID = dataBlock.GroupID;
+                    item.GroupOwned = dataBlock.GroupOwned;
+                    item.Name = Utils.BytesToString(dataBlock.Name);
+                    item.OwnerID = dataBlock.OwnerID;
+                    item.ParentUUID = dataBlock.FolderID;
+                    item.Permissions = new Permissions(
+                        dataBlock.BaseMask,
+                        dataBlock.EveryoneMask,
+                        dataBlock.GroupMask,
+                        dataBlock.NextOwnerMask,
+                        dataBlock.OwnerMask);
+                    item.SalePrice = dataBlock.SalePrice;
+                    item.SaleType = (SaleType)dataBlock.SaleType;
+
+                    _Store[item.UUID] = item;
+
+                    // Look for an "item created" callback
+                    ItemCreatedCallback callback;
+                    if (_ItemCreatedCallbacks.TryGetValue(dataBlock.CallbackID, out callback))
+                    {
+                        _ItemCreatedCallbacks.Remove(dataBlock.CallbackID);
+
+                        try { callback(true, item); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+                    }
+
+                    // Look for an "item copied" callback
+                    ItemCopiedCallback copyCallback;
+                    if (_ItemCopiedCallbacks.TryGetValue(dataBlock.CallbackID, out copyCallback))
+                    {
+                        _ItemCopiedCallbacks.Remove(dataBlock.CallbackID);
+
+                        try { copyCallback(item); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+                    }
+                }
+            }
+        }
+
+        private void FetchInventoryReplyHandler(Packet packet, Simulator simulator)
+        {
+            FetchInventoryReplyPacket reply = packet as FetchInventoryReplyPacket;
+
+            foreach (FetchInventoryReplyPacket.InventoryDataBlock dataBlock in reply.InventoryData) 
+            {
+                if (dataBlock.InvType == (sbyte)InventoryType.Folder)
+                {
+                    Logger.Log("Received FetchInventoryReply for an inventory folder, this should not happen!",
+                        Helpers.LogLevel.Error, _Client);
+                    continue;
+                }
+
+                InventoryItem item = CreateInventoryItem((InventoryType)dataBlock.InvType,dataBlock.ItemID);
+                item.AssetType = (AssetType)dataBlock.Type;
+                item.AssetUUID = dataBlock.AssetID;
+                item.CreationDate = Utils.UnixTimeToDateTime(dataBlock.CreationDate);
+                item.CreatorID = dataBlock.CreatorID;
+                item.Description = Utils.BytesToString(dataBlock.Description);
+                item.Flags = dataBlock.Flags;
+                item.GroupID = dataBlock.GroupID;
+                item.GroupOwned = dataBlock.GroupOwned;
+                item.Name = Utils.BytesToString(dataBlock.Name);
+                item.OwnerID = dataBlock.OwnerID;
+                item.ParentUUID = dataBlock.FolderID;
+                item.Permissions = new Permissions(
+                    dataBlock.BaseMask, 
+                    dataBlock.EveryoneMask, 
+                    dataBlock.GroupMask, 
+                    dataBlock.NextOwnerMask, 
+                    dataBlock.OwnerMask);
+                item.SalePrice = dataBlock.SalePrice;
+                item.SaleType = (SaleType)dataBlock.SaleType;
+
+                _Store[item.UUID] = item;
+
+                // Fire the callback for an item being fetched
+                if (OnItemReceived != null)
+                {
+                    try { OnItemReceived(item); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+                }
+            }
+        }
+
+        private void ReplyTaskInventoryHandler(Packet packet, Simulator simulator)
+        {
+            if (OnTaskInventoryReply != null)
+            {
+                ReplyTaskInventoryPacket reply = (ReplyTaskInventoryPacket)packet;
+
+                try
+                {
+                    OnTaskInventoryReply(reply.InventoryData.TaskID, reply.InventoryData.Serial,
+                        Utils.BytesToString(reply.InventoryData.Filename));
+                }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+            }
+        }
+
+        private void Self_OnInstantMessage(InstantMessage im, Simulator simulator)
+        {
+            // TODO: MainAvatar.InstantMessageDialog.GroupNotice can also be an inventory offer, should we
+            // handle it here?
+
+            if (OnObjectOffered != null && 
+                (im.Dialog == InstantMessageDialog.InventoryOffered 
+                || im.Dialog == InstantMessageDialog.TaskInventoryOffered))
+            {
+                AssetType type = AssetType.Unknown;
+                UUID objectID = UUID.Zero;
+                bool fromTask = false;
+
+                if (im.Dialog == InstantMessageDialog.InventoryOffered)
+                {
+                    if (im.BinaryBucket.Length == 17)
+                    {
+                        type = (AssetType)im.BinaryBucket[0];
+                        objectID = new UUID(im.BinaryBucket, 1);
+                        fromTask = false;
+                    }
+                    else
+                    {
+                        Logger.Log("Malformed inventory offer from agent", Helpers.LogLevel.Warning, _Client);
+                        return;
+                    }
+                }
+                else if (im.Dialog == InstantMessageDialog.TaskInventoryOffered)
+                {
+                    if (im.BinaryBucket.Length == 1)
+                    {
+                        type = (AssetType)im.BinaryBucket[0];
+                        fromTask = true;
+                    }
+                    else
+                    {
+                        Logger.Log("Malformed inventory offer from object", Helpers.LogLevel.Warning, _Client);
+                        return;
+                    }
+                }
+
+                // Find the folder where this is going to go
+                UUID destinationFolderID = FindFolderForType(type);
+
+                // Fire the callback
+                try
+                {
+                    ImprovedInstantMessagePacket imp = new ImprovedInstantMessagePacket();
+                    imp.AgentData.AgentID = _Client.Self.AgentID;
+                    imp.AgentData.SessionID = _Client.Self.SessionID;
+                    imp.MessageBlock.FromGroup = false;
+                    imp.MessageBlock.ToAgentID = im.FromAgentID;
+                    imp.MessageBlock.Offline = 0;
+                    imp.MessageBlock.ID = im.IMSessionID;
+                    imp.MessageBlock.Timestamp = 0;
+                    imp.MessageBlock.FromAgentName = Utils.StringToBytes(_Client.Self.Name);
+                    imp.MessageBlock.Message = new byte[0];
+                    imp.MessageBlock.ParentEstateID = 0;
+                    imp.MessageBlock.RegionID = UUID.Zero;
+                    imp.MessageBlock.Position = _Client.Self.SimPosition;
+
+                    if (OnObjectOffered(im, type, objectID, fromTask))
+                    {
+                        // Accept the inventory offer
+                        switch (im.Dialog)
+                        {
+                            case InstantMessageDialog.InventoryOffered:
+                                imp.MessageBlock.Dialog = (byte)InstantMessageDialog.InventoryAccepted;
+                                break;
+                            case InstantMessageDialog.TaskInventoryOffered:
+                                imp.MessageBlock.Dialog = (byte)InstantMessageDialog.TaskInventoryAccepted;
+                                break;
+                            case InstantMessageDialog.GroupNotice:
+                                imp.MessageBlock.Dialog = (byte)InstantMessageDialog.GroupNoticeInventoryAccepted;
+                                break;
+                        }
+
+                        imp.MessageBlock.BinaryBucket = destinationFolderID.GetBytes();
+                    }
+                    else
+                    {
+                        // Decline the inventory offer
+                        switch (im.Dialog)
+                        {
+                            case InstantMessageDialog.InventoryOffered:
+                                imp.MessageBlock.Dialog = (byte)InstantMessageDialog.InventoryDeclined;
+                                break;
+                            case InstantMessageDialog.TaskInventoryOffered:
+                                imp.MessageBlock.Dialog = (byte)InstantMessageDialog.TaskInventoryDeclined;
+                                break;
+                            case InstantMessageDialog.GroupNotice:
+                                imp.MessageBlock.Dialog = (byte)InstantMessageDialog.GroupNoticeInventoryDeclined;
+                                break;
+                        }
+
+                        imp.MessageBlock.BinaryBucket = new byte[0];
+                    }
+
+                    _Client.Network.SendPacket(imp, simulator);
+                }
+                catch (Exception e)
+                {
+                    Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e);
+                }
+            }
+        }
+        
+        private void Network_OnLoginResponse(bool loginSuccess, bool redirect, string message, string reason, LoginResponseData replyData)
+        {
+            if (loginSuccess)
+            {
+                // Initialize the store here so we know who owns it:
+                _Store = new Inventory(_Client, this, _Client.Self.AgentID);
+                Logger.DebugLog("Setting InventoryRoot to " + replyData.InventoryRoot.ToString(), _Client);
+                InventoryFolder rootFolder = new InventoryFolder(replyData.InventoryRoot);
+                rootFolder.Name = String.Empty;
+                rootFolder.ParentUUID = UUID.Zero;
+                _Store.RootFolder = rootFolder;
+
+                for (int i = 0; i < replyData.InventorySkeleton.Length; i++)
+                    _Store.UpdateNodeFor(replyData.InventorySkeleton[i]);
+
+                InventoryFolder libraryRootFolder = new InventoryFolder(replyData.LibraryRoot);
+                libraryRootFolder.Name = String.Empty;
+                libraryRootFolder.ParentUUID = UUID.Zero;
+                _Store.LibraryFolder = libraryRootFolder;
+
+                for(int i = 0; i < replyData.LibrarySkeleton.Length; i++)
+                    _Store.UpdateNodeFor(replyData.LibrarySkeleton[i]);
+            }
+        }
+
+        private void UploadNotecardAssetResponse(CapsClient client, OSD result, Exception error)
+        {
+            OSDMap contents = (OSDMap)result;
+            KeyValuePair<NotecardUploadedAssetCallback, byte[]> kvp = (KeyValuePair<NotecardUploadedAssetCallback, byte[]>)(((object[])client.UserData)[0]);
+            NotecardUploadedAssetCallback callback = kvp.Key;
+            byte[] itemData = (byte[])kvp.Value;
+
+            string status = contents["state"].AsString();
+
+            if (status == "upload")
+            {
+                string uploadURL = contents["uploader"].AsString();
+
+                // This makes the assumption that all uploads go to CurrentSim, to avoid
+                // the problem of HttpRequestState not knowing anything about simulators
+                CapsClient upload = new CapsClient(new Uri(uploadURL));
+                upload.OnComplete += new CapsClient.CompleteCallback(UploadNotecardAssetResponse);
+                upload.UserData = new object[2] { kvp, (UUID)(((object[])client.UserData)[1]) };
+                upload.StartRequest(itemData, "application/octet-stream");
+            }
+            else if (status == "complete")
+            {
+                if (contents.ContainsKey("new_asset"))
+                {
+                    try { callback(true, String.Empty, (UUID)(((object[])client.UserData)[1]), contents["new_asset"].AsUUID()); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+                }
+                else
+                {
+                    try { callback(false, "Failed to parse asset and item UUIDs", UUID.Zero, UUID.Zero); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+                }
+            }
+            else
+            {
+                // Failure
+                try { callback(false, status, UUID.Zero, UUID.Zero); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, _Client, e); }
+            }
+        }
+
+        #endregion Callbacks
+    }
+}
Index: AppearanceManager.cs
===================================================================
--- AppearanceManager.cs	(revision 2445)
+++ AppearanceManager.cs	(working copy)
@@ -1,1458 +1,1469 @@
-/*
- * Copyright (c) 2006-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using System.Collections.Generic;
-using System.Threading;
-using System.IO;
-using OpenMetaverse;
-using OpenMetaverse.Packets;
-using OpenMetaverse.Imaging;
-
-namespace OpenMetaverse
-{
-    public class InvalidOutfitException : Exception
-    {
-        public InvalidOutfitException(string message) : base(message) { }
-    }
-    
-    /// <summary>
-    /// Manager class to for agents appearance, both body parts and clothing
-    /// </summary>
-    public class AppearanceManager
-    {
-        /// <summary>
-        /// 
-        /// </summary>
-        public enum TextureIndex
-        {
-            Unknown = -1,
-            HeadBodypaint = 0,
-            UpperShirt,
-            LowerPants,
-            EyesIris,
-            Hair,
-            UpperBodypaint,
-            LowerBodypaint,
-            LowerShoes,
-            HeadBaked,
-            UpperBaked,
-            LowerBaked,
-            EyesBaked,
-            LowerSocks,
-            UpperJacket,
-            LowerJacket,
-            UpperGloves,
-            UpperUndershirt,
-            LowerUnderpants,
-            Skirt,
-            SkirtBaked
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        public enum BakeType
-        {
-            Unknown = -1,
-            Head = 0,
-            UpperBody = 1,
-            LowerBody = 2,
-            Eyes = 3,
-            Skirt = 4
-        }
-
-        public class WearableData
-        {
-            public InventoryWearable Item;
-            public AssetWearable Asset;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        public delegate void AgentWearablesCallback();
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="te"></param>
-        public delegate void AppearanceUpdatedCallback(Primitive.TextureEntry te);
-
-        /// <summary></summary>
-        public event AgentWearablesCallback OnAgentWearables;
-        /// <summary></summary>
-        public event AppearanceUpdatedCallback OnAppearanceUpdated;
-
-        /// <summary>Total number of wearables for each avatar</summary>
-        public const int WEARABLE_COUNT = 13;
-        /// <summary>Total number of baked textures on each avatar</summary>
-        public const int BAKED_TEXTURE_COUNT = 5;
-        /// <summary>Total number of wearables per bake layer</summary>
-        public const int WEARABLES_PER_LAYER = 7;
-        /// <summary>Total number of textures on an avatar, baked or not</summary>
-        public const int AVATAR_TEXTURE_COUNT = 20;
-        /// <summary>Map of what wearables are included in each bake</summary>
-        public static readonly WearableType[][] WEARABLE_BAKE_MAP = new WearableType[][]
-        {
-            new WearableType[] { WearableType.Shape, WearableType.Skin,    WearableType.Hair,    WearableType.Invalid, WearableType.Invalid, WearableType.Invalid,    WearableType.Invalid    },
-            new WearableType[] { WearableType.Shape, WearableType.Skin,    WearableType.Shirt,   WearableType.Jacket,  WearableType.Gloves,  WearableType.Undershirt, WearableType.Invalid    },
-            new WearableType[] { WearableType.Shape, WearableType.Skin,    WearableType.Pants,   WearableType.Shoes,   WearableType.Socks,   WearableType.Jacket,     WearableType.Underpants },
-            new WearableType[] { WearableType.Eyes,  WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid,    WearableType.Invalid    },
-            new WearableType[] { WearableType.Skirt, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid } 
-        };
-        /// <summary>Secret values to finalize the cache check hashes for each
-        /// bake</summary>
-        public static readonly UUID[] BAKED_TEXTURE_HASH = new UUID[]
-        {
-            new UUID("18ded8d6-bcfc-e415-8539-944c0f5ea7a6"),
-	        new UUID("338c29e3-3024-4dbb-998d-7c04cf4fa88f"),
-	        new UUID("91b4a2c7-1b1a-ba16-9a16-1f8f8dcc1c3f"),
-	        new UUID("b2cf28af-b840-1071-3c6a-78085d8128b5"),
-	        new UUID("ea800387-ea1a-14e0-56cb-24f2022f969a")
-        };
-        /// <summary>Default avatar texture, used to detect when a custom
-        /// texture is not set for a face</summary>
-        public static readonly UUID DEFAULT_AVATAR_TEXTURE = new UUID("c228d1cf-4b5d-4ba8-84f4-899a0796aa97");
-
-
-        private GridClient Client;
-        private AssetManager Assets;
-
-        /// <summary>
-        /// An <seealso cref="T:InternalDictionary"/> which keeps track of wearables data
-        /// </summary>
-        public InternalDictionary<WearableType, WearableData> Wearables = new InternalDictionary<WearableType, WearableData>();
-        // As wearable assets are downloaded and decoded, the textures are added to this array
-        private UUID[] AgentTextures = new UUID[AVATAR_TEXTURE_COUNT];
-
-        protected struct PendingAssetDownload
-        {
-            public UUID Id;
-            public AssetType Type;
-
-            public PendingAssetDownload(UUID id, AssetType type)
-            {
-                Id = id;
-                Type = type;
-            }
-        }
-        
-        // Wearable assets are downloaded one at a time, a new request is pulled off the queue
-        // and started when the previous one completes
-        private Queue<PendingAssetDownload> AssetDownloads = new Queue<PendingAssetDownload>();
-        // A list of all the images we are currently downloading, prior to baking
-        private Dictionary<UUID, TextureIndex> ImageDownloads = new Dictionary<UUID, TextureIndex>();
-        // A list of all the bakes we need to complete
-        private Dictionary<BakeType, Baker> PendingBakes = new Dictionary<BakeType, Baker>(BAKED_TEXTURE_COUNT);
-        // A list of all the uploads that are in progress
-        private Dictionary<UUID, TextureIndex> PendingUploads = new Dictionary<UUID, TextureIndex>(BAKED_TEXTURE_COUNT);
-        // Whether the handler for our current wearable list should automatically start downloading the assets
-        //private bool DownloadWearables = false;
-        private static int CacheCheckSerialNum = 1; //FIXME
-        private static uint SetAppearanceSerialNum = 1; //FIXME
-        private AutoResetEvent WearablesRequestEvent = new AutoResetEvent(false);
-        private AutoResetEvent WearablesDownloadedEvent = new AutoResetEvent(false);
-        private AutoResetEvent CachedResponseEvent = new AutoResetEvent(false);
-        private AutoResetEvent UpdateEvent = new AutoResetEvent(false);
-        // FIXME: Create a class-level appearance thread so multiple threads can't be launched
-
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        /// <param name="client">This agents <seealso cref="OpenMetaverse.GridClient"/> Object</param>
-        /// <param name="assets">Reference to an AssetManager object</param>
-        public AppearanceManager(GridClient client, AssetManager assets)
-        {
-            Client = client;
-            Assets = assets;
-
-            // Initialize AgentTextures to zero UUIDs
-            for (int i = 0; i < AgentTextures.Length; i++)
-                AgentTextures[i] = UUID.Zero;
-
-            Client.Network.RegisterCallback(PacketType.AgentWearablesUpdate, new NetworkManager.PacketCallback(AgentWearablesUpdateHandler));
-            Client.Network.RegisterCallback(PacketType.AgentCachedTextureResponse, new NetworkManager.PacketCallback(AgentCachedTextureResponseHandler));
-            Client.Network.OnDisconnected += new NetworkManager.DisconnectedCallback(Network_OnDisconnected);
-        }
-
-        private static AssetType WearableTypeToAssetType(WearableType type)
-        {
-            switch (type)
-            {
-                case WearableType.Shape:
-                case WearableType.Skin:
-                case WearableType.Hair:
-                case WearableType.Eyes:
-                    return AssetType.Bodypart;
-                case WearableType.Shirt:
-                case WearableType.Pants:
-                case WearableType.Shoes:
-                case WearableType.Socks:
-                case WearableType.Jacket:
-                case WearableType.Gloves:
-                case WearableType.Undershirt:
-                case WearableType.Underpants:
-                case WearableType.Skirt:
-                    return AssetType.Clothing;
-                default:
-                    throw new Exception("Unhandled wearable type " + type);
-            }
-        }
-
-        /// <summary>
-        /// Returns the assetID for a given WearableType 
-        /// </summary>
-        /// <param name="type">the <seealso cref="OpenMetaverse.WearableType"/> of the asset</param>
-        /// <returns>The <seealso cref="OpenMetaverse.UUID"/> of the WearableType</returns>
-        public UUID GetWearableAsset(WearableType type)
-        {
-            WearableData wearable;
-
-            if (Wearables.TryGetValue(type, out wearable))
-                return wearable.Item.AssetUUID;
-            else
-                return UUID.Zero;
-        }
-
-        /// <summary>
-        /// Ask the server what we are wearing and set appearance based on that
-        /// </summary>
-        public void SetPreviousAppearance()
-        {
-            SetPreviousAppearance(true);
-        }
-
-        public void SetPreviousAppearance(bool bake)
-        {
-            Thread appearanceThread = new Thread(new ParameterizedThreadStart(StartSetPreviousAppearance));
-            appearanceThread.Start(bake);
-        }
-
-        private void StartSetPreviousAppearance(object thread_params)
-        {
-            bool bake = (bool)thread_params;
-            SendAgentWearablesRequest();
-            WearablesRequestEvent.WaitOne();
-            UpdateAppearanceFromWearables(bake);
-        }
-
-        private class WearParams
-        {
-            public object Param;
-            public bool Bake;
-            public bool Remove_Existing_Attachments;
-
-            public WearParams(object param, bool bake, bool remove_existing_attachments)
-            {
-                Param = param;
-                Bake = bake;
-                Remove_Existing_Attachments = remove_existing_attachments;
-            }
-        }
-
-        /// <summary>
-        /// Replace the current outfit with a list of wearables and set appearance
-        /// </summary>
-        /// <param name="ibs">List of wearables that define the new outfit</param>
-        public void WearOutfit(List<InventoryBase> ibs)
-        {
-            WearOutfit(ibs, true);
-        }
-        
-        /// <summary>
-        /// Replace the current outfit with a list of wearables and set appearance
-        /// </summary>
-        /// <param name="ibs">List of wearables that define the new outfit</param>
-        /// <param name="bake">Whether to bake textures for the avatar or not</param>
-        public void WearOutfit(List<InventoryBase> ibs, bool bake)
-        {
-            WearParams wearParams = new WearParams(ibs, bake,true);
-            Thread appearanceThread = new Thread(new ParameterizedThreadStart(StartWearOutfit));
-            appearanceThread.Start(wearParams);
-        }
-
-        /// <summary>
-        /// Add to the current outfit with the list supplied
-        /// </summary>
-        /// <param name="ibs">List of wearables that will be added to the outfit</param>
-        /// <param name="bake">Whether to bake textures for the avatar or not</param>
-        public void AddToOutfit(List<InventoryBase> ibs_new, bool bake)
-        {
-            List<InventoryBase> ibs_total = new List<InventoryBase>();
-
-            // Get what we are currently wearing
+/*
+ * Copyright (c) 2006-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Text;
+using System.Collections.Generic;
+using System.Threading;
+using System.IO;
+using OpenMetaverse;
+using OpenMetaverse.Packets;
+using OpenMetaverse.Imaging;
+
+namespace OpenMetaverse
+{
+    public class InvalidOutfitException : Exception
+    {
+        public InvalidOutfitException(string message) : base(message) { }
+    }
+    
+    /// <summary>
+    /// Manager class to for agents appearance, both body parts and clothing
+    /// </summary>
+    public class AppearanceManager
+    {
+        /// <summary>
+        /// 
+        /// </summary>
+        public enum TextureIndex
+        {
+            Unknown = -1,
+            HeadBodypaint = 0,
+            UpperShirt,
+            LowerPants,
+            EyesIris,
+            Hair,
+            UpperBodypaint,
+            LowerBodypaint,
+            LowerShoes,
+            HeadBaked,
+            UpperBaked,
+            LowerBaked,
+            EyesBaked,
+            LowerSocks,
+            UpperJacket,
+            LowerJacket,
+            UpperGloves,
+            UpperUndershirt,
+            LowerUnderpants,
+            Skirt,
+            SkirtBaked
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        public enum BakeType
+        {
+            Unknown = -1,
+            Head = 0,
+            UpperBody = 1,
+            LowerBody = 2,
+            Eyes = 3,
+            Skirt = 4
+        }
+
+        public class WearableData
+        {
+            public InventoryWearable Item;
+            public AssetWearable Asset;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        public delegate void AgentWearablesCallback();
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="te"></param>
+        public delegate void AppearanceUpdatedCallback(Primitive.TextureEntry te);
+
+        /// <summary></summary>
+        public event AgentWearablesCallback OnAgentWearables;
+        /// <summary></summary>
+        public event AppearanceUpdatedCallback OnAppearanceUpdated;
+
+        /// <summary>Total number of wearables for each avatar</summary>
+        public const int WEARABLE_COUNT = 13;
+        /// <summary>Total number of baked textures on each avatar</summary>
+        public const int BAKED_TEXTURE_COUNT = 5;
+        /// <summary>Total number of wearables per bake layer</summary>
+        public const int WEARABLES_PER_LAYER = 7;
+        /// <summary>Total number of textures on an avatar, baked or not</summary>
+        public const int AVATAR_TEXTURE_COUNT = 20;
+        /// <summary>Map of what wearables are included in each bake</summary>
+        public static readonly WearableType[][] WEARABLE_BAKE_MAP = new WearableType[][]
+        {
+            new WearableType[] { WearableType.Shape, WearableType.Skin,    WearableType.Hair,    WearableType.Invalid, WearableType.Invalid, WearableType.Invalid,    WearableType.Invalid    },
+            new WearableType[] { WearableType.Shape, WearableType.Skin,    WearableType.Shirt,   WearableType.Jacket,  WearableType.Gloves,  WearableType.Undershirt, WearableType.Invalid    },
+            new WearableType[] { WearableType.Shape, WearableType.Skin,    WearableType.Pants,   WearableType.Shoes,   WearableType.Socks,   WearableType.Jacket,     WearableType.Underpants },
+            new WearableType[] { WearableType.Eyes,  WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid,    WearableType.Invalid    },
+            new WearableType[] { WearableType.Skirt, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid } 
+        };
+        /// <summary>Secret values to finalize the cache check hashes for each
+        /// bake</summary>
+        public static readonly UUID[] BAKED_TEXTURE_HASH = new UUID[]
+        {
+            new UUID("18ded8d6-bcfc-e415-8539-944c0f5ea7a6"),
+	        new UUID("338c29e3-3024-4dbb-998d-7c04cf4fa88f"),
+	        new UUID("91b4a2c7-1b1a-ba16-9a16-1f8f8dcc1c3f"),
+	        new UUID("b2cf28af-b840-1071-3c6a-78085d8128b5"),
+	        new UUID("ea800387-ea1a-14e0-56cb-24f2022f969a")
+        };
+        /// <summary>Default avatar texture, used to detect when a custom
+        /// texture is not set for a face</summary>
+        public static readonly UUID DEFAULT_AVATAR_TEXTURE = new UUID("c228d1cf-4b5d-4ba8-84f4-899a0796aa97");
+
+
+        private GridClient Client;
+        private AssetManager Assets;
+
+        /// <summary>
+        /// An <seealso cref="T:InternalDictionary"/> which keeps track of wearables data
+        /// </summary>
+        public InternalDictionary<WearableType, WearableData> Wearables = new InternalDictionary<WearableType, WearableData>();
+        // As wearable assets are downloaded and decoded, the textures are added to this array
+        private UUID[] AgentTextures = new UUID[AVATAR_TEXTURE_COUNT];
+
+        protected struct PendingAssetDownload
+        {
+            public UUID Id;
+            public AssetType Type;
+
+            public PendingAssetDownload(UUID id, AssetType type)
+            {
+                Id = id;
+                Type = type;
+            }
+        }
+        
+        // Wearable assets are downloaded one at a time, a new request is pulled off the queue
+        // and started when the previous one completes
+        private Queue<PendingAssetDownload> AssetDownloads = new Queue<PendingAssetDownload>();
+        // A list of all the images we are currently downloading, prior to baking
+        private Dictionary<UUID, TextureIndex> ImageDownloads = new Dictionary<UUID, TextureIndex>();
+        // A list of all the bakes we need to complete
+        private Dictionary<BakeType, Baker> PendingBakes = new Dictionary<BakeType, Baker>(BAKED_TEXTURE_COUNT);
+        // A list of all the uploads that are in progress
+        private Dictionary<UUID, TextureIndex> PendingUploads = new Dictionary<UUID, TextureIndex>(BAKED_TEXTURE_COUNT);
+        // Whether the handler for our current wearable list should automatically start downloading the assets
+        //private bool DownloadWearables = false;
+        private static int CacheCheckSerialNum = 1; //FIXME
+        private static uint SetAppearanceSerialNum = 1; //FIXME
+        private AutoResetEvent WearablesRequestEvent = new AutoResetEvent(false);
+        private AutoResetEvent WearablesDownloadedEvent = new AutoResetEvent(false);
+        private AutoResetEvent CachedResponseEvent = new AutoResetEvent(false);
+        private AutoResetEvent UpdateEvent = new AutoResetEvent(false);
+        // FIXME: Create a class-level appearance thread so multiple threads can't be launched
+
+        /// <summary>
+        /// Default constructor
+        /// </summary>
+        /// <param name="client">This agents <seealso cref="OpenMetaverse.GridClient"/> Object</param>
+        /// <param name="assets">Reference to an AssetManager object</param>
+        public AppearanceManager(GridClient client, AssetManager assets)
+        {
+            Client = client;
+            Assets = assets;
+
+            // Initialize AgentTextures to zero UUIDs
+            for (int i = 0; i < AgentTextures.Length; i++)
+                AgentTextures[i] = UUID.Zero;
+
+            Client.Network.RegisterCallback(PacketType.AgentWearablesUpdate, new NetworkManager.PacketCallback(AgentWearablesUpdateHandler));
+            Client.Network.RegisterCallback(PacketType.AgentCachedTextureResponse, new NetworkManager.PacketCallback(AgentCachedTextureResponseHandler));
+            Client.Network.RegisterCallback(PacketType.RebakeAvatarTextures, new NetworkManager.PacketCallback(RebakeAvatarTexturesHandler));
+            Client.Network.OnDisconnected += new NetworkManager.DisconnectedCallback(Network_OnDisconnected);
+        }
+
+        private void RebakeAvatarTexturesHandler(Packet packet,Simulator simulator)
+        {
+            RebakeAvatarTexturesPacket data = (RebakeAvatarTexturesPacket)packet;
+
+           
+            
+
+
+        }
+
+        private static AssetType WearableTypeToAssetType(WearableType type)
+        {
+            switch (type)
+            {
+                case WearableType.Shape:
+                case WearableType.Skin:
+                case WearableType.Hair:
+                case WearableType.Eyes:
+                    return AssetType.Bodypart;
+                case WearableType.Shirt:
+                case WearableType.Pants:
+                case WearableType.Shoes:
+                case WearableType.Socks:
+                case WearableType.Jacket:
+                case WearableType.Gloves:
+                case WearableType.Undershirt:
+                case WearableType.Underpants:
+                case WearableType.Skirt:
+                    return AssetType.Clothing;
+                default:
+                    throw new Exception("Unhandled wearable type " + type);
+            }
+        }
+
+        /// <summary>
+        /// Returns the assetID for a given WearableType 
+        /// </summary>
+        /// <param name="type">the <seealso cref="OpenMetaverse.WearableType"/> of the asset</param>
+        /// <returns>The <seealso cref="OpenMetaverse.UUID"/> of the WearableType</returns>
+        public UUID GetWearableAsset(WearableType type)
+        {
+            WearableData wearable;
+
+            if (Wearables.TryGetValue(type, out wearable))
+                return wearable.Item.AssetUUID;
+            else
+                return UUID.Zero;
+        }
+
+        /// <summary>
+        /// Ask the server what we are wearing and set appearance based on that
+        /// </summary>
+        public void SetPreviousAppearance()
+        {
+            SetPreviousAppearance(true);
+        }
+
+        public void SetPreviousAppearance(bool bake)
+        {
+            Thread appearanceThread = new Thread(new ParameterizedThreadStart(StartSetPreviousAppearance));
+            appearanceThread.Start(bake);
+        }
+
+        private void StartSetPreviousAppearance(object thread_params)
+        {
+            bool bake = (bool)thread_params;
+            SendAgentWearablesRequest();
+            WearablesRequestEvent.WaitOne();
+            UpdateAppearanceFromWearables(bake);
+        }
+
+        private class WearParams
+        {
+            public object Param;
+            public bool Bake;
+            public bool Remove_Existing_Attachments;
+
+            public WearParams(object param, bool bake, bool remove_existing_attachments)
+            {
+                Param = param;
+                Bake = bake;
+                Remove_Existing_Attachments = remove_existing_attachments;
+            }
+        }
+
+        /// <summary>
+        /// Replace the current outfit with a list of wearables and set appearance
+        /// </summary>
+        /// <param name="ibs">List of wearables that define the new outfit</param>
+        public void WearOutfit(List<InventoryBase> ibs)
+        {
+            WearOutfit(ibs, true);
+        }
+        
+        /// <summary>
+        /// Replace the current outfit with a list of wearables and set appearance
+        /// </summary>
+        /// <param name="ibs">List of wearables that define the new outfit</param>
+        /// <param name="bake">Whether to bake textures for the avatar or not</param>
+        public void WearOutfit(List<InventoryBase> ibs, bool bake)
+        {
+            WearParams wearParams = new WearParams(ibs, bake,true);
+            Thread appearanceThread = new Thread(new ParameterizedThreadStart(StartWearOutfit));
+            appearanceThread.Start(wearParams);
+        }
+
+        /// <summary>
+        /// Add to the current outfit with the list supplied
+        /// </summary>
+        /// <param name="ibs">List of wearables that will be added to the outfit</param>
+        /// <param name="bake">Whether to bake textures for the avatar or not</param>
+        public void AddToOutfit(List<InventoryBase> ibs_new, bool bake)
+        {
+            List<InventoryBase> ibs_total = new List<InventoryBase>();
+
+            // Get what we are currently wearing
             lock(Wearables.Dictionary)
             {
-                foreach (KeyValuePair<WearableType, OpenMetaverse.AppearanceManager.WearableData> kvp in Wearables.Dictionary)
-                    ibs_total.Add((InventoryBase)kvp.Value.Item);
-            
+                foreach (KeyValuePair<WearableType, OpenMetaverse.AppearanceManager.WearableData> kvp in Wearables.Dictionary)
+                    ibs_total.Add((InventoryBase)kvp.Value.Item);
+            
             }
-            // Add the new items at the end, ReplaceOutfitWearables() will do the right thing as it places each warable into a slot in order
-            // so the end of the list will overwrite earlier parts if they use the same slot.
-            foreach (InventoryBase item in ibs_new)
-            {
-                if (item is InventoryWearable)
-                    ibs_total.Add(item);
-            }
-
-            WearParams wearParams = new WearParams(ibs_total, bake, false);
-            Thread appearanceThread = new Thread(new ParameterizedThreadStart(StartWearOutfit));
-            appearanceThread.Start(wearParams);
-        }
-
-        private void StartWearOutfit(object thread_params)
-        {
-            WearParams wearParams = (WearParams)thread_params;
-
-            List<InventoryBase> ibs = (List<InventoryBase>)wearParams.Param;
-            List<InventoryWearable> wearables = new List<InventoryWearable>();
-            List<InventoryBase> attachments = new List<InventoryBase>();
-
-            foreach (InventoryBase ib in ibs)
-            {
-                if (ib is InventoryWearable)
-                    wearables.Add((InventoryWearable)ib);
-                else if (ib is InventoryAttachment || ib is InventoryObject)
-                    attachments.Add(ib);
-            }
-
-
-            SendAgentWearablesRequest();
-            WearablesRequestEvent.WaitOne();
-            ReplaceOutfitWearables(wearables);
-            UpdateAppearanceFromWearables(wearParams.Bake);
-            AddAttachments(attachments, wearParams.Remove_Existing_Attachments);
-        }
-
-        /// <summary>
-        /// Replace the current outfit with a folder and set appearance
-        /// </summary>
-        /// <param name="folder">UUID of the inventory folder to wear</param>
-        public void WearOutfit(UUID folder)
-        {
-            WearOutfit(folder, true);
-        }
-
-        /// <summary>
-        /// Replace the current outfit with a folder and set appearance
-        /// </summary>
-        /// <param name="path">Inventory path of the folder to wear</param>
-        public void WearOutfit(string[] path)
-        {
-            WearOutfit(path, true);
-        }
-
-        /// <summary>
-        /// Replace the current outfit with a folder and set appearance
-        /// </summary>
-        /// <param name="folder">Folder containing the new outfit</param>
-        /// <param name="bake">Whether to bake the avatar textures or not</param>
-        public void WearOutfit(UUID folder, bool bake)
-        {
-            WearParams wearOutfitParams = new WearParams(folder, bake,true);
-            Thread appearanceThread = new Thread(new ParameterizedThreadStart(StartWearOutfitFolder));
-            appearanceThread.Start(wearOutfitParams);
-        }
-
-        /// <summary>
-        /// Replace the current outfit with a folder and set appearance
-        /// </summary>
-        /// <param name="path">Path of folder containing the new outfit</param>
-        /// <param name="bake">Whether to bake the avatar textures or not</param>
-        public void WearOutfit(string[] path, bool bake)
-        {
-            WearParams wearOutfitParams = new WearParams(path, bake,true);
-            Thread appearanceThread = new Thread(new ParameterizedThreadStart(StartWearOutfitFolder));
-            appearanceThread.Start(wearOutfitParams);
-        }
-
-        public void WearOutfit(InventoryFolder folder, bool bake)
-        {
-            WearParams wearOutfitParams = new WearParams(folder, bake,true);
-            Thread appearanceThread = new Thread(new ParameterizedThreadStart(StartWearOutfitFolder));
-            appearanceThread.Start(wearOutfitParams);
-        }
-
-        private void StartWearOutfitFolder(object thread_params)
-        {
-            WearParams wearOutfitParams = (WearParams)thread_params;
-
-            SendAgentWearablesRequest(); // request current wearables async
-            List<InventoryWearable> wearables;
-            List<InventoryBase> attachments;
-
-            if (!GetFolderWearables(wearOutfitParams.Param, out wearables, out attachments)) // get wearables in outfit folder
-                return; // TODO: this error condition should be passed back to the client somehow
-
-            WearablesRequestEvent.WaitOne(); // wait for current wearables
-            ReplaceOutfitWearables(wearables); // replace current wearables with outfit folder
-            UpdateAppearanceFromWearables(wearOutfitParams.Bake);
-            AddAttachments(attachments, wearOutfitParams.Remove_Existing_Attachments);
-        }
-
-        private bool GetFolderWearables(object _folder, out List<InventoryWearable> wearables, out List<InventoryBase> attachments)
-        {
-            UUID folder;
-            wearables = null;
-            attachments = null;
-
-            if (_folder.GetType() == typeof(string[]))
-            {
-                string[] path = (string[])_folder;
-
-                folder = Client.Inventory.FindObjectByPath(
-                    Client.Inventory.Store.RootFolder.UUID, Client.Self.AgentID, String.Join("/", path), 1000 * 20);
-
-                if (folder == UUID.Zero)
-                {
-                    Logger.Log("Outfit path " + path + " not found", Helpers.LogLevel.Error, Client);
-                    return false;
-                }
-            }
-            else
-                folder = (UUID)_folder;
-
-            wearables = new List<InventoryWearable>();
-            attachments = new List<InventoryBase>();
-            List<InventoryBase> objects = Client.Inventory.FolderContents(folder, Client.Self.AgentID,
-                false, true, InventorySortOrder.ByName, 1000 * 20);
-
-            if (objects != null)
-            {
-                foreach (InventoryBase ib in objects)
-                {
-                    if (ib is InventoryWearable)
-                    {
-                        Logger.DebugLog("Adding wearable " + ib.Name, Client);
-                        wearables.Add((InventoryWearable)ib);
-                    }
-                    else if (ib is InventoryAttachment)
-                    {
-                        Logger.DebugLog("Adding attachment (attachment) " + ib.Name, Client);
-                        attachments.Add(ib);
-                    }
-                    else if (ib is InventoryObject)
-                    {
-                        Logger.DebugLog("Adding attachment (object) " + ib.Name, Client);
-                        attachments.Add(ib);
-                    }
-                    else
-                    {
-                        Logger.DebugLog("Ignoring inventory item " + ib.Name, Client);
-                    }
-                }
-            }
-            else
-            {
-                Logger.Log("Failed to download folder contents of + " + folder.ToString(),
-                    Helpers.LogLevel.Error, Client);
-                return false;
-            }
-
-            return true;
-        }
-
-        // this method will download the assets for all inventory items in iws
-        private void ReplaceOutfitWearables(List<InventoryWearable> iws)
-        {
-            lock (Wearables.Dictionary)
-            {
-                Dictionary<WearableType, WearableData> preserve = new Dictionary<WearableType,WearableData>();
-                
-                foreach (KeyValuePair<WearableType,WearableData> kvp in Wearables.Dictionary)
-                {
-                    if (kvp.Value.Item.AssetType == AssetType.Bodypart)
-                            preserve.Add(kvp.Key, kvp.Value);
-                }
-
-                Wearables.Dictionary = preserve;
-            
-                foreach (InventoryWearable iw in iws)
-                {
-                    WearableData wd = new WearableData();
-                    wd.Item = iw; 
-                    Wearables.Dictionary[wd.Item.WearableType] = wd;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Adds a list of attachments to avatar
-        /// </summary>
-        /// <param name="attachments">A List containing the attachments to add</param>
-        /// <param name="removeExistingFirst">If true, tells simulator to remove existing attachment
-        /// first</param>
-        public void AddAttachments(List<InventoryBase> attachments, bool removeExistingFirst)
-        {
-            // FIXME: Obey this
-            //const int OBJECTS_PER_PACKET = 4;
-
-            // Use RezMultipleAttachmentsFromInv  to clear out current attachments, and attach new ones
-            RezMultipleAttachmentsFromInvPacket attachmentsPacket = new RezMultipleAttachmentsFromInvPacket();
-            attachmentsPacket.AgentData.AgentID = Client.Self.AgentID;
-            attachmentsPacket.AgentData.SessionID = Client.Self.SessionID;
-
-            attachmentsPacket.HeaderData.CompoundMsgID = UUID.Random();
-            attachmentsPacket.HeaderData.FirstDetachAll = removeExistingFirst;
-            attachmentsPacket.HeaderData.TotalObjects = (byte)attachments.Count;
-
-            attachmentsPacket.ObjectData = new RezMultipleAttachmentsFromInvPacket.ObjectDataBlock[attachments.Count];
-            for (int i = 0; i < attachments.Count; i++)
-            {
-                if (attachments[i] is InventoryAttachment)
-                {
-                    InventoryAttachment attachment = (InventoryAttachment)attachments[i];
-                    attachmentsPacket.ObjectData[i] = new RezMultipleAttachmentsFromInvPacket.ObjectDataBlock();
-                    attachmentsPacket.ObjectData[i].AttachmentPt = 0;
-                    attachmentsPacket.ObjectData[i].EveryoneMask = (uint)attachment.Permissions.EveryoneMask;
-                    attachmentsPacket.ObjectData[i].GroupMask = (uint)attachment.Permissions.GroupMask;
-                    attachmentsPacket.ObjectData[i].ItemFlags = (uint)attachment.Flags;
-                    attachmentsPacket.ObjectData[i].ItemID = attachment.UUID;
-                    attachmentsPacket.ObjectData[i].Name = Utils.StringToBytes(attachment.Name);
-                    attachmentsPacket.ObjectData[i].Description = Utils.StringToBytes(attachment.Description);
-                    attachmentsPacket.ObjectData[i].NextOwnerMask = (uint)attachment.Permissions.NextOwnerMask;
-                    attachmentsPacket.ObjectData[i].OwnerID = attachment.OwnerID;
-                }
-                else if (attachments[i] is InventoryObject)
-                {
-                    InventoryObject attachment = (InventoryObject)attachments[i];
-                    attachmentsPacket.ObjectData[i] = new RezMultipleAttachmentsFromInvPacket.ObjectDataBlock();
-                    attachmentsPacket.ObjectData[i].AttachmentPt = 0;
-                    attachmentsPacket.ObjectData[i].EveryoneMask = (uint)attachment.Permissions.EveryoneMask;
-                    attachmentsPacket.ObjectData[i].GroupMask = (uint)attachment.Permissions.GroupMask;
-                    attachmentsPacket.ObjectData[i].ItemFlags = (uint)attachment.Flags;
-                    attachmentsPacket.ObjectData[i].ItemID = attachment.UUID;
-                    attachmentsPacket.ObjectData[i].Name = Utils.StringToBytes(attachment.Name);
-                    attachmentsPacket.ObjectData[i].Description = Utils.StringToBytes(attachment.Description);
-                    attachmentsPacket.ObjectData[i].NextOwnerMask = (uint)attachment.Permissions.NextOwnerMask;
-                    attachmentsPacket.ObjectData[i].OwnerID = attachment.OwnerID;
-                }
-                else
-                {
-                    Logger.Log("Cannot attach inventory item of type " + attachments[i].GetType().ToString(),
-                        Helpers.LogLevel.Warning, Client);
-                }
-            }
-
-            Client.Network.SendPacket(attachmentsPacket);
-        }
-
-        /// <summary>
-        /// Attach an item to an avatar at a specific attach point
-        /// </summary>
-        /// <param name="item">A <seealso cref="OpenMetaverse.InventoryItem"/> to attach</param>
-        /// <param name="attachPoint">the <seealso cref="OpenMetaverse.AttachmentPoint"/> on the avatar 
-        /// to attach the item to</param>
-        public void Attach(InventoryItem item, AttachmentPoint attachPoint)
-        {
-            Attach(item.UUID, item.OwnerID, item.Name, item.Description, item.Permissions, item.Flags, 
-                attachPoint);
-        }
-
-        /// <summary>
-        /// Attach an item to an avatar specifying attachment details
-        /// </summary>
-        /// <param name="itemID">The <seealso cref="OpenMetaverse.UUID"/> of the item to attach</param>
-        /// <param name="ownerID">The <seealso cref="OpenMetaverse.UUID"/> attachments owner</param>
-        /// <param name="name">The name of the attachment</param>
-        /// <param name="description">The description of the attahment</param>
-        /// <param name="perms">The <seealso cref="OpenMetaverse.Permissions"/> to apply when attached</param>
-        /// <param name="itemFlags">The <seealso cref="OpenMetaverse.InventoryItemFlags"/> of the attachment</param>
-        /// <param name="attachPoint">the <seealso cref="OpenMetaverse.AttachmentPoint"/> on the avatar 
-        /// to attach the item to</param>
-        public void Attach(UUID itemID, UUID ownerID, string name, string description,
-            Permissions perms, uint itemFlags, AttachmentPoint attachPoint)
-        {
-            // TODO: At some point it might be beneficial to have AppearanceManager track what we
-            // are currently wearing for attachments to make enumeration and detachment easier
-
-            RezSingleAttachmentFromInvPacket attach = new RezSingleAttachmentFromInvPacket();
-
-            attach.AgentData.AgentID = Client.Self.AgentID;
-            attach.AgentData.SessionID = Client.Self.SessionID;
-
-            attach.ObjectData.AttachmentPt = (byte)attachPoint;
-            attach.ObjectData.Description = Utils.StringToBytes(description);
-            attach.ObjectData.EveryoneMask = (uint)perms.EveryoneMask;
-            attach.ObjectData.GroupMask = (uint)perms.GroupMask;
-            attach.ObjectData.ItemFlags = itemFlags;
-            attach.ObjectData.ItemID = itemID;
-            attach.ObjectData.Name = Utils.StringToBytes(name);
-            attach.ObjectData.NextOwnerMask = (uint)perms.NextOwnerMask;
-            attach.ObjectData.OwnerID = ownerID;
-
-            Client.Network.SendPacket(attach);
-        }
-
-        /// <summary>
-        /// Detach an item from avatar using an <seealso cref="OpenMetaverse.InventoryItem"/> object
-        /// </summary>
-        /// <param name="item">An <seealso cref="OpenMetaverse.InventoryItem"/> object</param>
-        public void Detach(InventoryItem item)
-        {
-            Detach(item.UUID); 
-        }
-
-        /// <summary>
-        /// Detach an Item from avatar by items <seealso cref="OpenMetaverse.UUID"/>
-        /// </summary>
-        /// <param name="itemID">The items ID to detach</param>
-        public void Detach(UUID itemID)
-        {
-            DetachAttachmentIntoInvPacket detach = new DetachAttachmentIntoInvPacket();
-            detach.ObjectData.AgentID = Client.Self.AgentID;
-            detach.ObjectData.ItemID = itemID;
-
-            Client.Network.SendPacket(detach);
-        }
-
-
-        private void UpdateAppearanceFromWearables(bool bake)
-        {
-            lock (AgentTextures)
-            {
-                for (int i = 0; i < AgentTextures.Length; i++)
-                    AgentTextures[i] = UUID.Zero;
-            }
-
-            // Register an asset download callback to get wearable data
-            AssetManager.AssetReceivedCallback assetCallback = new AssetManager.AssetReceivedCallback(Assets_OnAssetReceived);
-            AssetManager.ImageReceivedCallback imageCallback = new AssetManager.ImageReceivedCallback(Assets_OnImageReceived);
-            AssetManager.AssetUploadedCallback uploadCallback = new AssetManager.AssetUploadedCallback(Assets_OnAssetUploaded);
-            Assets.OnAssetReceived += assetCallback;
-            Assets.OnImageReceived += imageCallback;
-            Assets.OnAssetUploaded += uploadCallback;
-
-            // Download assets for what we are wearing and fill in AgentTextures
-            DownloadWearableAssets();
-            WearablesDownloadedEvent.WaitOne();
-
-            // Unregister the asset download callback
-            Assets.OnAssetReceived -= assetCallback;
-
-            // Check if anything needs to be rebaked
-            if (bake) RequestCachedBakes();
-
-            // Tell the sim what we are wearing
-            SendAgentIsNowWearing();
-
-            // Wait for cached layer check to finish
-            if (bake) CachedResponseEvent.WaitOne();
-
-            // Unregister the image download and asset upload callbacks
-            Assets.OnImageReceived -= imageCallback;
-            Assets.OnAssetUploaded -= uploadCallback;
-
-            Logger.DebugLog("CachedResponseEvent completed", Client);
-
-            #region Send Appearance
-
-            Primitive.TextureEntry te = null;
-
-            ObjectManager.NewAvatarCallback updateCallback =
-                delegate(Simulator simulator, Avatar avatar, ulong regionHandle, ushort timeDilation)
-                {
-                    if (avatar.LocalID == Client.Self.LocalID)
-                    {
-                        if (avatar.Textures.FaceTextures != null)
-                        {
-                            bool match = true;
-
-                            for (uint i = 0; i < AgentTextures.Length; i++)
-                            {
-                                Primitive.TextureEntryFace face = avatar.Textures.FaceTextures[i];
-
-                                if (face == null)
-                                {
-                                    // If the texture is UUID.Zero the face should be null
-                                    if (AgentTextures[i] != UUID.Zero)
-                                    {
-                                        match = false;
-                                        break;
-                                    }
-                                }
-                                else if (face.TextureID != AgentTextures[i])
-                                {
-                                    Logger.DebugLog("*** FACE is "+face.TextureID.ToString()+" Agent Texture is "+AgentTextures[i].ToString());
-                                    match = false;
-                                    //break;
-                                }
-                            }
-
-                            if (!match)
-                                Logger.Log("TextureEntry mismatch after updating our appearance", Helpers.LogLevel.Warning, Client);
-
-                            te = avatar.Textures;
-                            UpdateEvent.Set();
-                        }
-                        else
-                        {
-                            Logger.Log("Received an update for our avatar with a null FaceTextures array",
-                                Helpers.LogLevel.Warning, Client);
-                        }
-                    }
-                };
-            Client.Objects.OnNewAvatar += updateCallback;
-
-            // Send all of the visual params and textures for our agent
-            SendAgentSetAppearance();
-
-            // Wait for the ObjectUpdate to come in for our avatar after changing appearance
-            if (UpdateEvent.WaitOne(1000 * 60, false))
-            {
-                if (OnAppearanceUpdated != null)
-                {
-                    try { OnAppearanceUpdated(te); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-            }
-            else
-            {
-                Logger.Log("Timed out waiting for our appearance to update on the simulator", Helpers.LogLevel.Warning, Client);
-            }
-
-            Client.Objects.OnNewAvatar -= updateCallback;
-
-            #endregion Send Appearance
-        }
-
-        /// <summary>
-        /// Build hashes out of the texture assetIDs for each baking layer to
-        /// ask the simulator whether it has cached copies of each baked texture
-        /// </summary>
-        public void RequestCachedBakes()
-        {
-            Logger.DebugLog("RequestCachedBakes()", Client);
-            
-            List<KeyValuePair<int, UUID>> hashes = new List<KeyValuePair<int,UUID>>();
-
-            AgentCachedTexturePacket cache = new AgentCachedTexturePacket();
-            cache.AgentData.AgentID = Client.Self.AgentID;
-            cache.AgentData.SessionID = Client.Self.SessionID;
-            cache.AgentData.SerialNum = CacheCheckSerialNum;
-
-            // Build hashes for each of the bake layers from the individual components
-            for (int bakedIndex = 0; bakedIndex < BAKED_TEXTURE_COUNT; bakedIndex++)
-            {
-                // Don't do a cache request for a skirt bake if we're not wearing a skirt
-                if (bakedIndex == (int)BakeType.Skirt && 
-                    (!Wearables.ContainsKey(WearableType.Skirt) || Wearables.Dictionary[WearableType.Skirt].Asset.AssetID == UUID.Zero))
-                    continue;
-
-                UUID hash = new UUID();
-
-                for (int wearableIndex = 0; wearableIndex < WEARABLES_PER_LAYER; wearableIndex++)
-                {
-                    WearableType type = WEARABLE_BAKE_MAP[bakedIndex][wearableIndex];
-                    UUID assetID = GetWearableAsset(type);
-
-                    // Build a hash of all the texture asset IDs in this baking layer
-                    if (assetID != UUID.Zero) hash ^= assetID;
-                }
-
-                if (hash != UUID.Zero)
-                {
-                    // Hash with our secret value for this baked layer
-                    hash ^= BAKED_TEXTURE_HASH[bakedIndex];
-
-                    // Add this to the list of hashes to send out
-                    hashes.Add(new KeyValuePair<int, UUID>(bakedIndex, hash));
-                }
-            }
-
-            // Only send the packet out if there's something to check
-            if (hashes.Count > 0)
-            {
-                cache.WearableData = new AgentCachedTexturePacket.WearableDataBlock[hashes.Count];
-
-                for (int i = 0; i < hashes.Count; i++)
-                {
-                    cache.WearableData[i] = new AgentCachedTexturePacket.WearableDataBlock();
-                    cache.WearableData[i].TextureIndex = (byte)hashes[i].Key;
-                    cache.WearableData[i].ID = hashes[i].Value;
-
-                    Logger.DebugLog("Checking cache for index " + cache.WearableData[i].TextureIndex +
-                        ", ID: " + cache.WearableData[i].ID, Client);
-                }
-
-                // Increment our serial number for this packet
-                CacheCheckSerialNum++;
-
-                // Send it out
-                Client.Network.SendPacket(cache);
-            }
-        }
-
-        /// <summary>
-        /// Ask the server what textures our avatar is currently wearing
-        /// </summary>
-        public void SendAgentWearablesRequest()
-        {
-            AgentWearablesRequestPacket request = new AgentWearablesRequestPacket();
-            request.AgentData.AgentID = Client.Self.AgentID;
-            request.AgentData.SessionID = Client.Self.SessionID;
-
-            Client.Network.SendPacket(request);
-        }
-
-        private void AgentWearablesUpdateHandler(Packet packet, Simulator simulator)
-        {
-            // Lock to prevent a race condition with multiple AgentWearables packets
-            lock (WearablesRequestEvent)
-            {
-                AgentWearablesUpdatePacket update = (AgentWearablesUpdatePacket)packet;
-
-                // Reset the Wearables collection
-                lock (Wearables.Dictionary) Wearables.Dictionary.Clear();
-
-                for (int i = 0; i < update.WearableData.Length; i++)
-                {
-                    if (update.WearableData[i].AssetID != UUID.Zero)
-                    {
-                        WearableType type = (WearableType)update.WearableData[i].WearableType;
-                        WearableData data = new WearableData();
-                        data.Item = new InventoryWearable(update.WearableData[i].ItemID);
-                        data.Item.WearableType = type;
-                        data.Item.AssetType = WearableTypeToAssetType(type);
-                        data.Item.AssetUUID = update.WearableData[i].AssetID;
-
-                        // Add this wearable to our collection
-                        lock (Wearables.Dictionary) Wearables.Dictionary[type] = data;
-                    }
-                }
-            }
-
-            WearablesRequestEvent.Set();
-        }
-
-        private void SendAgentSetAppearance()
-        {
-            AgentSetAppearancePacket set = new AgentSetAppearancePacket();
-            set.AgentData.AgentID = Client.Self.AgentID;
-            set.AgentData.SessionID = Client.Self.SessionID;
-            set.AgentData.SerialNum = SetAppearanceSerialNum++;
-            set.VisualParam = new AgentSetAppearancePacket.VisualParamBlock[218];
-
-            float AgentSizeVPHeight = 0.0f;
-            float AgentSizeVPHeelHeight = 0.0f;
-            float AgentSizeVPPlatformHeight = 0.0f;
-            float AgentSizeVPHeadSize = 0.5f;
-            float AgentSizeVPLegLength = 0.0f;
-            float AgentSizeVPNeckLength = 0.0f;
-            float AgentSizeVPHipLength = 0.0f;
-
-            lock (Wearables.Dictionary)
-            {
-                // Only for debugging output
-                int count = 0, vpIndex = 0;
-
-                // Build the visual param array
-                foreach (KeyValuePair<int, VisualParam> kvp in VisualParams.Params)
-                {
-                    VisualParam vp = kvp.Value;
-
-                    // Only Group-0 parameters are sent in AgentSetAppearance packets
-                    if (vp.Group == 0)
-                    {
-                        set.VisualParam[vpIndex] = new AgentSetAppearancePacket.VisualParamBlock();
-
-                        // Try and find this value in our collection of downloaded wearables
-                        foreach (WearableData data in Wearables.Dictionary.Values)
-                        {
-                            if (data.Asset != null && data.Asset.Params.ContainsKey(vp.ParamID))
-                            {
-                                set.VisualParam[vpIndex].ParamValue = Utils.FloatToByte(data.Asset.Params[vp.ParamID], vp.MinValue, vp.MaxValue);
-                                count++;
-
-                                switch (vp.ParamID)
-                                {
-                                    case 33:
-                                        AgentSizeVPHeight = data.Asset.Params[vp.ParamID];
-                                        break;
-                                    case 198:
-                                        AgentSizeVPHeelHeight = data.Asset.Params[vp.ParamID];
-                                        break;
-                                    case 503:
-                                        AgentSizeVPPlatformHeight = data.Asset.Params[vp.ParamID];
-                                        break;
-                                    case 682:
-                                        AgentSizeVPHeadSize = data.Asset.Params[vp.ParamID];
-                                        break;
-                                    case 692:
-                                        AgentSizeVPLegLength = data.Asset.Params[vp.ParamID];
-                                        break;
-                                    case 756:
-                                        AgentSizeVPNeckLength = data.Asset.Params[vp.ParamID];
-                                        break;
-                                    case 842:
-                                        AgentSizeVPHipLength = data.Asset.Params[vp.ParamID];
-                                        break;
-                                }
-                                break;
-                            }
-                        }
-
-                        ++vpIndex;
-                    }
-                }
-
-                // Build the texture entry for our agent
-                Primitive.TextureEntry te = new Primitive.TextureEntry(DEFAULT_AVATAR_TEXTURE);
-
-                // Put our AgentTextures array in to TextureEntry
-                lock (AgentTextures)
-                {
-                    for (uint i = 0; i < AgentTextures.Length; i++)
-                    {
-                        if (AgentTextures[i] != UUID.Zero)
-                        {
-                            Primitive.TextureEntryFace face = te.CreateFace(i);
-                            face.TextureID = AgentTextures[i];
-                        }
-                    }
-                }
-
-                foreach (WearableData data in Wearables.Dictionary.Values)
-                {
-                    if (data.Asset != null)
-                    {
-                        foreach (KeyValuePair<TextureIndex, UUID> texture in data.Asset.Textures)
-                        {
-                            Primitive.TextureEntryFace face = te.CreateFace((uint)texture.Key);
-                            face.TextureID = texture.Value;
-
-                            Logger.DebugLog("Setting agent texture " + ((TextureIndex)texture.Key).ToString() + " to " +
-                                texture.Value.ToString(), Client);
-                        }
-                    }
-                }
-
-                // Set the packet TextureEntry
-                set.ObjectData.TextureEntry = te.ToBytes();
-            }
-
-            // FIXME: Our hackish algorithm is making squished avatars. See
-            // http://www.OpenMetaverse.org/wiki/Agent_Size for discussion of the correct algorithm
-            //float height = Utils.ByteToFloat(set.VisualParam[33].ParamValue, VisualParams.Params[33].MinValue,
-            //    VisualParams.Params[33].MaxValue);
-
-            // Takes into account the Shoe Heel/Platform offsets but not the Head Size Offset.  But seems to work.
-            double AgentSizeBase = 1.706;
-
-            // The calculation for the Head Size scalar may be incorrect.  But seems to work.
-            double AgentHeight = AgentSizeBase + (AgentSizeVPLegLength * .1918) + (AgentSizeVPHipLength * .0375) +
-                (AgentSizeVPHeight * .12022) + (AgentSizeVPHeadSize * .01117) + (AgentSizeVPNeckLength * .038) +
-                (AgentSizeVPHeelHeight * .08) + (AgentSizeVPPlatformHeight * .07);
-
-            set.AgentData.Size = new Vector3(0.45f, 0.6f, (float)AgentHeight);
-
-            // TODO: Account for not having all the textures baked yet
-            set.WearableData = new AgentSetAppearancePacket.WearableDataBlock[BAKED_TEXTURE_COUNT];
-
-            // Build hashes for each of the bake layers from the individual components
-            for (int bakedIndex = 0; bakedIndex < BAKED_TEXTURE_COUNT; bakedIndex++)
-            {
-                UUID hash = new UUID();
-
-                for (int wearableIndex = 0; wearableIndex < WEARABLES_PER_LAYER; wearableIndex++)
-                {
-                    WearableType type = WEARABLE_BAKE_MAP[bakedIndex][wearableIndex];
-                    UUID assetID = GetWearableAsset(type);
-
-                    // Build a hash of all the texture asset IDs in this baking layer
-                    if (assetID != UUID.Zero) hash ^= assetID;
-                }
-
-                if (hash != UUID.Zero)
-                {
-                    // Hash with our secret value for this baked layer
-                    hash ^= BAKED_TEXTURE_HASH[bakedIndex];
-                }
-
-                // Tell the server what cached texture assetID to use for each bake layer
-                set.WearableData[bakedIndex] = new AgentSetAppearancePacket.WearableDataBlock();
-                set.WearableData[bakedIndex].TextureIndex = (byte)bakedIndex;
-                set.WearableData[bakedIndex].CacheID = hash;
-            }
-
-            // Finally, send the packet
-            Client.Network.SendPacket(set);
-        }
-
-
-        private void SendAgentIsNowWearing()
-        {
-            Logger.DebugLog("SendAgentIsNowWearing()", Client);
-
-            AgentIsNowWearingPacket wearing = new AgentIsNowWearingPacket();
-            wearing.AgentData.AgentID = Client.Self.AgentID;
-            wearing.AgentData.SessionID = Client.Self.SessionID;
-            wearing.WearableData = new AgentIsNowWearingPacket.WearableDataBlock[WEARABLE_COUNT];
-
-            for (int i = 0; i < WEARABLE_COUNT; i++)
-            {
-                WearableType type = (WearableType)i;
-                wearing.WearableData[i] = new AgentIsNowWearingPacket.WearableDataBlock();
-                wearing.WearableData[i].WearableType = (byte)i;
-
-                if (Wearables.ContainsKey(type))
-                    wearing.WearableData[i].ItemID = Wearables.Dictionary[type].Item.UUID;
-                else
-                    wearing.WearableData[i].ItemID = UUID.Zero;
-            }
-
-            Client.Network.SendPacket(wearing);
-        }
-
-        private TextureIndex BakeTypeToAgentTextureIndex(BakeType index)
-        {
-            switch (index)
-            {
-                case BakeType.Head:
-                    return TextureIndex.HeadBaked;
-                case BakeType.UpperBody:
-                    return TextureIndex.UpperBaked;
-                case BakeType.LowerBody:
-                    return TextureIndex.LowerBaked;
-                case BakeType.Eyes:
-                    return TextureIndex.EyesBaked;
-                case BakeType.Skirt:
-                    return TextureIndex.SkirtBaked;
-                default:
-                    return TextureIndex.Unknown;
-            }
-        }
-
-        private void DownloadWearableAssets()
-        {
+            // Add the new items at the end, ReplaceOutfitWearables() will do the right thing as it places each warable into a slot in order
+            // so the end of the list will overwrite earlier parts if they use the same slot.
+            foreach (InventoryBase item in ibs_new)
+            {
+                if (item is InventoryWearable)
+                    ibs_total.Add(item);
+            }
+
+            WearParams wearParams = new WearParams(ibs_total, bake, false);
+            Thread appearanceThread = new Thread(new ParameterizedThreadStart(StartWearOutfit));
+            appearanceThread.Start(wearParams);
+        }
+
+        private void StartWearOutfit(object thread_params)
+        {
+            WearParams wearParams = (WearParams)thread_params;
+
+            List<InventoryBase> ibs = (List<InventoryBase>)wearParams.Param;
+            List<InventoryWearable> wearables = new List<InventoryWearable>();
+            List<InventoryBase> attachments = new List<InventoryBase>();
+
+            foreach (InventoryBase ib in ibs)
+            {
+                if (ib is InventoryWearable)
+                    wearables.Add((InventoryWearable)ib);
+                else if (ib is InventoryAttachment || ib is InventoryObject)
+                    attachments.Add(ib);
+            }
+
+
+            SendAgentWearablesRequest();
+            WearablesRequestEvent.WaitOne();
+            ReplaceOutfitWearables(wearables);
+            UpdateAppearanceFromWearables(wearParams.Bake);
+            AddAttachments(attachments, wearParams.Remove_Existing_Attachments);
+        }
+
+        /// <summary>
+        /// Replace the current outfit with a folder and set appearance
+        /// </summary>
+        /// <param name="folder">UUID of the inventory folder to wear</param>
+        public void WearOutfit(UUID folder)
+        {
+            WearOutfit(folder, true);
+        }
+
+        /// <summary>
+        /// Replace the current outfit with a folder and set appearance
+        /// </summary>
+        /// <param name="path">Inventory path of the folder to wear</param>
+        public void WearOutfit(string[] path)
+        {
+            WearOutfit(path, true);
+        }
+
+        /// <summary>
+        /// Replace the current outfit with a folder and set appearance
+        /// </summary>
+        /// <param name="folder">Folder containing the new outfit</param>
+        /// <param name="bake">Whether to bake the avatar textures or not</param>
+        public void WearOutfit(UUID folder, bool bake)
+        {
+            WearParams wearOutfitParams = new WearParams(folder, bake,true);
+            Thread appearanceThread = new Thread(new ParameterizedThreadStart(StartWearOutfitFolder));
+            appearanceThread.Start(wearOutfitParams);
+        }
+
+        /// <summary>
+        /// Replace the current outfit with a folder and set appearance
+        /// </summary>
+        /// <param name="path">Path of folder containing the new outfit</param>
+        /// <param name="bake">Whether to bake the avatar textures or not</param>
+        public void WearOutfit(string[] path, bool bake)
+        {
+            WearParams wearOutfitParams = new WearParams(path, bake,true);
+            Thread appearanceThread = new Thread(new ParameterizedThreadStart(StartWearOutfitFolder));
+            appearanceThread.Start(wearOutfitParams);
+        }
+
+        public void WearOutfit(InventoryFolder folder, bool bake)
+        {
+            WearParams wearOutfitParams = new WearParams(folder, bake,true);
+            Thread appearanceThread = new Thread(new ParameterizedThreadStart(StartWearOutfitFolder));
+            appearanceThread.Start(wearOutfitParams);
+        }
+
+        private void StartWearOutfitFolder(object thread_params)
+        {
+            WearParams wearOutfitParams = (WearParams)thread_params;
+
+            SendAgentWearablesRequest(); // request current wearables async
+            List<InventoryWearable> wearables;
+            List<InventoryBase> attachments;
+
+            if (!GetFolderWearables(wearOutfitParams.Param, out wearables, out attachments)) // get wearables in outfit folder
+                return; // TODO: this error condition should be passed back to the client somehow
+
+            WearablesRequestEvent.WaitOne(); // wait for current wearables
+            ReplaceOutfitWearables(wearables); // replace current wearables with outfit folder
+            UpdateAppearanceFromWearables(wearOutfitParams.Bake);
+            AddAttachments(attachments, wearOutfitParams.Remove_Existing_Attachments);
+        }
+
+        private bool GetFolderWearables(object _folder, out List<InventoryWearable> wearables, out List<InventoryBase> attachments)
+        {
+            UUID folder;
+            wearables = null;
+            attachments = null;
+
+            if (_folder.GetType() == typeof(string[]))
+            {
+                string[] path = (string[])_folder;
+
+                folder = Client.Inventory.FindObjectByPath(
+                    Client.Inventory.Store.RootFolder.UUID, Client.Self.AgentID, String.Join("/", path), 1000 * 20);
+
+                if (folder == UUID.Zero)
+                {
+                    Logger.Log("Outfit path " + path + " not found", Helpers.LogLevel.Error, Client);
+                    return false;
+                }
+            }
+            else
+                folder = (UUID)_folder;
+
+            wearables = new List<InventoryWearable>();
+            attachments = new List<InventoryBase>();
+            List<InventoryBase> objects = Client.Inventory.FolderContents(folder, Client.Self.AgentID,
+                false, true, InventorySortOrder.ByName, 1000 * 20);
+
+            if (objects != null)
+            {
+                foreach (InventoryBase ib in objects)
+                {
+                    if (ib is InventoryWearable)
+                    {
+                        Logger.DebugLog("Adding wearable " + ib.Name, Client);
+                        wearables.Add((InventoryWearable)ib);
+                    }
+                    else if (ib is InventoryAttachment)
+                    {
+                        Logger.DebugLog("Adding attachment (attachment) " + ib.Name, Client);
+                        attachments.Add(ib);
+                    }
+                    else if (ib is InventoryObject)
+                    {
+                        Logger.DebugLog("Adding attachment (object) " + ib.Name, Client);
+                        attachments.Add(ib);
+                    }
+                    else
+                    {
+                        Logger.DebugLog("Ignoring inventory item " + ib.Name, Client);
+                    }
+                }
+            }
+            else
+            {
+                Logger.Log("Failed to download folder contents of + " + folder.ToString(),
+                    Helpers.LogLevel.Error, Client);
+                return false;
+            }
+
+            return true;
+        }
+
+        // this method will download the assets for all inventory items in iws
+        private void ReplaceOutfitWearables(List<InventoryWearable> iws)
+        {
+            lock (Wearables.Dictionary)
+            {
+                Dictionary<WearableType, WearableData> preserve = new Dictionary<WearableType,WearableData>();
+                
+                foreach (KeyValuePair<WearableType,WearableData> kvp in Wearables.Dictionary)
+                {
+                    if (kvp.Value.Item.AssetType == AssetType.Bodypart)
+                            preserve.Add(kvp.Key, kvp.Value);
+                }
+
+                Wearables.Dictionary = preserve;
+            
+                foreach (InventoryWearable iw in iws)
+                {
+                    WearableData wd = new WearableData();
+                    wd.Item = iw; 
+                    Wearables.Dictionary[wd.Item.WearableType] = wd;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Adds a list of attachments to avatar
+        /// </summary>
+        /// <param name="attachments">A List containing the attachments to add</param>
+        /// <param name="removeExistingFirst">If true, tells simulator to remove existing attachment
+        /// first</param>
+        public void AddAttachments(List<InventoryBase> attachments, bool removeExistingFirst)
+        {
+            // FIXME: Obey this
+            //const int OBJECTS_PER_PACKET = 4;
+
+            // Use RezMultipleAttachmentsFromInv  to clear out current attachments, and attach new ones
+            RezMultipleAttachmentsFromInvPacket attachmentsPacket = new RezMultipleAttachmentsFromInvPacket();
+            attachmentsPacket.AgentData.AgentID = Client.Self.AgentID;
+            attachmentsPacket.AgentData.SessionID = Client.Self.SessionID;
+
+            attachmentsPacket.HeaderData.CompoundMsgID = UUID.Random();
+            attachmentsPacket.HeaderData.FirstDetachAll = removeExistingFirst;
+            attachmentsPacket.HeaderData.TotalObjects = (byte)attachments.Count;
+
+            attachmentsPacket.ObjectData = new RezMultipleAttachmentsFromInvPacket.ObjectDataBlock[attachments.Count];
+            for (int i = 0; i < attachments.Count; i++)
+            {
+                if (attachments[i] is InventoryAttachment)
+                {
+                    InventoryAttachment attachment = (InventoryAttachment)attachments[i];
+                    attachmentsPacket.ObjectData[i] = new RezMultipleAttachmentsFromInvPacket.ObjectDataBlock();
+                    attachmentsPacket.ObjectData[i].AttachmentPt = 0;
+                    attachmentsPacket.ObjectData[i].EveryoneMask = (uint)attachment.Permissions.EveryoneMask;
+                    attachmentsPacket.ObjectData[i].GroupMask = (uint)attachment.Permissions.GroupMask;
+                    attachmentsPacket.ObjectData[i].ItemFlags = (uint)attachment.Flags;
+                    attachmentsPacket.ObjectData[i].ItemID = attachment.UUID;
+                    attachmentsPacket.ObjectData[i].Name = Utils.StringToBytes(attachment.Name);
+                    attachmentsPacket.ObjectData[i].Description = Utils.StringToBytes(attachment.Description);
+                    attachmentsPacket.ObjectData[i].NextOwnerMask = (uint)attachment.Permissions.NextOwnerMask;
+                    attachmentsPacket.ObjectData[i].OwnerID = attachment.OwnerID;
+                }
+                else if (attachments[i] is InventoryObject)
+                {
+                    InventoryObject attachment = (InventoryObject)attachments[i];
+                    attachmentsPacket.ObjectData[i] = new RezMultipleAttachmentsFromInvPacket.ObjectDataBlock();
+                    attachmentsPacket.ObjectData[i].AttachmentPt = 0;
+                    attachmentsPacket.ObjectData[i].EveryoneMask = (uint)attachment.Permissions.EveryoneMask;
+                    attachmentsPacket.ObjectData[i].GroupMask = (uint)attachment.Permissions.GroupMask;
+                    attachmentsPacket.ObjectData[i].ItemFlags = (uint)attachment.Flags;
+                    attachmentsPacket.ObjectData[i].ItemID = attachment.UUID;
+                    attachmentsPacket.ObjectData[i].Name = Utils.StringToBytes(attachment.Name);
+                    attachmentsPacket.ObjectData[i].Description = Utils.StringToBytes(attachment.Description);
+                    attachmentsPacket.ObjectData[i].NextOwnerMask = (uint)attachment.Permissions.NextOwnerMask;
+                    attachmentsPacket.ObjectData[i].OwnerID = attachment.OwnerID;
+                }
+                else
+                {
+                    Logger.Log("Cannot attach inventory item of type " + attachments[i].GetType().ToString(),
+                        Helpers.LogLevel.Warning, Client);
+                }
+            }
+
+            Client.Network.SendPacket(attachmentsPacket);
+        }
+
+        /// <summary>
+        /// Attach an item to an avatar at a specific attach point
+        /// </summary>
+        /// <param name="item">A <seealso cref="OpenMetaverse.InventoryItem"/> to attach</param>
+        /// <param name="attachPoint">the <seealso cref="OpenMetaverse.AttachmentPoint"/> on the avatar 
+        /// to attach the item to</param>
+        public void Attach(InventoryItem item, AttachmentPoint attachPoint)
+        {
+            Attach(item.UUID, item.OwnerID, item.Name, item.Description, item.Permissions, item.Flags, 
+                attachPoint);
+        }
+
+        /// <summary>
+        /// Attach an item to an avatar specifying attachment details
+        /// </summary>
+        /// <param name="itemID">The <seealso cref="OpenMetaverse.UUID"/> of the item to attach</param>
+        /// <param name="ownerID">The <seealso cref="OpenMetaverse.UUID"/> attachments owner</param>
+        /// <param name="name">The name of the attachment</param>
+        /// <param name="description">The description of the attahment</param>
+        /// <param name="perms">The <seealso cref="OpenMetaverse.Permissions"/> to apply when attached</param>
+        /// <param name="itemFlags">The <seealso cref="OpenMetaverse.InventoryItemFlags"/> of the attachment</param>
+        /// <param name="attachPoint">the <seealso cref="OpenMetaverse.AttachmentPoint"/> on the avatar 
+        /// to attach the item to</param>
+        public void Attach(UUID itemID, UUID ownerID, string name, string description,
+            Permissions perms, uint itemFlags, AttachmentPoint attachPoint)
+        {
+            // TODO: At some point it might be beneficial to have AppearanceManager track what we
+            // are currently wearing for attachments to make enumeration and detachment easier
+
+            RezSingleAttachmentFromInvPacket attach = new RezSingleAttachmentFromInvPacket();
+
+            attach.AgentData.AgentID = Client.Self.AgentID;
+            attach.AgentData.SessionID = Client.Self.SessionID;
+
+            attach.ObjectData.AttachmentPt = (byte)attachPoint;
+            attach.ObjectData.Description = Utils.StringToBytes(description);
+            attach.ObjectData.EveryoneMask = (uint)perms.EveryoneMask;
+            attach.ObjectData.GroupMask = (uint)perms.GroupMask;
+            attach.ObjectData.ItemFlags = itemFlags;
+            attach.ObjectData.ItemID = itemID;
+            attach.ObjectData.Name = Utils.StringToBytes(name);
+            attach.ObjectData.NextOwnerMask = (uint)perms.NextOwnerMask;
+            attach.ObjectData.OwnerID = ownerID;
+
+            Client.Network.SendPacket(attach);
+        }
+
+        /// <summary>
+        /// Detach an item from avatar using an <seealso cref="OpenMetaverse.InventoryItem"/> object
+        /// </summary>
+        /// <param name="item">An <seealso cref="OpenMetaverse.InventoryItem"/> object</param>
+        public void Detach(InventoryItem item)
+        {
+            Detach(item.UUID); 
+        }
+
+        /// <summary>
+        /// Detach an Item from avatar by items <seealso cref="OpenMetaverse.UUID"/>
+        /// </summary>
+        /// <param name="itemID">The items ID to detach</param>
+        public void Detach(UUID itemID)
+        {
+            DetachAttachmentIntoInvPacket detach = new DetachAttachmentIntoInvPacket();
+            detach.ObjectData.AgentID = Client.Self.AgentID;
+            detach.ObjectData.ItemID = itemID;
+
+            Client.Network.SendPacket(detach);
+        }
+
+
+        private void UpdateAppearanceFromWearables(bool bake)
+        {
+            lock (AgentTextures)
+            {
+                for (int i = 0; i < AgentTextures.Length; i++)
+                    AgentTextures[i] = UUID.Zero;
+            }
+
+            // Register an asset download callback to get wearable data
+            AssetManager.AssetReceivedCallback assetCallback = new AssetManager.AssetReceivedCallback(Assets_OnAssetReceived);
+            AssetManager.ImageReceivedCallback imageCallback = new AssetManager.ImageReceivedCallback(Assets_OnImageReceived);
+            AssetManager.AssetUploadedCallback uploadCallback = new AssetManager.AssetUploadedCallback(Assets_OnAssetUploaded);
+            Assets.OnAssetReceived += assetCallback;
+            Assets.OnImageReceived += imageCallback;
+            Assets.OnAssetUploaded += uploadCallback;
+
+            // Download assets for what we are wearing and fill in AgentTextures
+            DownloadWearableAssets();
+            WearablesDownloadedEvent.WaitOne();
+
+            // Unregister the asset download callback
+            Assets.OnAssetReceived -= assetCallback;
+
+            // Check if anything needs to be rebaked
+            if (bake) RequestCachedBakes();
+
+            // Tell the sim what we are wearing
+            SendAgentIsNowWearing();
+
+            // Wait for cached layer check to finish
+            if (bake) CachedResponseEvent.WaitOne();
+
+            // Unregister the image download and asset upload callbacks
+            Assets.OnImageReceived -= imageCallback;
+            Assets.OnAssetUploaded -= uploadCallback;
+
+            Logger.DebugLog("CachedResponseEvent completed", Client);
+
+            #region Send Appearance
+
+            Primitive.TextureEntry te = null;
+
+            ObjectManager.NewAvatarCallback updateCallback =
+                delegate(Simulator simulator, Avatar avatar, ulong regionHandle, ushort timeDilation)
+                {
+                    if (avatar.LocalID == Client.Self.LocalID)
+                    {
+                        if (avatar.Textures.FaceTextures != null)
+                        {
+                            bool match = true;
+
+                            for (uint i = 0; i < AgentTextures.Length; i++)
+                            {
+                                Primitive.TextureEntryFace face = avatar.Textures.FaceTextures[i];
+
+                                if (face == null)
+                                {
+                                    // If the texture is UUID.Zero the face should be null
+                                    if (AgentTextures[i] != UUID.Zero)
+                                    {
+                                        match = false;
+                                        break;
+                                    }
+                                }
+                                else if (face.TextureID != AgentTextures[i])
+                                {
+                                    Logger.DebugLog("*** FACE is "+face.TextureID.ToString()+" Agent Texture is "+AgentTextures[i].ToString());
+                                    match = false;
+                                    //break;
+                                }
+                            }
+
+                            if (!match)
+                                Logger.Log("TextureEntry mismatch after updating our appearance", Helpers.LogLevel.Warning, Client);
+
+                            te = avatar.Textures;
+                            UpdateEvent.Set();
+                        }
+                        else
+                        {
+                            Logger.Log("Received an update for our avatar with a null FaceTextures array",
+                                Helpers.LogLevel.Warning, Client);
+                        }
+                    }
+                };
+            Client.Objects.OnNewAvatar += updateCallback;
+
+            // Send all of the visual params and textures for our agent
+            SendAgentSetAppearance();
+
+            // Wait for the ObjectUpdate to come in for our avatar after changing appearance
+            if (UpdateEvent.WaitOne(1000 * 60, false))
+            {
+                if (OnAppearanceUpdated != null)
+                {
+                    try { OnAppearanceUpdated(te); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+            }
+            else
+            {
+                Logger.Log("Timed out waiting for our appearance to update on the simulator", Helpers.LogLevel.Warning, Client);
+            }
+
+            Client.Objects.OnNewAvatar -= updateCallback;
+
+            #endregion Send Appearance
+        }
+
+        /// <summary>
+        /// Build hashes out of the texture assetIDs for each baking layer to
+        /// ask the simulator whether it has cached copies of each baked texture
+        /// </summary>
+        public void RequestCachedBakes()
+        {
+            Logger.DebugLog("RequestCachedBakes()", Client);
+            
+            List<KeyValuePair<int, UUID>> hashes = new List<KeyValuePair<int,UUID>>();
+
+            AgentCachedTexturePacket cache = new AgentCachedTexturePacket();
+            cache.AgentData.AgentID = Client.Self.AgentID;
+            cache.AgentData.SessionID = Client.Self.SessionID;
+            cache.AgentData.SerialNum = CacheCheckSerialNum;
+
+            // Build hashes for each of the bake layers from the individual components
+            for (int bakedIndex = 0; bakedIndex < BAKED_TEXTURE_COUNT; bakedIndex++)
+            {
+                // Don't do a cache request for a skirt bake if we're not wearing a skirt
+                if (bakedIndex == (int)BakeType.Skirt && 
+                    (!Wearables.ContainsKey(WearableType.Skirt) || Wearables.Dictionary[WearableType.Skirt].Asset.AssetID == UUID.Zero))
+                    continue;
+
+                UUID hash = new UUID();
+
+                for (int wearableIndex = 0; wearableIndex < WEARABLES_PER_LAYER; wearableIndex++)
+                {
+                    WearableType type = WEARABLE_BAKE_MAP[bakedIndex][wearableIndex];
+                    UUID assetID = GetWearableAsset(type);
+
+                    // Build a hash of all the texture asset IDs in this baking layer
+                    if (assetID != UUID.Zero) hash ^= assetID;
+                }
+
+                if (hash != UUID.Zero)
+                {
+                    // Hash with our secret value for this baked layer
+                    hash ^= BAKED_TEXTURE_HASH[bakedIndex];
+
+                    // Add this to the list of hashes to send out
+                    hashes.Add(new KeyValuePair<int, UUID>(bakedIndex, hash));
+                }
+            }
+
+            // Only send the packet out if there's something to check
+            if (hashes.Count > 0)
+            {
+                cache.WearableData = new AgentCachedTexturePacket.WearableDataBlock[hashes.Count];
+
+                for (int i = 0; i < hashes.Count; i++)
+                {
+                    cache.WearableData[i] = new AgentCachedTexturePacket.WearableDataBlock();
+                    cache.WearableData[i].TextureIndex = (byte)hashes[i].Key;
+                    cache.WearableData[i].ID = hashes[i].Value;
+
+                    Logger.DebugLog("Checking cache for index " + cache.WearableData[i].TextureIndex +
+                        ", ID: " + cache.WearableData[i].ID, Client);
+                }
+
+                // Increment our serial number for this packet
+                CacheCheckSerialNum++;
+
+                // Send it out
+                Client.Network.SendPacket(cache);
+            }
+        }
+
+        /// <summary>
+        /// Ask the server what textures our avatar is currently wearing
+        /// </summary>
+        public void SendAgentWearablesRequest()
+        {
+            AgentWearablesRequestPacket request = new AgentWearablesRequestPacket();
+            request.AgentData.AgentID = Client.Self.AgentID;
+            request.AgentData.SessionID = Client.Self.SessionID;
+
+            Client.Network.SendPacket(request);
+        }
+
+        private void AgentWearablesUpdateHandler(Packet packet, Simulator simulator)
+        {
+            // Lock to prevent a race condition with multiple AgentWearables packets
+            lock (WearablesRequestEvent)
+            {
+                AgentWearablesUpdatePacket update = (AgentWearablesUpdatePacket)packet;
+
+                // Reset the Wearables collection
+                lock (Wearables.Dictionary) Wearables.Dictionary.Clear();
+
+                for (int i = 0; i < update.WearableData.Length; i++)
+                {
+                    if (update.WearableData[i].AssetID != UUID.Zero)
+                    {
+                        WearableType type = (WearableType)update.WearableData[i].WearableType;
+                        WearableData data = new WearableData();
+                        data.Item = new InventoryWearable(update.WearableData[i].ItemID);
+                        data.Item.WearableType = type;
+                        data.Item.AssetType = WearableTypeToAssetType(type);
+                        data.Item.AssetUUID = update.WearableData[i].AssetID;
+
+                        // Add this wearable to our collection
+                        lock (Wearables.Dictionary) Wearables.Dictionary[type] = data;
+                    }
+                }
+            }
+
+            WearablesRequestEvent.Set();
+        }
+
+        private void SendAgentSetAppearance()
+        {
+            AgentSetAppearancePacket set = new AgentSetAppearancePacket();
+            set.AgentData.AgentID = Client.Self.AgentID;
+            set.AgentData.SessionID = Client.Self.SessionID;
+            set.AgentData.SerialNum = SetAppearanceSerialNum++;
+            set.VisualParam = new AgentSetAppearancePacket.VisualParamBlock[218];
+
+            float AgentSizeVPHeight = 0.0f;
+            float AgentSizeVPHeelHeight = 0.0f;
+            float AgentSizeVPPlatformHeight = 0.0f;
+            float AgentSizeVPHeadSize = 0.5f;
+            float AgentSizeVPLegLength = 0.0f;
+            float AgentSizeVPNeckLength = 0.0f;
+            float AgentSizeVPHipLength = 0.0f;
+
+            lock (Wearables.Dictionary)
+            {
+                // Only for debugging output
+                int count = 0, vpIndex = 0;
+
+                // Build the visual param array
+                foreach (KeyValuePair<int, VisualParam> kvp in VisualParams.Params)
+                {
+                    VisualParam vp = kvp.Value;
+
+                    // Only Group-0 parameters are sent in AgentSetAppearance packets
+                    if (vp.Group == 0)
+                    {
+                        set.VisualParam[vpIndex] = new AgentSetAppearancePacket.VisualParamBlock();
+
+                        // Try and find this value in our collection of downloaded wearables
+                        foreach (WearableData data in Wearables.Dictionary.Values)
+                        {
+                            if (data.Asset != null && data.Asset.Params.ContainsKey(vp.ParamID))
+                            {
+                                set.VisualParam[vpIndex].ParamValue = Utils.FloatToByte(data.Asset.Params[vp.ParamID], vp.MinValue, vp.MaxValue);
+                                count++;
+
+                                switch (vp.ParamID)
+                                {
+                                    case 33:
+                                        AgentSizeVPHeight = data.Asset.Params[vp.ParamID];
+                                        break;
+                                    case 198:
+                                        AgentSizeVPHeelHeight = data.Asset.Params[vp.ParamID];
+                                        break;
+                                    case 503:
+                                        AgentSizeVPPlatformHeight = data.Asset.Params[vp.ParamID];
+                                        break;
+                                    case 682:
+                                        AgentSizeVPHeadSize = data.Asset.Params[vp.ParamID];
+                                        break;
+                                    case 692:
+                                        AgentSizeVPLegLength = data.Asset.Params[vp.ParamID];
+                                        break;
+                                    case 756:
+                                        AgentSizeVPNeckLength = data.Asset.Params[vp.ParamID];
+                                        break;
+                                    case 842:
+                                        AgentSizeVPHipLength = data.Asset.Params[vp.ParamID];
+                                        break;
+                                }
+                                break;
+                            }
+                        }
+
+                        ++vpIndex;
+                    }
+                }
+
+                // Build the texture entry for our agent
+                Primitive.TextureEntry te = new Primitive.TextureEntry(DEFAULT_AVATAR_TEXTURE);
+
+                // Put our AgentTextures array in to TextureEntry
+                lock (AgentTextures)
+                {
+                    for (uint i = 0; i < AgentTextures.Length; i++)
+                    {
+                        if (AgentTextures[i] != UUID.Zero)
+                        {
+                            Primitive.TextureEntryFace face = te.CreateFace(i);
+                            face.TextureID = AgentTextures[i];
+                        }
+                    }
+                }
+
+                foreach (WearableData data in Wearables.Dictionary.Values)
+                {
+                    if (data.Asset != null)
+                    {
+                        foreach (KeyValuePair<TextureIndex, UUID> texture in data.Asset.Textures)
+                        {
+                            Primitive.TextureEntryFace face = te.CreateFace((uint)texture.Key);
+                            face.TextureID = texture.Value;
+
+                            Logger.DebugLog("Setting agent texture " + ((TextureIndex)texture.Key).ToString() + " to " +
+                                texture.Value.ToString(), Client);
+                        }
+                    }
+                }
+
+                // Set the packet TextureEntry
+                set.ObjectData.TextureEntry = te.ToBytes();
+            }
+
+            // FIXME: Our hackish algorithm is making squished avatars. See
+            // http://www.OpenMetaverse.org/wiki/Agent_Size for discussion of the correct algorithm
+            //float height = Utils.ByteToFloat(set.VisualParam[33].ParamValue, VisualParams.Params[33].MinValue,
+            //    VisualParams.Params[33].MaxValue);
+
+            // Takes into account the Shoe Heel/Platform offsets but not the Head Size Offset.  But seems to work.
+            double AgentSizeBase = 1.706;
+
+            // The calculation for the Head Size scalar may be incorrect.  But seems to work.
+            double AgentHeight = AgentSizeBase + (AgentSizeVPLegLength * .1918) + (AgentSizeVPHipLength * .0375) +
+                (AgentSizeVPHeight * .12022) + (AgentSizeVPHeadSize * .01117) + (AgentSizeVPNeckLength * .038) +
+                (AgentSizeVPHeelHeight * .08) + (AgentSizeVPPlatformHeight * .07);
+
+            set.AgentData.Size = new Vector3(0.45f, 0.6f, (float)AgentHeight);
+
+            // TODO: Account for not having all the textures baked yet
+            set.WearableData = new AgentSetAppearancePacket.WearableDataBlock[BAKED_TEXTURE_COUNT];
+
+            // Build hashes for each of the bake layers from the individual components
+            for (int bakedIndex = 0; bakedIndex < BAKED_TEXTURE_COUNT; bakedIndex++)
+            {
+                UUID hash = new UUID();
+
+                for (int wearableIndex = 0; wearableIndex < WEARABLES_PER_LAYER; wearableIndex++)
+                {
+                    WearableType type = WEARABLE_BAKE_MAP[bakedIndex][wearableIndex];
+                    UUID assetID = GetWearableAsset(type);
+
+                    // Build a hash of all the texture asset IDs in this baking layer
+                    if (assetID != UUID.Zero) hash ^= assetID;
+                }
+
+                if (hash != UUID.Zero)
+                {
+                    // Hash with our secret value for this baked layer
+                    hash ^= BAKED_TEXTURE_HASH[bakedIndex];
+                }
+
+                // Tell the server what cached texture assetID to use for each bake layer
+                set.WearableData[bakedIndex] = new AgentSetAppearancePacket.WearableDataBlock();
+                set.WearableData[bakedIndex].TextureIndex = (byte)bakedIndex;
+                set.WearableData[bakedIndex].CacheID = hash;
+            }
+
+            // Finally, send the packet
+            Client.Network.SendPacket(set);
+        }
+
+
+        private void SendAgentIsNowWearing()
+        {
+            Logger.DebugLog("SendAgentIsNowWearing()", Client);
+
+            AgentIsNowWearingPacket wearing = new AgentIsNowWearingPacket();
+            wearing.AgentData.AgentID = Client.Self.AgentID;
+            wearing.AgentData.SessionID = Client.Self.SessionID;
+            wearing.WearableData = new AgentIsNowWearingPacket.WearableDataBlock[WEARABLE_COUNT];
+
+            for (int i = 0; i < WEARABLE_COUNT; i++)
+            {
+                WearableType type = (WearableType)i;
+                wearing.WearableData[i] = new AgentIsNowWearingPacket.WearableDataBlock();
+                wearing.WearableData[i].WearableType = (byte)i;
+
+                if (Wearables.ContainsKey(type))
+                    wearing.WearableData[i].ItemID = Wearables.Dictionary[type].Item.UUID;
+                else
+                    wearing.WearableData[i].ItemID = UUID.Zero;
+            }
+
+            Client.Network.SendPacket(wearing);
+        }
+
+        private TextureIndex BakeTypeToAgentTextureIndex(BakeType index)
+        {
+            switch (index)
+            {
+                case BakeType.Head:
+                    return TextureIndex.HeadBaked;
+                case BakeType.UpperBody:
+                    return TextureIndex.UpperBaked;
+                case BakeType.LowerBody:
+                    return TextureIndex.LowerBaked;
+                case BakeType.Eyes:
+                    return TextureIndex.EyesBaked;
+                case BakeType.Skirt:
+                    return TextureIndex.SkirtBaked;
+                default:
+                    return TextureIndex.Unknown;
+            }
+        }
+
+        private void DownloadWearableAssets()
+        {
             lock(Wearables.Dictionary)
             {
-                foreach (KeyValuePair<WearableType, WearableData> kvp in Wearables.Dictionary)
-                {
-                    Logger.DebugLog("Requesting asset for wearable item " + kvp.Value.Item.WearableType + " (" + kvp.Value.Item.AssetUUID + ")", Client);
-                    AssetDownloads.Enqueue(new PendingAssetDownload(kvp.Value.Item.AssetUUID, kvp.Value.Item.AssetType));
+                foreach (KeyValuePair<WearableType, WearableData> kvp in Wearables.Dictionary)
+                {
+                    Logger.DebugLog("Requesting asset for wearable item " + kvp.Value.Item.WearableType + " (" + kvp.Value.Item.AssetUUID + ")", Client);
+                    AssetDownloads.Enqueue(new PendingAssetDownload(kvp.Value.Item.AssetUUID, kvp.Value.Item.AssetType));
                 }
-            }
-
-            if (AssetDownloads.Count > 0)
-            {
-                PendingAssetDownload pad = AssetDownloads.Dequeue();
-                Assets.RequestAsset(pad.Id, pad.Type, true);
-            }
-        }
-
-        private void UploadBake(Baker bake)
-        {
-            lock (PendingUploads)
-            {
-                if(PendingUploads.ContainsKey(bake.BakedTexture.AssetID))
-                {
-                    Logger.Log("UploadBake(): Skipping Asset id "+bake.BakedTexture.AssetID.ToString()+" Already in progress",Helpers.LogLevel.Info, Client);
-                    return;
-                }
-
-                    // Upload the completed layer data and Add it to a pending uploads list
-                    UUID id=Assets.RequestUpload(bake.BakedTexture, true);
-                    PendingUploads.Add(UUID.Combine(id, Client.Self.SecureSessionID), BakeTypeToAgentTextureIndex(bake.BakeType));
-            }
-
-            Logger.DebugLog(String.Format("Bake {0} completed. Uploading asset {1}", bake.BakeType,
-                bake.BakedTexture.AssetID.ToString()), Client);
-
-        }
-
-        private int AddImageDownload(TextureIndex index)
-        {
-            UUID image = AgentTextures[(int)index];
-
-            if (image != UUID.Zero)
-            {
-                if (!ImageDownloads.ContainsKey(image))
-                {
-                    Logger.DebugLog("Downloading layer " + index.ToString(), Client);
-                    ImageDownloads.Add(image, index);
-                }
-
-                return 1;
-            }
-
-            return 0;
-        }
-
-        #region Callbacks
-
-        private void AgentCachedTextureResponseHandler(Packet packet, Simulator simulator)
-        {
-            Logger.DebugLog("AgentCachedTextureResponseHandler()", Client);
-            
-            AgentCachedTextureResponsePacket response = (AgentCachedTextureResponsePacket)packet;
-            Dictionary<int, float> paramValues = new Dictionary<int, float>(VisualParams.Params.Count);
-
+            }
+
+            if (AssetDownloads.Count > 0)
+            {
+                PendingAssetDownload pad = AssetDownloads.Dequeue();
+                Assets.RequestAsset(pad.Id, pad.Type, true);
+            }
+        }
+
+        private void UploadBake(Baker bake)
+        {
+            lock (PendingUploads)
+            {
+                if(PendingUploads.ContainsKey(bake.BakedTexture.AssetID))
+                {
+                    Logger.Log("UploadBake(): Skipping Asset id "+bake.BakedTexture.AssetID.ToString()+" Already in progress",Helpers.LogLevel.Info, Client);
+                    return;
+                }
+
+                    // Upload the completed layer data and Add it to a pending uploads list
+                    UUID id=Assets.RequestUpload(bake.BakedTexture, true);
+                    PendingUploads.Add(UUID.Combine(id, Client.Self.SecureSessionID), BakeTypeToAgentTextureIndex(bake.BakeType));
+            }
+
+            Logger.DebugLog(String.Format("Bake {0} completed. Uploading asset {1}", bake.BakeType,
+                bake.BakedTexture.AssetID.ToString()), Client);
+
+        }
+
+        private int AddImageDownload(TextureIndex index)
+        {
+            UUID image = AgentTextures[(int)index];
+
+            if (image != UUID.Zero)
+            {
+                if (!ImageDownloads.ContainsKey(image))
+                {
+                    Logger.DebugLog("Downloading layer " + index.ToString(), Client);
+                    ImageDownloads.Add(image, index);
+                }
+
+                return 1;
+            }
+
+            return 0;
+        }
+
+        #region Callbacks
+
+        private void AgentCachedTextureResponseHandler(Packet packet, Simulator simulator)
+        {
+            Logger.DebugLog("AgentCachedTextureResponseHandler()", Client);
+            
+            AgentCachedTextureResponsePacket response = (AgentCachedTextureResponsePacket)packet;
+            Dictionary<int, float> paramValues = new Dictionary<int, float>(VisualParams.Params.Count);
+
 	    lock(Wearables.Dictionary)
 	    {
-                // Build a dictionary of appearance parameter indices and values from the wearables
-                foreach (KeyValuePair<int,VisualParam> kvp in VisualParams.Params)
-                {
-                    // Only Group-0 parameters are sent in AgentSetAppearance packets
-                    if (kvp.Value.Group == 0)
-                    {
-                        bool found = false;
-                        VisualParam vp = kvp.Value;
-
-                        // Try and find this value in our collection of downloaded wearables
-                        foreach (WearableData data in Wearables.Dictionary.Values)
-                        {
-                            if (data.Asset.Params.ContainsKey(vp.ParamID))
-                            {
-                                paramValues.Add(vp.ParamID, data.Asset.Params[vp.ParamID]);
-                                found = true;
-                                break;
-                            }
-                        }
-
-                        // Use a default value if we don't have one set for it
-                        if (!found) paramValues.Add(vp.ParamID, vp.DefaultValue);
-                    }
-                }
+                // Build a dictionary of appearance parameter indices and values from the wearables
+                foreach (KeyValuePair<int,VisualParam> kvp in VisualParams.Params)
+                {
+                    // Only Group-0 parameters are sent in AgentSetAppearance packets
+                    if (kvp.Value.Group == 0)
+                    {
+                        bool found = false;
+                        VisualParam vp = kvp.Value;
+
+                        // Try and find this value in our collection of downloaded wearables
+                        foreach (WearableData data in Wearables.Dictionary.Values)
+                        {
+                            if (data.Asset.Params.ContainsKey(vp.ParamID))
+                            {
+                                paramValues.Add(vp.ParamID, data.Asset.Params[vp.ParamID]);
+                                found = true;
+                                break;
+                            }
+                        }
+
+                        // Use a default value if we don't have one set for it
+                        if (!found) paramValues.Add(vp.ParamID, vp.DefaultValue);
+                    }
+                }
             }
-            lock (AgentTextures)
-            {
-                //If we are here then the user has tried to wear stuff or we are at login
-                // In either case the existing uploads of this class are very shortly going to be no good
-                PendingUploads.Clear();
-
-                foreach (AgentCachedTextureResponsePacket.WearableDataBlock block in response.WearableData)
-                {
-                    //UUID hash=new UUID();
-                    // For each missing element we need to bake our own texture
-                    Logger.DebugLog("Cache response, index: " + block.TextureIndex + ", ID: " +
-                        block.TextureID.ToString(), Client);
-
-                    // FIXME: Use this. Right now we treat baked images on other sims as if they were missing
-                    string host = Utils.BytesToString(block.HostName);
-                    if (host.Length > 0) Logger.DebugLog("Cached bake exists on foreign host " + host, Client);
-
-                    BakeType bakeType = (BakeType)block.TextureIndex;
-                    
-                    // Note, still should handle block.TextureID != UUID.Zero && host.Length == 0
-                    // Not sure what we should do as yet with that.
-
-                    // Convert the baked index to an AgentTexture index
-                    if (block.TextureID != UUID.Zero && host.Length != 0)
-                    {
-                        TextureIndex index = BakeTypeToAgentTextureIndex(bakeType);
-                        AgentTextures[(int)index] = block.TextureID;
-                    }
-                    else
-                    {
-                        int imageCount = 0;
-
-                        // Download all of the images in this layer
-                        switch (bakeType)
-                        {
-                            case BakeType.Head:
-                                lock (ImageDownloads)
-                                {
-                                    imageCount += AddImageDownload(TextureIndex.HeadBodypaint);
-                                    //imageCount += AddImageDownload(TextureIndex.Hair);
-                                }
-                                break;
-                            case BakeType.UpperBody:
-                                lock (ImageDownloads)
-                                {
-                                    imageCount += AddImageDownload(TextureIndex.UpperBodypaint);
-                                    imageCount += AddImageDownload(TextureIndex.UpperGloves);
-                                    imageCount += AddImageDownload(TextureIndex.UpperUndershirt);
-                                    imageCount += AddImageDownload(TextureIndex.UpperShirt);
-                                    imageCount += AddImageDownload(TextureIndex.UpperJacket);
-                                }
-                                break;
-                            case BakeType.LowerBody:
-                                lock (ImageDownloads)
-                                {
-                                    imageCount += AddImageDownload(TextureIndex.LowerBodypaint);
-                                    imageCount += AddImageDownload(TextureIndex.LowerUnderpants);
-                                    imageCount += AddImageDownload(TextureIndex.LowerSocks);
-                                    imageCount += AddImageDownload(TextureIndex.LowerShoes);
-                                    imageCount += AddImageDownload(TextureIndex.LowerPants);
-                                    imageCount += AddImageDownload(TextureIndex.LowerJacket);
-                                }
-                                break;
-                            case BakeType.Eyes:
-                                lock (ImageDownloads)
-                                {
-                                    imageCount += AddImageDownload(TextureIndex.EyesIris);
-                                }
-                                break;
-                            case BakeType.Skirt:
-                                if (Wearables.ContainsKey(WearableType.Skirt))
-                                {
-                                    lock (ImageDownloads)
-                                    {
-                                        imageCount += AddImageDownload(TextureIndex.Skirt);
-                                    }
-                                }
-                                break;
-                            default:
-                                Logger.Log("Unknown BakeType " + block.TextureIndex, Helpers.LogLevel.Warning, Client);
-                                break;
-                        }
-
-                        if (!PendingBakes.ContainsKey(bakeType))
-                        {
-                            Logger.DebugLog("Initializing " + bakeType.ToString() + " bake with " + imageCount + " textures", Client);
-
-                            if (imageCount == 0)
-                            {
-                                // if there are no textures to download, we can bake right away and start the upload
-                                Baker bake = new Baker(Client, bakeType, 0, paramValues);
-                                UploadBake(bake);
-                            }
-                            else
-                            {
-                                lock (PendingBakes)
-                                {
-                                    Baker bake=new Baker(Client, bakeType, imageCount,paramValues);
-                                    PendingBakes.Add(bakeType,bake);
-                                }
-                            }
-                        }
-                        else if (!PendingBakes.ContainsKey(bakeType))
-                        {
-                            Logger.Log("No cached bake for " + bakeType.ToString() + " and no textures for that " +
-                                "layer, this is an unhandled case", Helpers.LogLevel.Error, Client);
-                        }
-                    }
-                }
-            }
-
-            if (ImageDownloads.Count == 0)
-            {
-                // No pending downloads for baking, we're done
-                CachedResponseEvent.Set();
-            }
-            else
-            {
-                lock (ImageDownloads)
-                {
-                    List<UUID> imgKeys = new List<UUID>(ImageDownloads.Keys);
-                    foreach (UUID image in imgKeys)
-                    {
-                        // Download all the images we need for baking
-                        Assets.RequestImage(image, ImageType.Normal, 1013000.0f, 0, 0);
-                    }
-                }
-            }
-        }
-
-        private void Assets_OnAssetReceived(AssetDownload download, Asset asset)
-        {
-            lock (Wearables.Dictionary)
-            {
-                // Check if this is a wearable we were waiting on
-                foreach (KeyValuePair<WearableType,WearableData> kvp in Wearables.Dictionary)
-                {
-                    if (kvp.Value.Item.AssetUUID == download.AssetID)
-                    {
-                        // Make sure the download succeeded
-                        if (download.Success)
-                        {
-                            kvp.Value.Asset = (AssetWearable)asset;
-
-                            Logger.DebugLog("Downloaded wearable asset " + kvp.Value.Asset.Name, Client);
-
-                            if (!kvp.Value.Asset.Decode())
-                            {
-                                Logger.Log("Failed to decode asset:" + Environment.NewLine +
-                                    Utils.BytesToString(asset.AssetData), Helpers.LogLevel.Error, Client);
-                            }
-
-                            lock (AgentTextures)
-                            {
-                                foreach (KeyValuePair<AppearanceManager.TextureIndex, UUID> texture in kvp.Value.Asset.Textures)
-                                {
-                                    if (texture.Value != DEFAULT_AVATAR_TEXTURE) // this texture is not meant to be displayed
-                                    {
-                                        Logger.DebugLog("Setting " + texture.Key + " to " + texture.Value, Client);
-                                        AgentTextures[(int)texture.Key] = texture.Value;
-                                    }
-                                }
-                            }
-                        }
-                        else
-                        {
-                            Logger.Log("Wearable " + kvp.Key + "(" + download.AssetID.ToString() + ") failed to download, " +
-                                download.Status.ToString(), Helpers.LogLevel.Warning, Client);
-                        }
-
-                        break;
-                    }
-                }
-            }
-
-            if (AssetDownloads.Count > 0)
-            {
-                // Dowload the next wearable in line
-                PendingAssetDownload pad = AssetDownloads.Dequeue();
-                Assets.RequestAsset(pad.Id, pad.Type, true);
-            }
-            else
-            {
-                // Everything is downloaded
-                if (OnAgentWearables != null)
-                {
-                    try { OnAgentWearables(); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-
-                WearablesDownloadedEvent.Set();
-            }
-        }
-
-        private void Assets_OnImageReceived(ImageDownload image, AssetTexture assetTexture)
-        {
-            lock (ImageDownloads)
-            {
-                if (ImageDownloads.ContainsKey(image.ID))
-                {
-                    ImageDownloads.Remove(image.ID);
-
-                    // NOTE: This image may occupy more than one TextureIndex! We must finish this loop
-                    for (int at = 0; at < AgentTextures.Length; at++)
-                    {
-                        if (AgentTextures[at] == image.ID)
-                        {
-                            TextureIndex index = (TextureIndex)at;
-                            BakeType type = Baker.BakeTypeFor(index);
-
-                            //BinaryWriter writer = new BinaryWriter(File.Create("wearable_" + index.ToString() + "_" + image.ID.ToString() + ".jp2"));
-                            //writer.Write(image.AssetData);
-                            //writer.Close();
-
-                            bool baked = false;
-
-                            if (PendingBakes.ContainsKey(type))
-                            {
-                                if (image.Success)
-                                {
-                                    Logger.DebugLog("Finished downloading texture for " + index.ToString(), Client);
-                                    OpenJPEG.DecodeToImage(image.AssetData, out assetTexture.Image);
-                                    baked = PendingBakes[type].AddTexture(index, assetTexture, false);
-                                }
-                                else
-                                {
-                                    Logger.Log("Texture for " + index.ToString() + " failed to download, " +
-                                        "bake will be incomplete", Helpers.LogLevel.Warning, Client);
-                                    baked = PendingBakes[type].MissingTexture(index);
-                                }
-                            }
-
-                            if (baked)
-                            {
-                                UploadBake(PendingBakes[type]);
-                                PendingBakes.Remove(type);
-                            }
-
-                            if (ImageDownloads.Count == 0 && PendingUploads.Count == 0)
-                            {
-                                // This is a failsafe catch, as the upload completed callback should normally 
-                                // be triggering the event
-                                Logger.DebugLog("No pending downloads or uploads detected in OnImageReceived", Client);
-                                CachedResponseEvent.Set();
-                            }
-                            else
-                            {
-                                Logger.DebugLog("Pending uploads: " + PendingUploads.Count + ", pending downloads: " +
-                                    ImageDownloads.Count, Client);
-                            }
-
-                        }
-                    }
-                }
-                else
-                {
-                    Logger.Log("Received an image download callback for an image we did not request " + image.ID.ToString(),
-                        Helpers.LogLevel.Warning, Client);
-                }
-            }
-        }
-
-        private void Assets_OnAssetUploaded(AssetUpload upload)
-        {
-            lock (PendingUploads)
-            {
-                if (PendingUploads.ContainsKey(upload.AssetID))
-                {
-                    if (upload.Success)
-                    {
-                        // Setup the TextureEntry with the new baked upload
-                        TextureIndex index = PendingUploads[upload.AssetID];
-                        AgentTextures[(int)index] = upload.AssetID;
-
-                        Logger.DebugLog("Upload complete, AgentTextures " + index.ToString() + " set to " + 
-                            upload.AssetID.ToString(), Client);
-                    }
-                    else
-                    {
-                        Logger.Log("Asset upload " + upload.AssetID.ToString() + " failed", 
-                            Helpers.LogLevel.Warning, Client);
-                    }
-
-                    PendingUploads.Remove(upload.AssetID);
-
-                    Logger.DebugLog("Pending uploads: " + PendingUploads.Count + ", pending downloads: " +
-                        ImageDownloads.Count, Client);
-
-                    if (PendingUploads.Count == 0 && ImageDownloads.Count == 0)
-                    {
-                        Logger.DebugLog("All pending image downloads and uploads complete", Client);
-
-                        CachedResponseEvent.Set();
-                    }
-                }
-                else
-                {
-                    // TEMP
-                    Logger.DebugLog("Upload " + upload.AssetID.ToString() + " was not found in PendingUploads", Client);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Terminate any wait handles when the network layer disconnects
-        /// </summary>
-        private void Network_OnDisconnected(NetworkManager.DisconnectType reason, string message)
-        {
-            WearablesRequestEvent.Set();
-            WearablesDownloadedEvent.Set();
-            CachedResponseEvent.Set();
-            UpdateEvent.Set();
-        }
-
-        #endregion Callbacks
-    }
-}
+            lock (AgentTextures)
+            {
+                //If we are here then the user has tried to wear stuff or we are at login
+                // In either case the existing uploads of this class are very shortly going to be no good
+                PendingUploads.Clear();
+
+                foreach (AgentCachedTextureResponsePacket.WearableDataBlock block in response.WearableData)
+                {
+                    //UUID hash=new UUID();
+                    // For each missing element we need to bake our own texture
+                    Logger.DebugLog("Cache response, index: " + block.TextureIndex + ", ID: " +
+                        block.TextureID.ToString(), Client);
+
+                    // FIXME: Use this. Right now we treat baked images on other sims as if they were missing
+                    string host = Utils.BytesToString(block.HostName);
+                    if (host.Length > 0) Logger.DebugLog("Cached bake exists on foreign host " + host, Client);
+
+                    BakeType bakeType = (BakeType)block.TextureIndex;
+                    
+                    // Note, still should handle block.TextureID != UUID.Zero && host.Length == 0
+                    // Not sure what we should do as yet with that.
+
+                    // Convert the baked index to an AgentTexture index
+                    if (block.TextureID != UUID.Zero && host.Length != 0)
+                    {
+                        TextureIndex index = BakeTypeToAgentTextureIndex(bakeType);
+                        AgentTextures[(int)index] = block.TextureID;
+                    }
+                    else
+                    {
+                        int imageCount = 0;
+
+                        // Download all of the images in this layer
+                        switch (bakeType)
+                        {
+                            case BakeType.Head:
+                                lock (ImageDownloads)
+                                {
+                                    imageCount += AddImageDownload(TextureIndex.HeadBodypaint);
+                                    //imageCount += AddImageDownload(TextureIndex.Hair);
+                                }
+                                break;
+                            case BakeType.UpperBody:
+                                lock (ImageDownloads)
+                                {
+                                    imageCount += AddImageDownload(TextureIndex.UpperBodypaint);
+                                    imageCount += AddImageDownload(TextureIndex.UpperGloves);
+                                    imageCount += AddImageDownload(TextureIndex.UpperUndershirt);
+                                    imageCount += AddImageDownload(TextureIndex.UpperShirt);
+                                    imageCount += AddImageDownload(TextureIndex.UpperJacket);
+                                }
+                                break;
+                            case BakeType.LowerBody:
+                                lock (ImageDownloads)
+                                {
+                                    imageCount += AddImageDownload(TextureIndex.LowerBodypaint);
+                                    imageCount += AddImageDownload(TextureIndex.LowerUnderpants);
+                                    imageCount += AddImageDownload(TextureIndex.LowerSocks);
+                                    imageCount += AddImageDownload(TextureIndex.LowerShoes);
+                                    imageCount += AddImageDownload(TextureIndex.LowerPants);
+                                    imageCount += AddImageDownload(TextureIndex.LowerJacket);
+                                }
+                                break;
+                            case BakeType.Eyes:
+                                lock (ImageDownloads)
+                                {
+                                    imageCount += AddImageDownload(TextureIndex.EyesIris);
+                                }
+                                break;
+                            case BakeType.Skirt:
+                                if (Wearables.ContainsKey(WearableType.Skirt))
+                                {
+                                    lock (ImageDownloads)
+                                    {
+                                        imageCount += AddImageDownload(TextureIndex.Skirt);
+                                    }
+                                }
+                                break;
+                            default:
+                                Logger.Log("Unknown BakeType " + block.TextureIndex, Helpers.LogLevel.Warning, Client);
+                                break;
+                        }
+
+                        if (!PendingBakes.ContainsKey(bakeType))
+                        {
+                            Logger.DebugLog("Initializing " + bakeType.ToString() + " bake with " + imageCount + " textures", Client);
+
+                            if (imageCount == 0)
+                            {
+                                // if there are no textures to download, we can bake right away and start the upload
+                                Baker bake = new Baker(Client, bakeType, 0, paramValues);
+                                UploadBake(bake);
+                            }
+                            else
+                            {
+                                lock (PendingBakes)
+                                {
+                                    Baker bake=new Baker(Client, bakeType, imageCount,paramValues);
+                                    PendingBakes.Add(bakeType,bake);
+                                }
+                            }
+                        }
+                        else if (!PendingBakes.ContainsKey(bakeType))
+                        {
+                            Logger.Log("No cached bake for " + bakeType.ToString() + " and no textures for that " +
+                                "layer, this is an unhandled case", Helpers.LogLevel.Error, Client);
+                        }
+                    }
+                }
+            }
+
+            if (ImageDownloads.Count == 0)
+            {
+                // No pending downloads for baking, we're done
+                CachedResponseEvent.Set();
+            }
+            else
+            {
+                lock (ImageDownloads)
+                {
+                    List<UUID> imgKeys = new List<UUID>(ImageDownloads.Keys);
+                    foreach (UUID image in imgKeys)
+                    {
+                        // Download all the images we need for baking
+                        Assets.RequestImage(image, ImageType.Normal, 1013000.0f, 0, 0);
+                    }
+                }
+            }
+        }
+
+        private void Assets_OnAssetReceived(AssetDownload download, Asset asset)
+        {
+            lock (Wearables.Dictionary)
+            {
+                // Check if this is a wearable we were waiting on
+                foreach (KeyValuePair<WearableType,WearableData> kvp in Wearables.Dictionary)
+                {
+                    if (kvp.Value.Item.AssetUUID == download.AssetID)
+                    {
+                        // Make sure the download succeeded
+                        if (download.Success)
+                        {
+                            kvp.Value.Asset = (AssetWearable)asset;
+
+                            Logger.DebugLog("Downloaded wearable asset " + kvp.Value.Asset.Name, Client);
+
+                            if (!kvp.Value.Asset.Decode())
+                            {
+                                Logger.Log("Failed to decode asset:" + Environment.NewLine +
+                                    Utils.BytesToString(asset.AssetData), Helpers.LogLevel.Error, Client);
+                            }
+
+                            lock (AgentTextures)
+                            {
+                                foreach (KeyValuePair<AppearanceManager.TextureIndex, UUID> texture in kvp.Value.Asset.Textures)
+                                {
+                                    if (texture.Value != DEFAULT_AVATAR_TEXTURE) // this texture is not meant to be displayed
+                                    {
+                                        Logger.DebugLog("Setting " + texture.Key + " to " + texture.Value, Client);
+                                        AgentTextures[(int)texture.Key] = texture.Value;
+                                    }
+                                }
+                            }
+                        }
+                        else
+                        {
+                            Logger.Log("Wearable " + kvp.Key + "(" + download.AssetID.ToString() + ") failed to download, " +
+                                download.Status.ToString(), Helpers.LogLevel.Warning, Client);
+                        }
+
+                        break;
+                    }
+                }
+            }
+
+            if (AssetDownloads.Count > 0)
+            {
+                // Dowload the next wearable in line
+                PendingAssetDownload pad = AssetDownloads.Dequeue();
+                Assets.RequestAsset(pad.Id, pad.Type, true);
+            }
+            else
+            {
+                // Everything is downloaded
+                if (OnAgentWearables != null)
+                {
+                    try { OnAgentWearables(); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+
+                WearablesDownloadedEvent.Set();
+            }
+        }
+
+        private void Assets_OnImageReceived(ImageDownload image, AssetTexture assetTexture)
+        {
+            lock (ImageDownloads)
+            {
+                if (ImageDownloads.ContainsKey(image.ID))
+                {
+                    ImageDownloads.Remove(image.ID);
+
+                    // NOTE: This image may occupy more than one TextureIndex! We must finish this loop
+                    for (int at = 0; at < AgentTextures.Length; at++)
+                    {
+                        if (AgentTextures[at] == image.ID)
+                        {
+                            TextureIndex index = (TextureIndex)at;
+                            BakeType type = Baker.BakeTypeFor(index);
+
+                            //BinaryWriter writer = new BinaryWriter(File.Create("wearable_" + index.ToString() + "_" + image.ID.ToString() + ".jp2"));
+                            //writer.Write(image.AssetData);
+                            //writer.Close();
+
+                            bool baked = false;
+
+                            if (PendingBakes.ContainsKey(type))
+                            {
+                                if (image.Success)
+                                {
+                                    Logger.DebugLog("Finished downloading texture for " + index.ToString(), Client);
+                                    OpenJPEG.DecodeToImage(image.AssetData, out assetTexture.Image);
+                                    baked = PendingBakes[type].AddTexture(index, assetTexture, false);
+                                }
+                                else
+                                {
+                                    Logger.Log("Texture for " + index.ToString() + " failed to download, " +
+                                        "bake will be incomplete", Helpers.LogLevel.Warning, Client);
+                                    baked = PendingBakes[type].MissingTexture(index);
+                                }
+                            }
+
+                            if (baked)
+                            {
+                                UploadBake(PendingBakes[type]);
+                                PendingBakes.Remove(type);
+                            }
+
+                            if (ImageDownloads.Count == 0 && PendingUploads.Count == 0)
+                            {
+                                // This is a failsafe catch, as the upload completed callback should normally 
+                                // be triggering the event
+                                Logger.DebugLog("No pending downloads or uploads detected in OnImageReceived", Client);
+                                CachedResponseEvent.Set();
+                            }
+                            else
+                            {
+                                Logger.DebugLog("Pending uploads: " + PendingUploads.Count + ", pending downloads: " +
+                                    ImageDownloads.Count, Client);
+                            }
+
+                        }
+                    }
+                }
+                else
+                {
+                    Logger.Log("Received an image download callback for an image we did not request " + image.ID.ToString(),
+                        Helpers.LogLevel.Warning, Client);
+                }
+            }
+        }
+
+        private void Assets_OnAssetUploaded(AssetUpload upload)
+        {
+            lock (PendingUploads)
+            {
+                if (PendingUploads.ContainsKey(upload.AssetID))
+                {
+                    if (upload.Success)
+                    {
+                        // Setup the TextureEntry with the new baked upload
+                        TextureIndex index = PendingUploads[upload.AssetID];
+                        AgentTextures[(int)index] = upload.AssetID;
+
+                        Logger.DebugLog("Upload complete, AgentTextures " + index.ToString() + " set to " + 
+                            upload.AssetID.ToString(), Client);
+                    }
+                    else
+                    {
+                        Logger.Log("Asset upload " + upload.AssetID.ToString() + " failed", 
+                            Helpers.LogLevel.Warning, Client);
+                    }
+
+                    PendingUploads.Remove(upload.AssetID);
+
+                    Logger.DebugLog("Pending uploads: " + PendingUploads.Count + ", pending downloads: " +
+                        ImageDownloads.Count, Client);
+
+                    if (PendingUploads.Count == 0 && ImageDownloads.Count == 0)
+                    {
+                        Logger.DebugLog("All pending image downloads and uploads complete", Client);
+
+                        CachedResponseEvent.Set();
+                    }
+                }
+                else
+                {
+                    // TEMP
+                    Logger.DebugLog("Upload " + upload.AssetID.ToString() + " was not found in PendingUploads", Client);
+                }
+            }
+        }
+
+        /// <summary>
+        /// Terminate any wait handles when the network layer disconnects
+        /// </summary>
+        private void Network_OnDisconnected(NetworkManager.DisconnectType reason, string message)
+        {
+            WearablesRequestEvent.Set();
+            WearablesDownloadedEvent.Set();
+            CachedResponseEvent.Set();
+            UpdateEvent.Set();
+        }
+
+        #endregion Callbacks
+    }
+}
Index: ObjectPoolBase.cs
===================================================================
--- ObjectPoolBase.cs	(revision 2445)
+++ ObjectPoolBase.cs	(working copy)
@@ -1,529 +1,529 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Threading;
-
-namespace OpenMetaverse
-{
-    public sealed class WrappedObject<T> : IDisposable where T : class
-    {
-        private T _instance;
-        internal readonly ObjectPoolSegment<T> _owningSegment;
-        internal readonly ObjectPoolBase<T> _owningObjectPool;
-        private bool _disposed = false;
-
-        internal WrappedObject(ObjectPoolBase<T> owningPool, ObjectPoolSegment<T> ownerSegment, T activeInstance)
-        {
-            _owningObjectPool = owningPool;
-            _owningSegment = ownerSegment;
-            _instance = activeInstance;
-        }
-
-        ~WrappedObject()
-        {
-#if !PocketPC
-            // If the AppDomain is being unloaded, or the CLR is 
-            // shutting down, just exit gracefully
-            if (Environment.HasShutdownStarted)
-                return;
-#endif
-
-            // Object Resurrection in Action!
-            GC.ReRegisterForFinalize(this);
-
-            // Return this instance back to the owning queue
-            _owningObjectPool.CheckIn(_owningSegment, _instance);
-        }
-
-        /// <summary>
-        /// Returns an instance of the class that has been checked out of the Object Pool.
-        /// </summary>
-        public T Instance
-        {
-            get
-            {
-                if (_disposed)
-                    throw new ObjectDisposedException("WrappedObject");
-                return _instance;
-            }
-        }
-
-        /// <summary>
-        /// Checks the instance back into the object pool
-        /// </summary>
-        public void Dispose()
-        {
-            if (_disposed)
-                return;
-
-            _disposed = true;
-            _owningObjectPool.CheckIn(_owningSegment, _instance);
-            GC.SuppressFinalize(this);
-        }
-    }
-
-    public abstract class ObjectPoolBase<T> : IDisposable where T : class
-    {
-        private int _itemsPerSegment = 32;
-        private int _minimumSegmentCount = 1;
-
-        // A segment won't be eligible for cleanup unless it's at least this old...
-        private TimeSpan _minimumAgeToCleanup = new TimeSpan(0, 5, 0);
-
-        // ever increasing segment counter
-        private int _activeSegment = 0;
-
-        private bool _gc = true;
-
-        private volatile bool _disposed = false;
-
-        private Dictionary<int, ObjectPoolSegment<T>> _segments = new Dictionary<int, ObjectPoolSegment<T>>();
-        private object _syncRoot = new object();
-        private object _timerLock = new object();
-
-        // create a timer that starts in 5 minutes, and gets called every 5 minutes.
-        System.Threading.Timer _timer;
-        int _cleanupFrequency;
-
-        /// <summary>
-        /// Creates a new instance of the ObjectPoolBase class. Initialize MUST be called
-        /// after using this constructor.
-        /// </summary>
-        protected ObjectPoolBase()
-        {
-        }
-
-        /// <summary>
-        /// Creates a new instance of the ObjectPool Base class.        
-        /// </summary>
-        /// <param name="itemsPerSegment">The object pool is composed of segments, which 
-        /// are allocated whenever the size of the pool is exceeded. The number of items
-        /// in a segment should be large enough that allocating a new segmeng is a rare
-        /// thing. For example, on a server that will have 10k people logged in at once, 
-        /// the receive buffer object pool should have segment sizes of at least 1000 
-        /// byte arrays per segment.
-        /// </param>
-        /// <param name="minimumSegmentCount">The minimun number of segments that may exist.</param>
-        /// <param name="gcOnPoolGrowth">Perform a full GC.Collect whenever a segment is allocated, and then again after allocation to compact the heap.</param>
-        /// <param name="cleanupFrequenceMS">The frequency which segments are checked to see if they're eligible for cleanup.</param>
-        protected ObjectPoolBase(int itemsPerSegment, int minimumSegmentCount, bool gcOnPoolGrowth, int cleanupFrequenceMS)
-        {
-            Initialize(itemsPerSegment, minimumSegmentCount, gcOnPoolGrowth, cleanupFrequenceMS);
-        }
-
-        protected void Initialize(int itemsPerSegment, int minimumSegmentCount, bool gcOnPoolGrowth, int cleanupFrequenceMS)
-        {
-            _itemsPerSegment = itemsPerSegment;
-            _minimumSegmentCount = minimumSegmentCount;
-            _gc = gcOnPoolGrowth;
-
-            // force garbage collection to make sure these new long lived objects
-            // cause as little fragmentation as possible
-            if (_gc)
-                System.GC.Collect();
-
-            lock (_syncRoot)
-            {
-                while (_segments.Count < this.MinimumSegmentCount)
-                {
-                    ObjectPoolSegment<T> segment = CreateSegment(false);
-                    _segments.Add(segment.SegmentNumber, segment);
-                }
-            }
-
-            // This forces a compact, to make sure our objects fill in any holes in the heap. 
-            if (_gc)
-            {
-                System.GC.Collect();
-            }
-
-            _timer = new Timer(CleanupThreadCallback, null, cleanupFrequenceMS, cleanupFrequenceMS);
-        }
-
-        /// <summary>
-        /// Forces the segment cleanup algorithm to be run. This method is intended 
-        /// primarly for use from the Unit Test libraries.
-        /// </summary>
-        internal void ForceCleanup()
-        {
-            CleanupThreadCallback(null);
-        }
-
-        private void CleanupThreadCallback(object state)
-        {
-            if (_disposed)
-                return;
-
-            if (Monitor.TryEnter(_timerLock) == false)
-                return;
-
-            try
-            {
-                lock (_syncRoot)
-                {
-                    // If we're below, or at, or minimum segment count threshold, 
-                    // there's no point in going any further.
-                    if (_segments.Count <= _minimumSegmentCount)
-                        return;
-
-                    for (int i = _activeSegment; i > 0; i--)
-                    {
-                        ObjectPoolSegment<T> segment;
-                        if (_segments.TryGetValue(i, out segment) == true)
-                        {
-                            // For the "old" segments that were allocated at startup, this will
-                            // always be false, as their expiration dates are set at infinity. 
-                            if (segment.CanBeCleanedUp())
-                            {
-                                _segments.Remove(i);
-                                segment.Dispose();
-                            }
-                        }
-                    }
-                }
-            }
-            finally
-            {
-                Monitor.Exit(_timerLock);
-            }
-        }
-
-        /// <summary>
-        /// Responsible for allocate 1 instance of an object that will be stored in a segment. 
-        /// </summary>
-        /// <returns>An instance of whatever objec the pool is pooling.</returns>
-        protected abstract T GetObjectInstance();
-
-
-        private ObjectPoolSegment<T> CreateSegment(bool allowSegmentToBeCleanedUp)
-        {
-            if (_disposed)
-                throw new ObjectDisposedException("ObjectPoolBase");
-
-            if (allowSegmentToBeCleanedUp)
-                Logger.Log("Creating new object pool segment", Helpers.LogLevel.Info);
-
-            // This method is called inside a lock, so no interlocked stuff required.
-            int segmentToAdd = _activeSegment;
-            _activeSegment++;
-
-            Queue<T> buffers = new Queue<T>();
-            for (int i = 1; i <= this._itemsPerSegment; i++)
-            {
-                T obj = GetObjectInstance();
-                buffers.Enqueue(obj);
-            }
-
-            // certain segments we don't want to ever be cleaned up (the initial segments)
-            DateTime cleanupTime = (allowSegmentToBeCleanedUp) ? DateTime.Now.Add(this._minimumAgeToCleanup) : DateTime.MaxValue;
-            ObjectPoolSegment<T> segment = new ObjectPoolSegment<T>(segmentToAdd, buffers, cleanupTime);
-
-            return segment;
-        }
-
-
-        /// <summary>
-        /// Checks in an instance of T owned by the object pool. This method is only intended to be called
-        /// by the <c>WrappedObject</c> class.
-        /// </summary>
-        /// <param name="owningSegment">The segment from which the instance is checked out.</param>
-        /// <param name="instance">The instance of <c>T</c> to check back into the segment.</param>
-        internal void CheckIn(ObjectPoolSegment<T> owningSegment, T instance)
-        {
-            lock (_syncRoot)
-            {
-                owningSegment.CheckInObject(instance);
-            }
-        }
-
-        /// <summary>
-        /// Checks an instance of <c>T</c> from the pool. If the pool is not sufficient to 
-        /// allow the checkout, a new segment is created. 
-        /// </summary>
-        /// <returns>A <c>WrappedObject</c> around the instance of <c>T</c>. To check
-        /// the instance back into the segment, be sureto dispose the WrappedObject 
-        /// when finished. </returns>
-        public WrappedObject<T> CheckOut()
-        {
-            if (_disposed)
-                throw new ObjectDisposedException("ObjectPoolBase");
-
-            // It's key that this CheckOut always, always, uses a pooled object
-            // from the oldest available segment. This will help keep the "newer" 
-            // segments from being used - which in turn, makes them eligible
-            // for deletion.
-
-
-            lock (_syncRoot)
-            {
-                ObjectPoolSegment<T> targetSegment = null;
-
-                // find the oldest segment that has items available for checkout
-                for (int i = 0; i < _activeSegment; i++)
-                {
-                    ObjectPoolSegment<T> segment;
-                    if (_segments.TryGetValue(i, out segment) == true)
-                    {
-                        if (segment.AvailableItems > 0)
-                        {
-                            targetSegment = segment;
-                            break;
-                        }
-                    }
-                }
-
-                if (targetSegment == null)
-                {
-                    // We couldn't find a sigment that had any available space in it,
-                    // so it's time to create a new segment.
-
-                    // Before creating the segment, do a GC to make sure the heap 
-                    // is compacted.
-                    if (_gc) GC.Collect();
-
-                    targetSegment = CreateSegment(true);
-
-                    if (_gc) GC.Collect();
-
-                    _segments.Add(targetSegment.SegmentNumber, targetSegment);
-                }
-
-                WrappedObject<T> obj = new WrappedObject<T>(this, targetSegment, targetSegment.CheckOutObject());
-                return obj;
-            }
-        }
-
-        /// <summary>
-        /// The total number of segments created. Intended to be used by the Unit Tests.
-        /// </summary>
-        public int TotalSegments
-        {
-            get
-            {
-                if (_disposed)
-                    throw new ObjectDisposedException("ObjectPoolBase");
-
-                lock (_syncRoot)
-                {
-                    return _segments.Count;
-                }
-            }
-        }
-
-        /// <summary>
-        /// The number of items that are in a segment. Items in a segment 
-        /// are all allocated at the same time, and are hopefully close to 
-        /// each other in the managed heap. 
-        /// </summary>
-        public int ItemsPerSegment
-        {
-            get
-            {
-                if (_disposed)
-                    throw new ObjectDisposedException("ObjectPoolBase");
-
-                return _itemsPerSegment;
-            }
-        }
-
-        /// <summary>
-        /// The minimum number of segments. When segments are reclaimed, 
-        /// this number of segments will always be left alone. These
-        /// segments are allocated at startup.
-        /// </summary>
-        public int MinimumSegmentCount
-        {
-            get
-            {
-                if (_disposed)
-                    throw new ObjectDisposedException("ObjectPoolBase");
-
-                return _minimumSegmentCount;
-            }
-        }
-
-        /// <summary>
-        /// The age a segment must be before it's eligible for cleanup. 
-        /// This  is used to prevent thrash, and typical values are in 
-        /// the 5 minute range.
-        /// </summary>
-        public TimeSpan MinimumSegmentAgePriorToCleanup
-        {
-            get
-            {
-                if (_disposed)
-                    throw new ObjectDisposedException("ObjectPoolBase");
-
-                return _minimumAgeToCleanup;
-            }
-            set
-            {
-                if (_disposed)
-                    throw new ObjectDisposedException("ObjectPoolBase");
-
-                _minimumAgeToCleanup = value;
-            }
-        }
-
-        /// <summary>
-        /// The frequence which the cleanup thread runs. This is typically
-        /// expected to be in the 5 minute range. 
-        /// </summary>
-        public int CleanupFrequencyMilliseconds
-        {
-            get
-            {
-                if (_disposed)
-                    throw new ObjectDisposedException("ObjectPoolBase");
-
-                return _cleanupFrequency;
-            }
-            set
-            {
-                if (_disposed)
-                    throw new ObjectDisposedException("ObjectPoolBase");
-
-                Interlocked.Exchange(ref _cleanupFrequency, value);
-
-                _timer.Change(_cleanupFrequency, _cleanupFrequency);
-            }
-        }
-
-        #region IDisposable Members
-
-        public void Dispose()
-        {
-            if (_disposed)
-                return;
-
-            Dispose(true);
-
-            GC.SuppressFinalize(this);
-        }
-
-        protected virtual void Dispose(bool disposing)
-        {
-            if (disposing)
-            {
-                lock (_syncRoot)
-                {
-                    if (_disposed)
-                        return;
-
-                    _timer.Dispose();
-                    _disposed = true;
-
-                    foreach (KeyValuePair<int, ObjectPoolSegment<T>> kvp in _segments)
-                    {
-                        try
-                        {
-                            kvp.Value.Dispose();
-                        }
-                        catch (Exception) { }
-                    }
-
-                    _segments.Clear();
-                }
-            }
-        }
-
-        #endregion
-    }
-
-    internal class ObjectPoolSegment<T> : IDisposable where T : class
-    {
-        private Queue<T> _liveInstances = new Queue<T>();
-        private int _segmentNumber;
-        private int _originalCount;
-        private bool _isDisposed = false;
-        private DateTime _eligibleForDeletionAt;
-
-        public int SegmentNumber { get { return _segmentNumber; } }
-        public int AvailableItems { get { return _liveInstances.Count; } }
-        public DateTime DateEligibleForDeletion { get { return _eligibleForDeletionAt; } }
-
-        public ObjectPoolSegment(int segmentNumber, Queue<T> liveInstances, DateTime eligibleForDeletionAt)
-        {
-            _segmentNumber = segmentNumber;
-            _liveInstances = liveInstances;
-            _originalCount = liveInstances.Count;
-            _eligibleForDeletionAt = eligibleForDeletionAt;
-        }
-
-        public bool CanBeCleanedUp()
-        {
-            if (_isDisposed == true)
-                throw new ObjectDisposedException("ObjectPoolSegment");
-
-            return ((_originalCount == _liveInstances.Count) && (DateTime.Now > _eligibleForDeletionAt));
-        }
-
-        public void Dispose()
-        {
-            if (_isDisposed)
-                return;
-
-            _isDisposed = true;
-
-            bool shouldDispose = (typeof(T) is IDisposable);
-            while (_liveInstances.Count != 0)
-            {
-                T instance = _liveInstances.Dequeue();
-                if (shouldDispose)
-                {
-                    try
-                    {
-                        (instance as IDisposable).Dispose();
-                    }
-                    catch (Exception) { }
-                }
-            }
-        }
-
-        internal void CheckInObject(T o)
-        {
-            if (_isDisposed == true)
-                throw new ObjectDisposedException("ObjectPoolSegment");
-
-            _liveInstances.Enqueue(o);
-        }
-
-        internal T CheckOutObject()
-        {
-            if (_isDisposed == true)
-                throw new ObjectDisposedException("ObjectPoolSegment");
-
-            if (0 == _liveInstances.Count)
-                throw new InvalidOperationException("No Objects Available for Checkout");
-
-            T o = _liveInstances.Dequeue();
-            return o;
-        }
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Threading;
+
+namespace OpenMetaverse
+{
+    public sealed class WrappedObject<T> : IDisposable where T : class
+    {
+        private T _instance;
+        internal readonly ObjectPoolSegment<T> _owningSegment;
+        internal readonly ObjectPoolBase<T> _owningObjectPool;
+        private bool _disposed = false;
+
+        internal WrappedObject(ObjectPoolBase<T> owningPool, ObjectPoolSegment<T> ownerSegment, T activeInstance)
+        {
+            _owningObjectPool = owningPool;
+            _owningSegment = ownerSegment;
+            _instance = activeInstance;
+        }
+
+        ~WrappedObject()
+        {
+#if !PocketPC
+            // If the AppDomain is being unloaded, or the CLR is 
+            // shutting down, just exit gracefully
+            if (Environment.HasShutdownStarted)
+                return;
+#endif
+
+            // Object Resurrection in Action!
+            GC.ReRegisterForFinalize(this);
+
+            // Return this instance back to the owning queue
+            _owningObjectPool.CheckIn(_owningSegment, _instance);
+        }
+
+        /// <summary>
+        /// Returns an instance of the class that has been checked out of the Object Pool.
+        /// </summary>
+        public T Instance
+        {
+            get
+            {
+                if (_disposed)
+                    throw new ObjectDisposedException("WrappedObject");
+                return _instance;
+            }
+        }
+
+        /// <summary>
+        /// Checks the instance back into the object pool
+        /// </summary>
+        public void Dispose()
+        {
+            if (_disposed)
+                return;
+
+            _disposed = true;
+            _owningObjectPool.CheckIn(_owningSegment, _instance);
+            GC.SuppressFinalize(this);
+        }
+    }
+
+    public abstract class ObjectPoolBase<T> : IDisposable where T : class
+    {
+        private int _itemsPerSegment = 32;
+        private int _minimumSegmentCount = 1;
+
+        // A segment won't be eligible for cleanup unless it's at least this old...
+        private TimeSpan _minimumAgeToCleanup = new TimeSpan(0, 5, 0);
+
+        // ever increasing segment counter
+        private int _activeSegment = 0;
+
+        private bool _gc = true;
+
+        private volatile bool _disposed = false;
+
+        private Dictionary<int, ObjectPoolSegment<T>> _segments = new Dictionary<int, ObjectPoolSegment<T>>();
+        private object _syncRoot = new object();
+        private object _timerLock = new object();
+
+        // create a timer that starts in 5 minutes, and gets called every 5 minutes.
+        System.Threading.Timer _timer;
+        int _cleanupFrequency;
+
+        /// <summary>
+        /// Creates a new instance of the ObjectPoolBase class. Initialize MUST be called
+        /// after using this constructor.
+        /// </summary>
+        protected ObjectPoolBase()
+        {
+        }
+
+        /// <summary>
+        /// Creates a new instance of the ObjectPool Base class.        
+        /// </summary>
+        /// <param name="itemsPerSegment">The object pool is composed of segments, which 
+        /// are allocated whenever the size of the pool is exceeded. The number of items
+        /// in a segment should be large enough that allocating a new segmeng is a rare
+        /// thing. For example, on a server that will have 10k people logged in at once, 
+        /// the receive buffer object pool should have segment sizes of at least 1000 
+        /// byte arrays per segment.
+        /// </param>
+        /// <param name="minimumSegmentCount">The minimun number of segments that may exist.</param>
+        /// <param name="gcOnPoolGrowth">Perform a full GC.Collect whenever a segment is allocated, and then again after allocation to compact the heap.</param>
+        /// <param name="cleanupFrequenceMS">The frequency which segments are checked to see if they're eligible for cleanup.</param>
+        protected ObjectPoolBase(int itemsPerSegment, int minimumSegmentCount, bool gcOnPoolGrowth, int cleanupFrequenceMS)
+        {
+            Initialize(itemsPerSegment, minimumSegmentCount, gcOnPoolGrowth, cleanupFrequenceMS);
+        }
+
+        protected void Initialize(int itemsPerSegment, int minimumSegmentCount, bool gcOnPoolGrowth, int cleanupFrequenceMS)
+        {
+            _itemsPerSegment = itemsPerSegment;
+            _minimumSegmentCount = minimumSegmentCount;
+            _gc = gcOnPoolGrowth;
+
+            // force garbage collection to make sure these new long lived objects
+            // cause as little fragmentation as possible
+            if (_gc)
+                System.GC.Collect();
+
+            lock (_syncRoot)
+            {
+                while (_segments.Count < this.MinimumSegmentCount)
+                {
+                    ObjectPoolSegment<T> segment = CreateSegment(false);
+                    _segments.Add(segment.SegmentNumber, segment);
+                }
+            }
+
+            // This forces a compact, to make sure our objects fill in any holes in the heap. 
+            if (_gc)
+            {
+                System.GC.Collect();
+            }
+
+            _timer = new Timer(CleanupThreadCallback, null, cleanupFrequenceMS, cleanupFrequenceMS);
+        }
+
+        /// <summary>
+        /// Forces the segment cleanup algorithm to be run. This method is intended 
+        /// primarly for use from the Unit Test libraries.
+        /// </summary>
+        internal void ForceCleanup()
+        {
+            CleanupThreadCallback(null);
+        }
+
+        private void CleanupThreadCallback(object state)
+        {
+            if (_disposed)
+                return;
+
+            if (Monitor.TryEnter(_timerLock) == false)
+                return;
+
+            try
+            {
+                lock (_syncRoot)
+                {
+                    // If we're below, or at, or minimum segment count threshold, 
+                    // there's no point in going any further.
+                    if (_segments.Count <= _minimumSegmentCount)
+                        return;
+
+                    for (int i = _activeSegment; i > 0; i--)
+                    {
+                        ObjectPoolSegment<T> segment;
+                        if (_segments.TryGetValue(i, out segment) == true)
+                        {
+                            // For the "old" segments that were allocated at startup, this will
+                            // always be false, as their expiration dates are set at infinity. 
+                            if (segment.CanBeCleanedUp())
+                            {
+                                _segments.Remove(i);
+                                segment.Dispose();
+                            }
+                        }
+                    }
+                }
+            }
+            finally
+            {
+                Monitor.Exit(_timerLock);
+            }
+        }
+
+        /// <summary>
+        /// Responsible for allocate 1 instance of an object that will be stored in a segment. 
+        /// </summary>
+        /// <returns>An instance of whatever objec the pool is pooling.</returns>
+        protected abstract T GetObjectInstance();
+
+
+        private ObjectPoolSegment<T> CreateSegment(bool allowSegmentToBeCleanedUp)
+        {
+            if (_disposed)
+                throw new ObjectDisposedException("ObjectPoolBase");
+
+            if (allowSegmentToBeCleanedUp)
+                Logger.Log("Creating new object pool segment", Helpers.LogLevel.Info);
+
+            // This method is called inside a lock, so no interlocked stuff required.
+            int segmentToAdd = _activeSegment;
+            _activeSegment++;
+
+            Queue<T> buffers = new Queue<T>();
+            for (int i = 1; i <= this._itemsPerSegment; i++)
+            {
+                T obj = GetObjectInstance();
+                buffers.Enqueue(obj);
+            }
+
+            // certain segments we don't want to ever be cleaned up (the initial segments)
+            DateTime cleanupTime = (allowSegmentToBeCleanedUp) ? DateTime.Now.Add(this._minimumAgeToCleanup) : DateTime.MaxValue;
+            ObjectPoolSegment<T> segment = new ObjectPoolSegment<T>(segmentToAdd, buffers, cleanupTime);
+
+            return segment;
+        }
+
+
+        /// <summary>
+        /// Checks in an instance of T owned by the object pool. This method is only intended to be called
+        /// by the <c>WrappedObject</c> class.
+        /// </summary>
+        /// <param name="owningSegment">The segment from which the instance is checked out.</param>
+        /// <param name="instance">The instance of <c>T</c> to check back into the segment.</param>
+        internal void CheckIn(ObjectPoolSegment<T> owningSegment, T instance)
+        {
+            lock (_syncRoot)
+            {
+                owningSegment.CheckInObject(instance);
+            }
+        }
+
+        /// <summary>
+        /// Checks an instance of <c>T</c> from the pool. If the pool is not sufficient to 
+        /// allow the checkout, a new segment is created. 
+        /// </summary>
+        /// <returns>A <c>WrappedObject</c> around the instance of <c>T</c>. To check
+        /// the instance back into the segment, be sureto dispose the WrappedObject 
+        /// when finished. </returns>
+        public WrappedObject<T> CheckOut()
+        {
+            if (_disposed)
+                throw new ObjectDisposedException("ObjectPoolBase");
+
+            // It's key that this CheckOut always, always, uses a pooled object
+            // from the oldest available segment. This will help keep the "newer" 
+            // segments from being used - which in turn, makes them eligible
+            // for deletion.
+
+
+            lock (_syncRoot)
+            {
+                ObjectPoolSegment<T> targetSegment = null;
+
+                // find the oldest segment that has items available for checkout
+                for (int i = 0; i < _activeSegment; i++)
+                {
+                    ObjectPoolSegment<T> segment;
+                    if (_segments.TryGetValue(i, out segment) == true)
+                    {
+                        if (segment.AvailableItems > 0)
+                        {
+                            targetSegment = segment;
+                            break;
+                        }
+                    }
+                }
+
+                if (targetSegment == null)
+                {
+                    // We couldn't find a sigment that had any available space in it,
+                    // so it's time to create a new segment.
+
+                    // Before creating the segment, do a GC to make sure the heap 
+                    // is compacted.
+                    if (_gc) GC.Collect();
+
+                    targetSegment = CreateSegment(true);
+
+                    if (_gc) GC.Collect();
+
+                    _segments.Add(targetSegment.SegmentNumber, targetSegment);
+                }
+
+                WrappedObject<T> obj = new WrappedObject<T>(this, targetSegment, targetSegment.CheckOutObject());
+                return obj;
+            }
+        }
+
+        /// <summary>
+        /// The total number of segments created. Intended to be used by the Unit Tests.
+        /// </summary>
+        public int TotalSegments
+        {
+            get
+            {
+                if (_disposed)
+                    throw new ObjectDisposedException("ObjectPoolBase");
+
+                lock (_syncRoot)
+                {
+                    return _segments.Count;
+                }
+            }
+        }
+
+        /// <summary>
+        /// The number of items that are in a segment. Items in a segment 
+        /// are all allocated at the same time, and are hopefully close to 
+        /// each other in the managed heap. 
+        /// </summary>
+        public int ItemsPerSegment
+        {
+            get
+            {
+                if (_disposed)
+                    throw new ObjectDisposedException("ObjectPoolBase");
+
+                return _itemsPerSegment;
+            }
+        }
+
+        /// <summary>
+        /// The minimum number of segments. When segments are reclaimed, 
+        /// this number of segments will always be left alone. These
+        /// segments are allocated at startup.
+        /// </summary>
+        public int MinimumSegmentCount
+        {
+            get
+            {
+                if (_disposed)
+                    throw new ObjectDisposedException("ObjectPoolBase");
+
+                return _minimumSegmentCount;
+            }
+        }
+
+        /// <summary>
+        /// The age a segment must be before it's eligible for cleanup. 
+        /// This  is used to prevent thrash, and typical values are in 
+        /// the 5 minute range.
+        /// </summary>
+        public TimeSpan MinimumSegmentAgePriorToCleanup
+        {
+            get
+            {
+                if (_disposed)
+                    throw new ObjectDisposedException("ObjectPoolBase");
+
+                return _minimumAgeToCleanup;
+            }
+            set
+            {
+                if (_disposed)
+                    throw new ObjectDisposedException("ObjectPoolBase");
+
+                _minimumAgeToCleanup = value;
+            }
+        }
+
+        /// <summary>
+        /// The frequence which the cleanup thread runs. This is typically
+        /// expected to be in the 5 minute range. 
+        /// </summary>
+        public int CleanupFrequencyMilliseconds
+        {
+            get
+            {
+                if (_disposed)
+                    throw new ObjectDisposedException("ObjectPoolBase");
+
+                return _cleanupFrequency;
+            }
+            set
+            {
+                if (_disposed)
+                    throw new ObjectDisposedException("ObjectPoolBase");
+
+                Interlocked.Exchange(ref _cleanupFrequency, value);
+
+                _timer.Change(_cleanupFrequency, _cleanupFrequency);
+            }
+        }
+
+        #region IDisposable Members
+
+        public void Dispose()
+        {
+            if (_disposed)
+                return;
+
+            Dispose(true);
+
+            GC.SuppressFinalize(this);
+        }
+
+        protected virtual void Dispose(bool disposing)
+        {
+            if (disposing)
+            {
+                lock (_syncRoot)
+                {
+                    if (_disposed)
+                        return;
+
+                    _timer.Dispose();
+                    _disposed = true;
+
+                    foreach (KeyValuePair<int, ObjectPoolSegment<T>> kvp in _segments)
+                    {
+                        try
+                        {
+                            kvp.Value.Dispose();
+                        }
+                        catch (Exception) { }
+                    }
+
+                    _segments.Clear();
+                }
+            }
+        }
+
+        #endregion
+    }
+
+    internal class ObjectPoolSegment<T> : IDisposable where T : class
+    {
+        private Queue<T> _liveInstances = new Queue<T>();
+        private int _segmentNumber;
+        private int _originalCount;
+        private bool _isDisposed = false;
+        private DateTime _eligibleForDeletionAt;
+
+        public int SegmentNumber { get { return _segmentNumber; } }
+        public int AvailableItems { get { return _liveInstances.Count; } }
+        public DateTime DateEligibleForDeletion { get { return _eligibleForDeletionAt; } }
+
+        public ObjectPoolSegment(int segmentNumber, Queue<T> liveInstances, DateTime eligibleForDeletionAt)
+        {
+            _segmentNumber = segmentNumber;
+            _liveInstances = liveInstances;
+            _originalCount = liveInstances.Count;
+            _eligibleForDeletionAt = eligibleForDeletionAt;
+        }
+
+        public bool CanBeCleanedUp()
+        {
+            if (_isDisposed == true)
+                throw new ObjectDisposedException("ObjectPoolSegment");
+
+            return ((_originalCount == _liveInstances.Count) && (DateTime.Now > _eligibleForDeletionAt));
+        }
+
+        public void Dispose()
+        {
+            if (_isDisposed)
+                return;
+
+            _isDisposed = true;
+
+            bool shouldDispose = (typeof(T) is IDisposable);
+            while (_liveInstances.Count != 0)
+            {
+                T instance = _liveInstances.Dequeue();
+                if (shouldDispose)
+                {
+                    try
+                    {
+                        (instance as IDisposable).Dispose();
+                    }
+                    catch (Exception) { }
+                }
+            }
+        }
+
+        internal void CheckInObject(T o)
+        {
+            if (_isDisposed == true)
+                throw new ObjectDisposedException("ObjectPoolSegment");
+
+            _liveInstances.Enqueue(o);
+        }
+
+        internal T CheckOutObject()
+        {
+            if (_isDisposed == true)
+                throw new ObjectDisposedException("ObjectPoolSegment");
+
+            if (0 == _liveInstances.Count)
+                throw new InvalidOperationException("No Objects Available for Checkout");
+
+            T o = _liveInstances.Dequeue();
+            return o;
+        }
+    }
+}
Index: Inventory.cs
===================================================================
--- Inventory.cs	(revision 2445)
+++ Inventory.cs	(working copy)
@@ -1,384 +1,384 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// Exception class to identify inventory exceptions
-    /// </summary>
-    public class InventoryException : Exception
-    {
-        public InventoryException(string message)
-            : base(message) { }
-    }
-
-    /// <summary>
-    /// Responsible for maintaining inventory structure. Inventory constructs nodes
-    /// and manages node children as is necessary to maintain a coherant hirarchy.
-    /// Other classes should not manipulate or create InventoryNodes explicitly. When
-    /// A node's parent changes (when a folder is moved, for example) simply pass
-    /// Inventory the updated InventoryFolder and it will make the appropriate changes
-    /// to its internal representation.
-    /// </summary>
-    public class Inventory
-    {
-        /// <summary>
-        /// Delegate to use for the OnInventoryObjectUpdated event.
-        /// </summary>
-        /// <param name="oldObject">The state of the InventoryObject before the update occured.</param>
-        /// <param name="newObject">The state of the InventoryObject after the update occured.</param>
-        public delegate void InventoryObjectUpdated(InventoryBase oldObject, InventoryBase newObject);
-        /// <summary>
-        /// Delegate to use for the OnInventoryObjectRemoved event.
-        /// </summary>
-        /// <param name="obj">The InventoryObject that was removed.</param>
-        public delegate void InventoryObjectRemoved(InventoryBase obj);
-        /// <summary>
-        /// Delegate to use for the OnInventoryObjectUpdated event.
-        /// </summary>
-        /// <param name="obj">The InventoryObject that has been stored.</param>
-        public delegate void InventoryObjectAdded(InventoryBase obj);
-
-        /// <summary>
-        /// Called when an InventoryObject's state is changed.
-        /// </summary>
-        public event InventoryObjectUpdated OnInventoryObjectUpdated;
-        /// <summary>
-        /// Called when an item or folder is removed from inventory.
-        /// </summary>
-        public event InventoryObjectRemoved OnInventoryObjectRemoved;
-        /// <summary>
-        /// Called when an item is first added to the local inventory store.
-        /// This will occur most frequently when we're initially downloading
-        /// the inventory from the server.
-        /// 
-        /// This will also fire when another avatar or object offers us inventory
-        /// </summary>
-        public event InventoryObjectAdded OnInventoryObjectAdded;
-
-        /// <summary>
-        /// The root folder of this avatars inventory
-        /// </summary>
-        public InventoryFolder RootFolder
-        {
-            get { return RootNode.Data as InventoryFolder; }
-            set 
-            {
-                UpdateNodeFor(value);
-                _RootNode = Items[value.UUID];
-            }
-        }
-
-        /// <summary>
-        /// The default shared library folder
-        /// </summary>
-        public InventoryFolder LibraryFolder
-        {
-            get { return LibraryRootNode.Data as InventoryFolder; }
-            set
-            {
-                UpdateNodeFor(value);
-                _LibraryRootNode = Items[value.UUID];
-            }
-        }
-
-        private InventoryNode _LibraryRootNode;
-        private InventoryNode _RootNode;
-        
-        /// <summary>
-        /// The root node of the avatars inventory
-        /// </summary>
-        public InventoryNode RootNode
-        {
-            get
-            {
-                if (_RootNode == null)
-                    throw new InventoryException("Root node unknown. Are you completely logged in?");
-                return _RootNode;
-            }
-        }
-
-        /// <summary>
-        /// The root node of the default shared library
-        /// </summary>
-        public InventoryNode LibraryRootNode
-        {
-            get
-            {
-                if (_LibraryRootNode == null)
-                    throw new InventoryException("Library Root node unknown. Are you completely logged in?");
-                return _LibraryRootNode;
-            }
-        }
-
-        public UUID Owner {
-            get { return _Owner; }
-        }
-
-        private UUID _Owner;
-
-        private GridClient Client;
-        //private InventoryManager Manager;
-        private Dictionary<UUID, InventoryNode> Items = new Dictionary<UUID, InventoryNode>();
-
-        public Inventory(GridClient client, InventoryManager manager)
-            : this(client, manager, client.Self.AgentID) { }
-
-        public Inventory(GridClient client, InventoryManager manager, UUID owner)
-        {
-            Client = client;
-            //Manager = manager;
-            _Owner = owner;
-            if (owner == UUID.Zero)
-                Logger.Log("Inventory owned by nobody!", Helpers.LogLevel.Warning, Client);
-            Items = new Dictionary<UUID, InventoryNode>();
-        }
-
-        public List<InventoryBase> GetContents(InventoryFolder folder)
-        {
-            return GetContents(folder.UUID);
-        }
-
-        /// <summary>
-        /// Returns the contents of the specified folder
-        /// </summary>
-        /// <param name="folder">A folder's UUID</param>
-        /// <returns>The contents of the folder corresponding to <code>folder</code></returns>
-        /// <exception cref="InventoryException">When <code>folder</code> does not exist in the inventory</exception>
-        public List<InventoryBase> GetContents(UUID folder)
-        {
-            InventoryNode folderNode;
-            if (!Items.TryGetValue(folder, out folderNode))
-                throw new InventoryException("Unknown folder: " + folder);
-            lock (folderNode.Nodes.SyncRoot)
-            {
-                List<InventoryBase> contents = new List<InventoryBase>(folderNode.Nodes.Count);
-                foreach (InventoryNode node in folderNode.Nodes.Values)
-                {
-                    contents.Add(node.Data);
-                }
-                return contents;
-            }
-        }
-
-        /// <summary>
-        /// Updates the state of the InventoryNode and inventory data structure that
-        /// is responsible for the InventoryObject. If the item was previously not added to inventory,
-        /// it adds the item, and updates structure accordingly. If it was, it updates the 
-        /// InventoryNode, changing the parent node if <code>item.parentUUID</code> does 
-        /// not match <code>node.Parent.Data.UUID</code>.
-        /// 
-        /// You can not set the inventory root folder using this method
-        /// </summary>
-        /// <param name="item">The InventoryObject to store</param>
-        public void UpdateNodeFor(InventoryBase item)
-        {
-            lock (Items)
-            {
-                InventoryNode itemParent = null;
-                if (item.ParentUUID != UUID.Zero && !Items.TryGetValue(item.ParentUUID, out itemParent))
-                {
-                    // OK, we have no data on the parent, let's create a fake one.
-                    InventoryFolder fakeParent = new InventoryFolder(item.ParentUUID);
-                    fakeParent.DescendentCount = 1; // Dear god, please forgive me.
-                    itemParent = new InventoryNode(fakeParent);
-                    Items[item.ParentUUID] = itemParent;
-                    // Unfortunately, this breaks the nice unified tree
-                    // while we're waiting for the parent's data to come in.
-                    // As soon as we get the parent, the tree repairs itself.
-                    Logger.DebugLog("Attempting to update inventory child of " +
-                        item.ParentUUID.ToString() + " when we have no local reference to that folder", Client);
-
-                    if (Client.Settings.FETCH_MISSING_INVENTORY)
-                    {
-                        // Fetch the parent
-                        List<UUID> fetchreq = new List<UUID>(1);
-                        fetchreq.Add(item.ParentUUID);
-                        //Manager.FetchInventory(fetchreq); // we cant fetch folder data! :-O
-                    }
-                }
-
-                InventoryNode itemNode;
-                if (Items.TryGetValue(item.UUID, out itemNode)) // We're updating.
-                {
-                    InventoryNode oldParent = itemNode.Parent;
-                    // Handle parent change
-                    if (oldParent == null || itemParent == null || itemParent.Data.UUID != oldParent.Data.UUID)
-                    {
-                        if (oldParent != null)
-                        {
-                            lock (oldParent.Nodes.SyncRoot)
-                                oldParent.Nodes.Remove(item.UUID);
-                        }
-                        if (itemParent != null)
-                        {
-                            lock (itemParent.Nodes.SyncRoot)
-                                itemParent.Nodes[item.UUID] = itemNode;
-                        }
-                    }
-
-                    itemNode.Parent = itemParent;
-
-                    if (item != itemNode.Data)
-                        FireOnInventoryObjectUpdated(itemNode.Data, item);
-
-                    itemNode.Data = item;
-                }
-                else // We're adding.
-                {
-                    itemNode = new InventoryNode(item, itemParent);
-                    Items.Add(item.UUID, itemNode);
-                    FireOnInventoryObjectAdded(item);
-                }
-            }
-        }
-
-        public InventoryNode GetNodeFor(UUID uuid)
-        {
-            return Items[uuid];
-        }
-
-        /// <summary>
-        /// Removes the InventoryObject and all related node data from Inventory.
-        /// </summary>
-        /// <param name="item">The InventoryObject to remove.</param>
-        public void RemoveNodeFor(InventoryBase item)
-        {
-            lock (Items)
-            {
-                InventoryNode node;
-                if (Items.TryGetValue(item.UUID, out node))
-                {
-                    if (node.Parent != null)
-                        lock (node.Parent.Nodes.SyncRoot)
-                            node.Parent.Nodes.Remove(item.UUID);
-                    Items.Remove(item.UUID);
-                    FireOnInventoryObjectRemoved(item);
-                }
-
-                // In case there's a new parent:
-                InventoryNode newParent;
-                if (Items.TryGetValue(item.ParentUUID, out newParent))
-                {
-                    lock (newParent.Nodes.SyncRoot)
-                        newParent.Nodes.Remove(item.UUID);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Used to find out if Inventory contains the InventoryObject
-        /// specified by <code>uuid</code>.
-        /// </summary>
-        /// <param name="uuid">The UUID to check.</param>
-        /// <returns>true if inventory contains uuid, false otherwise</returns>
-        public bool Contains(UUID uuid)
-        {
-            return Items.ContainsKey(uuid);
-        }
-
-        public bool Contains(InventoryBase obj)
-        {
-            return Contains(obj.UUID);
-        }
-
-        #region Operators
-
-        /// <summary>
-        /// By using the bracket operator on this class, the program can get the 
-        /// InventoryObject designated by the specified uuid. If the value for the corresponding
-        /// UUID is null, the call is equivelant to a call to <code>RemoveNodeFor(this[uuid])</code>.
-        /// If the value is non-null, it is equivelant to a call to <code>UpdateNodeFor(value)</code>,
-        /// the uuid parameter is ignored.
-        /// </summary>
-        /// <param name="uuid">The UUID of the InventoryObject to get or set, ignored if set to non-null value.</param>
-        /// <returns>The InventoryObject corresponding to <code>uuid</code>.</returns>
-        public InventoryBase this[UUID uuid]
-        {
-            get
-            {
-                InventoryNode node = Items[uuid];
-                return node.Data;
-            }
-            set
-            {
-                if (value != null)
-                {
-                    // Log a warning if there is a UUID mismatch, this will cause problems
-                    if (value.UUID != uuid)
-                        Logger.Log("Inventory[uuid]: uuid " + uuid.ToString() + " is not equal to value.UUID " +
-                            value.UUID.ToString(), Helpers.LogLevel.Warning, Client);
-
-                    UpdateNodeFor(value);
-                }
-                else
-                {
-                    InventoryNode node;
-                    if (Items.TryGetValue(uuid, out node))
-                    {
-                        RemoveNodeFor(node.Data);
-                    }
-                }
-            }
-        }
-
-        #endregion Operators
-
-        #region Event Firing
-
-        protected void FireOnInventoryObjectUpdated(InventoryBase oldObject, InventoryBase newObject)
-        {
-            if (OnInventoryObjectUpdated != null)
-            {
-                try { OnInventoryObjectUpdated(oldObject, newObject); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        protected void FireOnInventoryObjectRemoved(InventoryBase obj)
-        {
-            if (OnInventoryObjectRemoved != null)
-            {
-                try { OnInventoryObjectRemoved(obj); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        protected void FireOnInventoryObjectAdded(InventoryBase obj)
-        {
-            if (OnInventoryObjectAdded != null)
-            {
-                try { OnInventoryObjectAdded(obj); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        #endregion
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// Exception class to identify inventory exceptions
+    /// </summary>
+    public class InventoryException : Exception
+    {
+        public InventoryException(string message)
+            : base(message) { }
+    }
+
+    /// <summary>
+    /// Responsible for maintaining inventory structure. Inventory constructs nodes
+    /// and manages node children as is necessary to maintain a coherant hirarchy.
+    /// Other classes should not manipulate or create InventoryNodes explicitly. When
+    /// A node's parent changes (when a folder is moved, for example) simply pass
+    /// Inventory the updated InventoryFolder and it will make the appropriate changes
+    /// to its internal representation.
+    /// </summary>
+    public class Inventory
+    {
+        /// <summary>
+        /// Delegate to use for the OnInventoryObjectUpdated event.
+        /// </summary>
+        /// <param name="oldObject">The state of the InventoryObject before the update occured.</param>
+        /// <param name="newObject">The state of the InventoryObject after the update occured.</param>
+        public delegate void InventoryObjectUpdated(InventoryBase oldObject, InventoryBase newObject);
+        /// <summary>
+        /// Delegate to use for the OnInventoryObjectRemoved event.
+        /// </summary>
+        /// <param name="obj">The InventoryObject that was removed.</param>
+        public delegate void InventoryObjectRemoved(InventoryBase obj);
+        /// <summary>
+        /// Delegate to use for the OnInventoryObjectUpdated event.
+        /// </summary>
+        /// <param name="obj">The InventoryObject that has been stored.</param>
+        public delegate void InventoryObjectAdded(InventoryBase obj);
+
+        /// <summary>
+        /// Called when an InventoryObject's state is changed.
+        /// </summary>
+        public event InventoryObjectUpdated OnInventoryObjectUpdated;
+        /// <summary>
+        /// Called when an item or folder is removed from inventory.
+        /// </summary>
+        public event InventoryObjectRemoved OnInventoryObjectRemoved;
+        /// <summary>
+        /// Called when an item is first added to the local inventory store.
+        /// This will occur most frequently when we're initially downloading
+        /// the inventory from the server.
+        /// 
+        /// This will also fire when another avatar or object offers us inventory
+        /// </summary>
+        public event InventoryObjectAdded OnInventoryObjectAdded;
+
+        /// <summary>
+        /// The root folder of this avatars inventory
+        /// </summary>
+        public InventoryFolder RootFolder
+        {
+            get { return RootNode.Data as InventoryFolder; }
+            set 
+            {
+                UpdateNodeFor(value);
+                _RootNode = Items[value.UUID];
+            }
+        }
+
+        /// <summary>
+        /// The default shared library folder
+        /// </summary>
+        public InventoryFolder LibraryFolder
+        {
+            get { return LibraryRootNode.Data as InventoryFolder; }
+            set
+            {
+                UpdateNodeFor(value);
+                _LibraryRootNode = Items[value.UUID];
+            }
+        }
+
+        private InventoryNode _LibraryRootNode;
+        private InventoryNode _RootNode;
+        
+        /// <summary>
+        /// The root node of the avatars inventory
+        /// </summary>
+        public InventoryNode RootNode
+        {
+            get
+            {
+                if (_RootNode == null)
+                    throw new InventoryException("Root node unknown. Are you completely logged in?");
+                return _RootNode;
+            }
+        }
+
+        /// <summary>
+        /// The root node of the default shared library
+        /// </summary>
+        public InventoryNode LibraryRootNode
+        {
+            get
+            {
+                if (_LibraryRootNode == null)
+                    throw new InventoryException("Library Root node unknown. Are you completely logged in?");
+                return _LibraryRootNode;
+            }
+        }
+
+        public UUID Owner {
+            get { return _Owner; }
+        }
+
+        private UUID _Owner;
+
+        private GridClient Client;
+        //private InventoryManager Manager;
+        public Dictionary<UUID, InventoryNode> Items = new Dictionary<UUID, InventoryNode>();
+
+        public Inventory(GridClient client, InventoryManager manager)
+            : this(client, manager, client.Self.AgentID) { }
+
+        public Inventory(GridClient client, InventoryManager manager, UUID owner)
+        {
+            Client = client;
+            //Manager = manager;
+            _Owner = owner;
+            if (owner == UUID.Zero)
+                Logger.Log("Inventory owned by nobody!", Helpers.LogLevel.Warning, Client);
+            Items = new Dictionary<UUID, InventoryNode>();
+        }
+
+        public List<InventoryBase> GetContents(InventoryFolder folder)
+        {
+            return GetContents(folder.UUID);
+        }
+
+        /// <summary>
+        /// Returns the contents of the specified folder
+        /// </summary>
+        /// <param name="folder">A folder's UUID</param>
+        /// <returns>The contents of the folder corresponding to <code>folder</code></returns>
+        /// <exception cref="InventoryException">When <code>folder</code> does not exist in the inventory</exception>
+        public List<InventoryBase> GetContents(UUID folder)
+        {
+            InventoryNode folderNode;
+            if (!Items.TryGetValue(folder, out folderNode))
+                throw new InventoryException("Unknown folder: " + folder);
+            lock (folderNode.Nodes.SyncRoot)
+            {
+                List<InventoryBase> contents = new List<InventoryBase>(folderNode.Nodes.Count);
+                foreach (InventoryNode node in folderNode.Nodes.Values)
+                {
+                    contents.Add(node.Data);
+                }
+                return contents;
+            }
+        }
+
+        /// <summary>
+        /// Updates the state of the InventoryNode and inventory data structure that
+        /// is responsible for the InventoryObject. If the item was previously not added to inventory,
+        /// it adds the item, and updates structure accordingly. If it was, it updates the 
+        /// InventoryNode, changing the parent node if <code>item.parentUUID</code> does 
+        /// not match <code>node.Parent.Data.UUID</code>.
+        /// 
+        /// You can not set the inventory root folder using this method
+        /// </summary>
+        /// <param name="item">The InventoryObject to store</param>
+        public void UpdateNodeFor(InventoryBase item)
+        {
+            lock (Items)
+            {
+                InventoryNode itemParent = null;
+                if (item.ParentUUID != UUID.Zero && !Items.TryGetValue(item.ParentUUID, out itemParent))
+                {
+                    // OK, we have no data on the parent, let's create a fake one.
+                    InventoryFolder fakeParent = new InventoryFolder(item.ParentUUID);
+                    fakeParent.DescendentCount = 1; // Dear god, please forgive me.
+                    itemParent = new InventoryNode(fakeParent);
+                    Items[item.ParentUUID] = itemParent;
+                    // Unfortunately, this breaks the nice unified tree
+                    // while we're waiting for the parent's data to come in.
+                    // As soon as we get the parent, the tree repairs itself.
+                    Logger.DebugLog("Attempting to update inventory child of " +
+                        item.ParentUUID.ToString() + " when we have no local reference to that folder", Client);
+
+                    if (Client.Settings.FETCH_MISSING_INVENTORY)
+                    {
+                        // Fetch the parent
+                        List<UUID> fetchreq = new List<UUID>(1);
+                        fetchreq.Add(item.ParentUUID);
+                        //Manager.FetchInventory(fetchreq); // we cant fetch folder data! :-O
+                    }
+                }
+
+                InventoryNode itemNode;
+                if (Items.TryGetValue(item.UUID, out itemNode)) // We're updating.
+                {
+                    InventoryNode oldParent = itemNode.Parent;
+                    // Handle parent change
+                    if (oldParent == null || itemParent == null || itemParent.Data.UUID != oldParent.Data.UUID)
+                    {
+                        if (oldParent != null)
+                        {
+                            lock (oldParent.Nodes.SyncRoot)
+                                oldParent.Nodes.Remove(item.UUID);
+                        }
+                        if (itemParent != null)
+                        {
+                            lock (itemParent.Nodes.SyncRoot)
+                                itemParent.Nodes[item.UUID] = itemNode;
+                        }
+                    }
+
+                    itemNode.Parent = itemParent;
+
+                    if (item != itemNode.Data)
+                        FireOnInventoryObjectUpdated(itemNode.Data, item);
+
+                    itemNode.Data = item;
+                }
+                else // We're adding.
+                {
+                    itemNode = new InventoryNode(item, itemParent);
+                    Items.Add(item.UUID, itemNode);
+                    FireOnInventoryObjectAdded(item);
+                }
+            }
+        }
+
+        public InventoryNode GetNodeFor(UUID uuid)
+        {
+            return Items[uuid];
+        }
+
+        /// <summary>
+        /// Removes the InventoryObject and all related node data from Inventory.
+        /// </summary>
+        /// <param name="item">The InventoryObject to remove.</param>
+        public void RemoveNodeFor(InventoryBase item)
+        {
+            lock (Items)
+            {
+                InventoryNode node;
+                if (Items.TryGetValue(item.UUID, out node))
+                {
+                    if (node.Parent != null)
+                        lock (node.Parent.Nodes.SyncRoot)
+                            node.Parent.Nodes.Remove(item.UUID);
+                    Items.Remove(item.UUID);
+                    FireOnInventoryObjectRemoved(item);
+                }
+
+                // In case there's a new parent:
+                InventoryNode newParent;
+                if (Items.TryGetValue(item.ParentUUID, out newParent))
+                {
+                    lock (newParent.Nodes.SyncRoot)
+                        newParent.Nodes.Remove(item.UUID);
+                }
+            }
+        }
+
+        /// <summary>
+        /// Used to find out if Inventory contains the InventoryObject
+        /// specified by <code>uuid</code>.
+        /// </summary>
+        /// <param name="uuid">The UUID to check.</param>
+        /// <returns>true if inventory contains uuid, false otherwise</returns>
+        public bool Contains(UUID uuid)
+        {
+            return Items.ContainsKey(uuid);
+        }
+
+        public bool Contains(InventoryBase obj)
+        {
+            return Contains(obj.UUID);
+        }
+
+        #region Operators
+
+        /// <summary>
+        /// By using the bracket operator on this class, the program can get the 
+        /// InventoryObject designated by the specified uuid. If the value for the corresponding
+        /// UUID is null, the call is equivelant to a call to <code>RemoveNodeFor(this[uuid])</code>.
+        /// If the value is non-null, it is equivelant to a call to <code>UpdateNodeFor(value)</code>,
+        /// the uuid parameter is ignored.
+        /// </summary>
+        /// <param name="uuid">The UUID of the InventoryObject to get or set, ignored if set to non-null value.</param>
+        /// <returns>The InventoryObject corresponding to <code>uuid</code>.</returns>
+        public InventoryBase this[UUID uuid]
+        {
+            get
+            {
+                InventoryNode node = Items[uuid];
+                return node.Data;
+            }
+            set
+            {
+                if (value != null)
+                {
+                    // Log a warning if there is a UUID mismatch, this will cause problems
+                    if (value.UUID != uuid)
+                        Logger.Log("Inventory[uuid]: uuid " + uuid.ToString() + " is not equal to value.UUID " +
+                            value.UUID.ToString(), Helpers.LogLevel.Warning, Client);
+
+                    UpdateNodeFor(value);
+                }
+                else
+                {
+                    InventoryNode node;
+                    if (Items.TryGetValue(uuid, out node))
+                    {
+                        RemoveNodeFor(node.Data);
+                    }
+                }
+            }
+        }
+
+        #endregion Operators
+
+        #region Event Firing
+
+        protected void FireOnInventoryObjectUpdated(InventoryBase oldObject, InventoryBase newObject)
+        {
+            if (OnInventoryObjectUpdated != null)
+            {
+                try { OnInventoryObjectUpdated(oldObject, newObject); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        protected void FireOnInventoryObjectRemoved(InventoryBase obj)
+        {
+            if (OnInventoryObjectRemoved != null)
+            {
+                try { OnInventoryObjectRemoved(obj); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        protected void FireOnInventoryObjectAdded(InventoryBase obj)
+        {
+            if (OnInventoryObjectAdded != null)
+            {
+                try { OnInventoryObjectAdded(obj); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        #endregion
+    }
+}
Index: ObjectPool.cs
===================================================================
--- ObjectPool.cs	(revision 2445)
+++ ObjectPool.cs	(working copy)
@@ -1,119 +1,119 @@
-using System;
-using System.Collections.Generic;
-using System.Net;
-
-namespace OpenMetaverse
-{
-    // this class encapsulates a single packet that
-    // is either sent or received by a UDP socket
-    public class UDPPacketBuffer
-    {
-        /// <summary>Size of the byte array used to store raw packet data</summary>
-        public const int BUFFER_SIZE = 4096;
-        /// <summary>Size of the temporary buffer for zerodecoding and 
-        /// zeroencoding this packet</summary>
-        public const int ZERO_BUFFER_SIZE = 4096;
-        /// <summary>Raw packet data buffer</summary>
-        public readonly byte[] Data;
-        /// <summary>Temporary buffer used for zerodecoding and zeroencoding
-        /// this packet</summary>
-        public readonly byte[] ZeroData;
-        /// <summary>Length of the data to transmit</summary>
-        public int DataLength;
-        /// <summary>EndPoint of the remote host</summary>
-        public EndPoint RemoteEndPoint;
-
-        /// <summary>
-        /// Create an allocated UDP packet buffer for receiving a packet
-        /// </summary>
-        public UDPPacketBuffer()
-        {
-            Data = new byte[UDPPacketBuffer.BUFFER_SIZE];
-            ZeroData = new byte[UDPPacketBuffer.ZERO_BUFFER_SIZE];
-            // Will be modified later by BeginReceiveFrom()
-            RemoteEndPoint = (EndPoint)new IPEndPoint(Settings.BIND_ADDR, 0);
-        }
-
-        /// <summary>
-        /// Create an allocated UDP packet buffer for sending a packet
-        /// </summary>
-        /// <param name="endPoint">EndPoint of the remote host</param>
-        public UDPPacketBuffer(IPEndPoint endPoint)
-        {
-            Data = new byte[UDPPacketBuffer.BUFFER_SIZE];
-            ZeroData = new byte[UDPPacketBuffer.ZERO_BUFFER_SIZE];
-            RemoteEndPoint = (EndPoint)endPoint;
-        }
-    }
-
-    /// <summary>
-    /// Object pool for packet buffers. This is used to allocate memory for all
-    /// incoming and outgoing packets, and zerocoding buffers for those packets
-    /// </summary>
-    public class PacketBufferPool : ObjectPoolBase<UDPPacketBuffer>
-    {
-        private IPEndPoint EndPoint;
-
-        /// <summary>
-        /// Initialize the object pool in client mode
-        /// </summary>
-        /// <param name="endPoint">Server to connect to</param>
-        /// <param name="itemsPerSegment"></param>
-        /// <param name="minSegments"></param>
-        public PacketBufferPool(IPEndPoint endPoint, int itemsPerSegment, int minSegments)
-            : base()
-        {
-            EndPoint = endPoint;
-            Initialize(itemsPerSegment, minSegments, true, 1000 * 60 * 5);
-        }
-
-        /// <summary>
-        /// Initialize the object pool in server mode
-        /// </summary>
-        /// <param name="itemsPerSegment"></param>
-        /// <param name="minSegments"></param>
-        public PacketBufferPool(int itemsPerSegment, int minSegments)
-            : base()
-        {
-            EndPoint = null;
-            Initialize(itemsPerSegment, minSegments, true, 1000 * 60 * 5);
-        }
-
-        /// <summary>
-        /// Returns a packet buffer with EndPoint set if the buffer is in
-        /// client mode, or with EndPoint set to null in server mode
-        /// </summary>
-        /// <returns>Initialized UDPPacketBuffer object</returns>
-        protected override UDPPacketBuffer GetObjectInstance()
-        {
-            if (EndPoint != null)
-                // Client mode
-                return new UDPPacketBuffer(EndPoint);
-            else
-                // Server mode
-                return new UDPPacketBuffer();
-        }
-    }
-
-    public static class Pool
-    {
-        public static PacketBufferPool PoolInstance;
-
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        static Pool()
-        {
-            PoolInstance = new PacketBufferPool(new IPEndPoint(Settings.BIND_ADDR, 0), 16, 1);
-        }
-
-        /// <summary>
-        /// Check a packet buffer out of the pool
-        /// </summary>
-        /// <returns>A packet buffer object</returns>
-        public static WrappedObject<UDPPacketBuffer> CheckOut()
-        {
-            return PoolInstance.CheckOut();
-        }
-    }
-}
+using System;
+using System.Collections.Generic;
+using System.Net;
+
+namespace OpenMetaverse
+{
+    // this class encapsulates a single packet that
+    // is either sent or received by a UDP socket
+    public class UDPPacketBuffer
+    {
+        /// <summary>Size of the byte array used to store raw packet data</summary>
+        public const int BUFFER_SIZE = 4096;
+        /// <summary>Size of the temporary buffer for zerodecoding and 
+        /// zeroencoding this packet</summary>
+        public const int ZERO_BUFFER_SIZE = 4096;
+        /// <summary>Raw packet data buffer</summary>
+        public readonly byte[] Data;
+        /// <summary>Temporary buffer used for zerodecoding and zeroencoding
+        /// this packet</summary>
+        public readonly byte[] ZeroData;
+        /// <summary>Length of the data to transmit</summary>
+        public int DataLength;
+        /// <summary>EndPoint of the remote host</summary>
+        public EndPoint RemoteEndPoint;
+
+        /// <summary>
+        /// Create an allocated UDP packet buffer for receiving a packet
+        /// </summary>
+        public UDPPacketBuffer()
+        {
+            Data = new byte[UDPPacketBuffer.BUFFER_SIZE];
+            ZeroData = new byte[UDPPacketBuffer.ZERO_BUFFER_SIZE];
+            // Will be modified later by BeginReceiveFrom()
+            RemoteEndPoint = (EndPoint)new IPEndPoint(Settings.BIND_ADDR, 0);
+        }
+
+        /// <summary>
+        /// Create an allocated UDP packet buffer for sending a packet
+        /// </summary>
+        /// <param name="endPoint">EndPoint of the remote host</param>
+        public UDPPacketBuffer(IPEndPoint endPoint)
+        {
+            Data = new byte[UDPPacketBuffer.BUFFER_SIZE];
+            ZeroData = new byte[UDPPacketBuffer.ZERO_BUFFER_SIZE];
+            RemoteEndPoint = (EndPoint)endPoint;
+        }
+    }
+
+    /// <summary>
+    /// Object pool for packet buffers. This is used to allocate memory for all
+    /// incoming and outgoing packets, and zerocoding buffers for those packets
+    /// </summary>
+    public class PacketBufferPool : ObjectPoolBase<UDPPacketBuffer>
+    {
+        private IPEndPoint EndPoint;
+
+        /// <summary>
+        /// Initialize the object pool in client mode
+        /// </summary>
+        /// <param name="endPoint">Server to connect to</param>
+        /// <param name="itemsPerSegment"></param>
+        /// <param name="minSegments"></param>
+        public PacketBufferPool(IPEndPoint endPoint, int itemsPerSegment, int minSegments)
+            : base()
+        {
+            EndPoint = endPoint;
+            Initialize(itemsPerSegment, minSegments, true, 1000 * 60 * 5);
+        }
+
+        /// <summary>
+        /// Initialize the object pool in server mode
+        /// </summary>
+        /// <param name="itemsPerSegment"></param>
+        /// <param name="minSegments"></param>
+        public PacketBufferPool(int itemsPerSegment, int minSegments)
+            : base()
+        {
+            EndPoint = null;
+            Initialize(itemsPerSegment, minSegments, true, 1000 * 60 * 5);
+        }
+
+        /// <summary>
+        /// Returns a packet buffer with EndPoint set if the buffer is in
+        /// client mode, or with EndPoint set to null in server mode
+        /// </summary>
+        /// <returns>Initialized UDPPacketBuffer object</returns>
+        protected override UDPPacketBuffer GetObjectInstance()
+        {
+            if (EndPoint != null)
+                // Client mode
+                return new UDPPacketBuffer(EndPoint);
+            else
+                // Server mode
+                return new UDPPacketBuffer();
+        }
+    }
+
+    public static class Pool
+    {
+        public static PacketBufferPool PoolInstance;
+
+        /// <summary>
+        /// Default constructor
+        /// </summary>
+        static Pool()
+        {
+            PoolInstance = new PacketBufferPool(new IPEndPoint(Settings.BIND_ADDR, 0), 16, 1);
+        }
+
+        /// <summary>
+        /// Check a packet buffer out of the pool
+        /// </summary>
+        /// <returns>A packet buffer object</returns>
+        public static WrappedObject<UDPPacketBuffer> CheckOut()
+        {
+            return PoolInstance.CheckOut();
+        }
+    }
+}
Index: InternalDictionary.cs
===================================================================
--- InternalDictionary.cs	(revision 2445)
+++ InternalDictionary.cs	(working copy)
@@ -1,298 +1,298 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// The InternalDictionary class is used through the library for storing key/value pairs.
-    /// It is intended to be a replacement for the generic Dictionary class and should 
-    /// be used in its place. It contains several methods for allowing access to the data from
-    /// outside the library that are read only and thread safe.
-    /// 
-    /// </summary>
-    /// <typeparam name="TKey">Key <see langword="Tkey"/></typeparam>
-    /// <typeparam name="TValue">Value <see langword="TValue"/></typeparam>
-    public class InternalDictionary<TKey, TValue>
-    {
-        /// <summary>Internal dictionary that this class wraps around. Do not
-        /// modify or enumerate the contents of this dictionary without locking</summary>
-        public Dictionary<TKey, TValue> Dictionary;
-
-        /// <summary>
-        /// Gets the number of Key/Value pairs contained in the <seealso cref="T:InternalDictionary"/>
-        /// </summary>
-        public int Count { get { return Dictionary.Count; } }
-
-        /// <summary>
-        /// Initializes a new instance of the <seealso cref="T:InternalDictionary"/> Class 
-        /// with the specified key/value, has the default initial capacity.
-        /// </summary>
-        /// <example>
-        /// <code>
-        /// // initialize a new InternalDictionary named testDict with a string as the key and an int as the value.
-        /// public InternalDictionary&lt;string, int&gt; testDict = new InternalDictionary&lt;string, int&gt;();
-        /// </code>
-        /// </example>
-        public InternalDictionary()
-        {
-            Dictionary = new Dictionary<TKey, TValue>();
-        }
-
-        /// <summary>
-        /// Initializes a new instance of the <seealso cref="T:InternalDictionary"/> Class 
-        /// with the specified key/value, has its initial valies copied from the specified 
-        /// <seealso cref="T:System.Collections.Generic.Dictionary"/>
-        /// </summary>
-        /// <param name="dictionary"><seealso cref="T:System.Collections.Generic.Dictionary"/>
-        /// to copy initial values from</param>
-        /// <example>
-        /// <code>
-        /// // initialize a new InternalDictionary named testAvName with a UUID as the key and an string as the value.
-        /// // populates with copied values from example KeyNameCache Dictionary.
-        /// 
-        /// // create source dictionary
-        /// Dictionary&lt;UUID, string&gt; KeyNameCache = new Dictionary&lt;UUID, string&gt;();
-        /// KeyNameCache.Add("8300f94a-7970-7810-cf2c-fc9aa6cdda24", "Jack Avatar");
-        /// KeyNameCache.Add("27ba1e40-13f7-0708-3e98-5819d780bd62", "Jill Avatar");
-        /// 
-        /// // Initialize new dictionary.
-        /// public InternalDictionary&lt;UUID, string&gt; testAvName = new InternalDictionary&lt;UUID, string&gt;(KeyNameCache);
-        /// </code>
-        /// </example>
-        public InternalDictionary(IDictionary<TKey, TValue> dictionary)
-        {
-            Dictionary = new Dictionary<TKey, TValue>(dictionary);
-        }
-
-        /// <summary>
-        /// Initializes a new instance of the <seealso cref="T:OpenMetaverse.InternalDictionary"/> Class 
-        /// with the specified key/value, With its initial capacity specified.
-        /// </summary>
-        /// <param name="capacity">Initial size of dictionary</param>
-        /// <example>
-        /// <code>
-        /// // initialize a new InternalDictionary named testDict with a string as the key and an int as the value, 
-        /// // initially allocated room for 10 entries.
-        /// public InternalDictionary&lt;string, int&gt; testDict = new InternalDictionary&lt;string, int&gt;(10);
-        /// </code>
-        /// </example>
-        public InternalDictionary(int capacity)
-        {
-            Dictionary = new Dictionary<TKey, TValue>(capacity);
-        }
-
-        /// <summary>
-        /// Try to get entry from <seealso cref="T:OpenMetaverse.InternalDictionary"/> with specified key 
-        /// </summary>
-        /// <param name="key">Key to use for lookup</param>
-        /// <param name="value">Value returned</param>
-        /// <returns><see langword="true"/> if specified key exists,  <see langword="false"/> if not found</returns>
-        /// <example>
-        /// <code>
-        /// // find your avatar using the Simulator.ObjectsAvatars InternalDictionary:
-        ///    Avatar av;
-        ///    if (Client.Network.CurrentSim.ObjectsAvatars.TryGetValue(Client.Self.AgentID, out av))
-        ///        Console.WriteLine("Found Avatar {0}", av.Name);
-        /// </code>
-        /// <seealso cref="Simulator.ObjectsAvatars"/>
-        /// </example>
-        public bool TryGetValue(TKey key, out TValue value)
-        {
-            return Dictionary.TryGetValue(key, out value);
-        }
-
-        /// <summary>
-        /// Finds the specified match.
-        /// </summary>
-        /// <param name="match">The match.</param>
-        /// <returns>Matched value</returns>
-        /// <example>
-        /// <code>
-        /// // use a delegate to find a prim in the ObjectsPrimitives InternalDictionary
-        /// // with the ID 95683496
-        /// uint findID = 95683496;
-        /// Primitive findPrim = sim.ObjectsPrimitives.Find(
-        ///             delegate(Primitive prim) { return prim.ID == findID; });
-        /// </code>
-        /// </example>
-        public TValue Find(Predicate<TValue> match)
-        {
-            lock (Dictionary)
-            {
-                foreach (TValue value in Dictionary.Values)
-                {
-                    if (match(value))
-                        return value;
-                }
-            }
-            return default(TValue);
-        }
-
-        /// <summary>Find All items in an <seealso cref="T:InternalDictionary"/></summary>
-        /// <param name="match">return matching items.</param>
-        /// <returns>a <seealso cref="T:System.Collections.Generic.List"/> containing found items.</returns>
-        /// <example>
-        /// Find All prims within 20 meters and store them in a List
-        /// <code>
-        /// int radius = 20;
-        /// List&lt;Primitive&gt; prims = Client.Network.CurrentSim.ObjectsPrimitives.FindAll(
-        ///         delegate(Primitive prim) {
-        ///             Vector3 pos = prim.Position;
-        ///             return ((prim.ParentID == 0) &amp;&amp; (pos != Vector3.Zero) &amp;&amp; (Vector3.Distance(pos, location) &lt; radius));
-        ///         }
-        ///    ); 
-        ///</code>
-        ///</example>
-        public List<TValue> FindAll(Predicate<TValue> match)
-        {
-            List<TValue> found = new List<TValue>();
-            lock (Dictionary)
-            {
-                foreach (KeyValuePair<TKey, TValue> kvp in Dictionary)
-                {
-                    if (match(kvp.Value))
-                        found.Add(kvp.Value);
-                }
-            }
-            return found;
-        }
-
-        /// <summary>Perform an <seealso cref="T:System.Action"/> on each entry in an <seealso cref="T:OpenMetaverse.InternalDictionary"/></summary>
-        /// <param name="action"><seealso cref="T:System.Action"/> to perform</param>
-        /// <example>
-        /// <code>
-        /// // Iterates over the ObjectsPrimitives InternalDictionary and prints out some information.
-        /// Client.Network.CurrentSim.ObjectsPrimitives.ForEach(
-        ///     delegate(Primitive prim)
-        ///     {
-        ///         if (prim.Text != null)
-        ///         {
-        ///             Console.WriteLine("NAME={0} ID = {1} TEXT = '{2}'", 
-        ///                 prim.PropertiesFamily.Name, prim.ID, prim.Text);
-        ///         }
-        ///     });
-        ///</code>
-        ///</example>
-        public void ForEach(Action<TValue> action)
-        {
-            lock (Dictionary)
-            {
-                foreach (TValue value in Dictionary.Values)
-                {
-                    action(value);
-                }
-            }
-        }
-
-        /// <summary>Perform an <seealso cref="T:System.Action"/> on each key of an <seealso cref="T:OpenMetaverse.InternalDictionary"/></summary>
-        /// <param name="action"><seealso cref="T:System.Action"/> to perform</param>
-        public void ForEach(Action<TKey> action)
-        {
-            lock (Dictionary)
-            {
-                foreach (TKey key in Dictionary.Keys)
-                {
-                    action(key);
-                }
-            }
-        }
-
-        /// <summary>Check if Key exists in Dictionary</summary>
-        /// <param name="key">Key to check for</param>
-        /// <returns><see langword="true"/> if found, <see langword="false"/> otherwise</returns>
-        public bool ContainsKey(TKey key)
-        {
-            lock(Dictionary)
-            return Dictionary.ContainsKey(key);
-        }
-
-        /// <summary>Check if Value exists in Dictionary</summary>
-        /// <param name="value">Value to check for</param>
-        /// <returns><see langword="true"/> if found, <see langword="false"/> otherwise</returns>
-        public bool ContainsValue(TValue value)
-        {
-            lock(Dictionary)
-            return Dictionary.ContainsValue(value);
-        }
-
-        /// <summary>
-        /// Adds the specified key to the dictionary, dictionary locking is not performed, 
-        /// <see cref="SafeAdd"/>
-        /// </summary>
-        /// <param name="key">The key</param>
-        /// <param name="value">The value</param>
-        internal void Add(TKey key, TValue value)
-        {
-            Dictionary.Add(key, value);
-        }
-
-        /// <summary>
-        /// Removes the specified key, dictionary locking is not performed
-        /// </summary>
-        /// <param name="key">The key.</param>
-        /// <returns><see langword="true"/> if successful, <see langword="false"/> otherwise</returns>
-        internal bool Remove(TKey key)
-        {
-            return Dictionary.Remove(key);
-        }
-
-        /// <summary>
-        /// Safely add a key/value pair to the dictionary
-        /// </summary>
-        /// <param name="key">The key</param>
-        /// <param name="value">The value</param>
-        internal void SafeAdd(TKey key, TValue value)
-        {
-            lock (Dictionary)
-                Dictionary.Add(key, value);
-        }
-
-        /// <summary>
-        /// Safely Removes an item from the InternalDictionary
-        /// </summary>
-        /// <param name="key">The key</param>
-        /// <returns><see langword="true"/> if successful, <see langword="false"/> otherwise</returns>
-        internal bool SafeRemove(TKey key)
-        {
-            lock (Dictionary)
-                return Dictionary.Remove(key);
-        }
-
-        /// <summary>
-        /// Indexer for the dictionary
-        /// </summary>
-        /// <param name="key">The key</param>
-        /// <returns>The value</returns>
-        internal TValue this[TKey key]
-        {
-            get { return Dictionary[key]; }
-            set { Dictionary[key] = value; }
-        }
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// The InternalDictionary class is used through the library for storing key/value pairs.
+    /// It is intended to be a replacement for the generic Dictionary class and should 
+    /// be used in its place. It contains several methods for allowing access to the data from
+    /// outside the library that are read only and thread safe.
+    /// 
+    /// </summary>
+    /// <typeparam name="TKey">Key <see langword="Tkey"/></typeparam>
+    /// <typeparam name="TValue">Value <see langword="TValue"/></typeparam>
+    public class InternalDictionary<TKey, TValue>
+    {
+        /// <summary>Internal dictionary that this class wraps around. Do not
+        /// modify or enumerate the contents of this dictionary without locking</summary>
+        public Dictionary<TKey, TValue> Dictionary;
+
+        /// <summary>
+        /// Gets the number of Key/Value pairs contained in the <seealso cref="T:InternalDictionary"/>
+        /// </summary>
+        public int Count { get { return Dictionary.Count; } }
+
+        /// <summary>
+        /// Initializes a new instance of the <seealso cref="T:InternalDictionary"/> Class 
+        /// with the specified key/value, has the default initial capacity.
+        /// </summary>
+        /// <example>
+        /// <code>
+        /// // initialize a new InternalDictionary named testDict with a string as the key and an int as the value.
+        /// public InternalDictionary&lt;string, int&gt; testDict = new InternalDictionary&lt;string, int&gt;();
+        /// </code>
+        /// </example>
+        public InternalDictionary()
+        {
+            Dictionary = new Dictionary<TKey, TValue>();
+        }
+
+        /// <summary>
+        /// Initializes a new instance of the <seealso cref="T:InternalDictionary"/> Class 
+        /// with the specified key/value, has its initial valies copied from the specified 
+        /// <seealso cref="T:System.Collections.Generic.Dictionary"/>
+        /// </summary>
+        /// <param name="dictionary"><seealso cref="T:System.Collections.Generic.Dictionary"/>
+        /// to copy initial values from</param>
+        /// <example>
+        /// <code>
+        /// // initialize a new InternalDictionary named testAvName with a UUID as the key and an string as the value.
+        /// // populates with copied values from example KeyNameCache Dictionary.
+        /// 
+        /// // create source dictionary
+        /// Dictionary&lt;UUID, string&gt; KeyNameCache = new Dictionary&lt;UUID, string&gt;();
+        /// KeyNameCache.Add("8300f94a-7970-7810-cf2c-fc9aa6cdda24", "Jack Avatar");
+        /// KeyNameCache.Add("27ba1e40-13f7-0708-3e98-5819d780bd62", "Jill Avatar");
+        /// 
+        /// // Initialize new dictionary.
+        /// public InternalDictionary&lt;UUID, string&gt; testAvName = new InternalDictionary&lt;UUID, string&gt;(KeyNameCache);
+        /// </code>
+        /// </example>
+        public InternalDictionary(IDictionary<TKey, TValue> dictionary)
+        {
+            Dictionary = new Dictionary<TKey, TValue>(dictionary);
+        }
+
+        /// <summary>
+        /// Initializes a new instance of the <seealso cref="T:OpenMetaverse.InternalDictionary"/> Class 
+        /// with the specified key/value, With its initial capacity specified.
+        /// </summary>
+        /// <param name="capacity">Initial size of dictionary</param>
+        /// <example>
+        /// <code>
+        /// // initialize a new InternalDictionary named testDict with a string as the key and an int as the value, 
+        /// // initially allocated room for 10 entries.
+        /// public InternalDictionary&lt;string, int&gt; testDict = new InternalDictionary&lt;string, int&gt;(10);
+        /// </code>
+        /// </example>
+        public InternalDictionary(int capacity)
+        {
+            Dictionary = new Dictionary<TKey, TValue>(capacity);
+        }
+
+        /// <summary>
+        /// Try to get entry from <seealso cref="T:OpenMetaverse.InternalDictionary"/> with specified key 
+        /// </summary>
+        /// <param name="key">Key to use for lookup</param>
+        /// <param name="value">Value returned</param>
+        /// <returns><see langword="true"/> if specified key exists,  <see langword="false"/> if not found</returns>
+        /// <example>
+        /// <code>
+        /// // find your avatar using the Simulator.ObjectsAvatars InternalDictionary:
+        ///    Avatar av;
+        ///    if (Client.Network.CurrentSim.ObjectsAvatars.TryGetValue(Client.Self.AgentID, out av))
+        ///        Console.WriteLine("Found Avatar {0}", av.Name);
+        /// </code>
+        /// <seealso cref="Simulator.ObjectsAvatars"/>
+        /// </example>
+        public bool TryGetValue(TKey key, out TValue value)
+        {
+            return Dictionary.TryGetValue(key, out value);
+        }
+
+        /// <summary>
+        /// Finds the specified match.
+        /// </summary>
+        /// <param name="match">The match.</param>
+        /// <returns>Matched value</returns>
+        /// <example>
+        /// <code>
+        /// // use a delegate to find a prim in the ObjectsPrimitives InternalDictionary
+        /// // with the ID 95683496
+        /// uint findID = 95683496;
+        /// Primitive findPrim = sim.ObjectsPrimitives.Find(
+        ///             delegate(Primitive prim) { return prim.ID == findID; });
+        /// </code>
+        /// </example>
+        public TValue Find(Predicate<TValue> match)
+        {
+            lock (Dictionary)
+            {
+                foreach (TValue value in Dictionary.Values)
+                {
+                    if (match(value))
+                        return value;
+                }
+            }
+            return default(TValue);
+        }
+
+        /// <summary>Find All items in an <seealso cref="T:InternalDictionary"/></summary>
+        /// <param name="match">return matching items.</param>
+        /// <returns>a <seealso cref="T:System.Collections.Generic.List"/> containing found items.</returns>
+        /// <example>
+        /// Find All prims within 20 meters and store them in a List
+        /// <code>
+        /// int radius = 20;
+        /// List&lt;Primitive&gt; prims = Client.Network.CurrentSim.ObjectsPrimitives.FindAll(
+        ///         delegate(Primitive prim) {
+        ///             Vector3 pos = prim.Position;
+        ///             return ((prim.ParentID == 0) &amp;&amp; (pos != Vector3.Zero) &amp;&amp; (Vector3.Distance(pos, location) &lt; radius));
+        ///         }
+        ///    ); 
+        ///</code>
+        ///</example>
+        public List<TValue> FindAll(Predicate<TValue> match)
+        {
+            List<TValue> found = new List<TValue>();
+            lock (Dictionary)
+            {
+                foreach (KeyValuePair<TKey, TValue> kvp in Dictionary)
+                {
+                    if (match(kvp.Value))
+                        found.Add(kvp.Value);
+                }
+            }
+            return found;
+        }
+
+        /// <summary>Perform an <seealso cref="T:System.Action"/> on each entry in an <seealso cref="T:OpenMetaverse.InternalDictionary"/></summary>
+        /// <param name="action"><seealso cref="T:System.Action"/> to perform</param>
+        /// <example>
+        /// <code>
+        /// // Iterates over the ObjectsPrimitives InternalDictionary and prints out some information.
+        /// Client.Network.CurrentSim.ObjectsPrimitives.ForEach(
+        ///     delegate(Primitive prim)
+        ///     {
+        ///         if (prim.Text != null)
+        ///         {
+        ///             Console.WriteLine("NAME={0} ID = {1} TEXT = '{2}'", 
+        ///                 prim.PropertiesFamily.Name, prim.ID, prim.Text);
+        ///         }
+        ///     });
+        ///</code>
+        ///</example>
+        public void ForEach(Action<TValue> action)
+        {
+            lock (Dictionary)
+            {
+                foreach (TValue value in Dictionary.Values)
+                {
+                    action(value);
+                }
+            }
+        }
+
+        /// <summary>Perform an <seealso cref="T:System.Action"/> on each key of an <seealso cref="T:OpenMetaverse.InternalDictionary"/></summary>
+        /// <param name="action"><seealso cref="T:System.Action"/> to perform</param>
+        public void ForEach(Action<TKey> action)
+        {
+            lock (Dictionary)
+            {
+                foreach (TKey key in Dictionary.Keys)
+                {
+                    action(key);
+                }
+            }
+        }
+
+        /// <summary>Check if Key exists in Dictionary</summary>
+        /// <param name="key">Key to check for</param>
+        /// <returns><see langword="true"/> if found, <see langword="false"/> otherwise</returns>
+        public bool ContainsKey(TKey key)
+        {
+            lock(Dictionary)
+            return Dictionary.ContainsKey(key);
+        }
+
+        /// <summary>Check if Value exists in Dictionary</summary>
+        /// <param name="value">Value to check for</param>
+        /// <returns><see langword="true"/> if found, <see langword="false"/> otherwise</returns>
+        public bool ContainsValue(TValue value)
+        {
+            lock(Dictionary)
+            return Dictionary.ContainsValue(value);
+        }
+
+        /// <summary>
+        /// Adds the specified key to the dictionary, dictionary locking is not performed, 
+        /// <see cref="SafeAdd"/>
+        /// </summary>
+        /// <param name="key">The key</param>
+        /// <param name="value">The value</param>
+        internal void Add(TKey key, TValue value)
+        {
+            Dictionary.Add(key, value);
+        }
+
+        /// <summary>
+        /// Removes the specified key, dictionary locking is not performed
+        /// </summary>
+        /// <param name="key">The key.</param>
+        /// <returns><see langword="true"/> if successful, <see langword="false"/> otherwise</returns>
+        internal bool Remove(TKey key)
+        {
+            return Dictionary.Remove(key);
+        }
+
+        /// <summary>
+        /// Safely add a key/value pair to the dictionary
+        /// </summary>
+        /// <param name="key">The key</param>
+        /// <param name="value">The value</param>
+        internal void SafeAdd(TKey key, TValue value)
+        {
+            lock (Dictionary)
+                Dictionary.Add(key, value);
+        }
+
+        /// <summary>
+        /// Safely Removes an item from the InternalDictionary
+        /// </summary>
+        /// <param name="key">The key</param>
+        /// <returns><see langword="true"/> if successful, <see langword="false"/> otherwise</returns>
+        internal bool SafeRemove(TKey key)
+        {
+            lock (Dictionary)
+                return Dictionary.Remove(key);
+        }
+
+        /// <summary>
+        /// Indexer for the dictionary
+        /// </summary>
+        /// <param name="key">The key</param>
+        /// <returns>The value</returns>
+        internal TValue this[TKey key]
+        {
+            get { return Dictionary[key]; }
+            set { Dictionary[key] = value; }
+        }
+    }
+}
Index: CoordinateFrame.cs
===================================================================
--- CoordinateFrame.cs	(revision 2445)
+++ CoordinateFrame.cs	(working copy)
@@ -1,283 +1,283 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-
-namespace OpenMetaverse
-{
-    public class CoordinateFrame
-    {
-        public static readonly Vector3 X_AXIS = new Vector3(1f, 0f, 0f);
-        public static readonly Vector3 Y_AXIS = new Vector3(0f, 1f, 0f);
-        public static readonly Vector3 Z_AXIS = new Vector3(0f, 0f, 1f);
-
-        /// <summary>Origin position of this coordinate frame</summary>
-        public Vector3 Origin
-        {
-            get { return origin; }
-            set
-            {
-                if (!value.IsFinite())
-                    throw new ArgumentException("Non-finite in CoordinateFrame.Origin assignment");
-                origin = value;
-            }
-        }
-        /// <summary>X axis of this coordinate frame, or Forward/At in grid terms</summary>
-        public Vector3 XAxis
-        {
-            get { return xAxis; }
-            set
-            {
-                if (!value.IsFinite())
-                    throw new ArgumentException("Non-finite in CoordinateFrame.XAxis assignment");
-                xAxis = value;
-            }
-        }
-        /// <summary>Y axis of this coordinate frame, or Left in grid terms</summary>
-        public Vector3 YAxis
-        {
-            get { return yAxis; }
-            set
-            {
-                if (!value.IsFinite())
-                    throw new ArgumentException("Non-finite in CoordinateFrame.YAxis assignment");
-                yAxis = value;
-            }
-        }
-        /// <summary>Z axis of this coordinate frame, or Up in grid terms</summary>
-        public Vector3 ZAxis
-        {
-            get { return zAxis; }
-            set
-            {
-                if (!value.IsFinite())
-                    throw new ArgumentException("Non-finite in CoordinateFrame.ZAxis assignment");
-                zAxis = value;
-            }
-        }
-
-        protected Vector3 origin;
-        protected Vector3 xAxis;
-        protected Vector3 yAxis;
-        protected Vector3 zAxis;
-
-        #region Constructors
-
-        public CoordinateFrame(Vector3 origin)
-        {
-            this.origin = origin;
-            xAxis = X_AXIS;
-            yAxis = Y_AXIS;
-            zAxis = Z_AXIS;
-
-            if (!this.origin.IsFinite())
-                throw new ArgumentException("Non-finite in CoordinateFrame constructor");
-        }
-
-        public CoordinateFrame(Vector3 origin, Vector3 direction)
-        {
-            this.origin = origin;
-            LookDirection(direction);
-
-            if (!IsFinite())
-                throw new ArgumentException("Non-finite in CoordinateFrame constructor");
-        }
-
-        public CoordinateFrame(Vector3 origin, Vector3 xAxis, Vector3 yAxis, Vector3 zAxis)
-        {
-            this.origin = origin;
-            this.xAxis = xAxis;
-            this.yAxis = yAxis;
-            this.zAxis = zAxis;
-
-            if (!IsFinite())
-                throw new ArgumentException("Non-finite in CoordinateFrame constructor");
-        }
-
-        public CoordinateFrame(Vector3 origin, Matrix4 rotation)
-        {
-            this.origin = origin;
-            xAxis = rotation.AtAxis;
-            yAxis = rotation.LeftAxis;
-            zAxis = rotation.UpAxis;
-
-            if (!IsFinite())
-                throw new ArgumentException("Non-finite in CoordinateFrame constructor");
-        }
-
-        public CoordinateFrame(Vector3 origin, Quaternion rotation)
-        {
-            Matrix4 m = Matrix4.CreateFromQuaternion(rotation);
-
-            this.origin = origin;
-            xAxis = m.AtAxis;
-            yAxis = m.LeftAxis;
-            zAxis = m.UpAxis;
-
-            if (!IsFinite())
-                throw new ArgumentException("Non-finite in CoordinateFrame constructor");
-        }
-
-        #endregion Constructors
-
-        #region Public Methods
-
-        public void ResetAxes()
-        {
-            xAxis = X_AXIS;
-            yAxis = Y_AXIS;
-            zAxis = Z_AXIS;
-        }
-
-        public void Rotate(float angle, Vector3 rotationAxis)
-        {
-            Quaternion q = Quaternion.CreateFromAxisAngle(rotationAxis, angle);
-            Rotate(q);
-        }
-
-        public void Rotate(Quaternion q)
-        {
-            Matrix4 m = Matrix4.CreateFromQuaternion(q);
-            Rotate(m);
-        }
-
-        public void Rotate(Matrix4 m)
-        {
-            xAxis = Vector3.Transform(xAxis, m);
-            yAxis = Vector3.Transform(yAxis, m);
-
-            Orthonormalize();
-
-            if (!IsFinite())
-                throw new Exception("Non-finite in CoordinateFrame.Rotate()");
-        }
-
-        public void Roll(float angle)
-        {
-            Quaternion q = Quaternion.CreateFromAxisAngle(xAxis, angle);
-            Matrix4 m = Matrix4.CreateFromQuaternion(q);
-            Rotate(m);
-
-            if (!yAxis.IsFinite() || !zAxis.IsFinite())
-                throw new Exception("Non-finite in CoordinateFrame.Roll()");
-        }
-
-        public void Pitch(float angle)
-        {
-            Quaternion q = Quaternion.CreateFromAxisAngle(yAxis, angle);
-            Matrix4 m = Matrix4.CreateFromQuaternion(q);
-            Rotate(m);
-
-            if (!xAxis.IsFinite() || !zAxis.IsFinite())
-                throw new Exception("Non-finite in CoordinateFrame.Pitch()");
-        }
-
-        public void Yaw(float angle)
-        {
-            Quaternion q = Quaternion.CreateFromAxisAngle(zAxis, angle);
-            Matrix4 m = Matrix4.CreateFromQuaternion(q);
-            Rotate(m);
-
-            if (!xAxis.IsFinite() || !yAxis.IsFinite())
-                throw new Exception("Non-finite in CoordinateFrame.Yaw()");
-        }
-
-        public void LookDirection(Vector3 at)
-        {
-            LookDirection(at, Z_AXIS);
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="at">Looking direction, must be a normalized vector</param>
-        /// <param name="upDirection">Up direction, must be a normalized vector</param>
-        public void LookDirection(Vector3 at, Vector3 upDirection)
-        {
-            // The two parameters cannot be parallel
-            Vector3 left = Vector3.Cross(upDirection, at);
-            if (left == Vector3.Zero)
-            {
-                // Prevent left from being zero
-                at.X += 0.01f;
-                at.Normalize();
-                left = Vector3.Cross(upDirection, at);
-            }
-            left.Normalize();
-
-            xAxis = at;
-            yAxis = left;
-            zAxis = Vector3.Cross(at, left);
-        }
-
-        /// <summary>
-        /// Align the coordinate frame X and Y axis with a given rotation
-        /// around the Z axis in radians
-        /// </summary>
-        /// <param name="heading">Absolute rotation around the Z axis in
-        /// radians</param>
-        public void LookDirection(double heading)
-        {
-            yAxis.X = (float)Math.Cos(heading);
-            yAxis.Y = (float)Math.Sin(heading);
-            xAxis.X = (float)-Math.Sin(heading);
-            xAxis.Y = (float)Math.Cos(heading);
-        }
-
-        public void LookAt(Vector3 origin, Vector3 target)
-        {
-            LookAt(origin, target, new Vector3(0f, 0f, 1f));
-        }
-
-        public void LookAt(Vector3 origin, Vector3 target, Vector3 upDirection)
-        {
-            this.origin = origin;
-            Vector3 at = new Vector3(target - origin);
-            at.Normalize();
-
-            LookDirection(at, upDirection);
-        }
-
-        #endregion Public Methods
-
-        protected bool IsFinite()
-        {
-            if (xAxis.IsFinite() && yAxis.IsFinite() && zAxis.IsFinite())
-                return true;
-            else
-                return false;
-        }
-
-        protected void Orthonormalize()
-        {
-            // Make sure the axis are orthagonal and normalized
-            xAxis.Normalize();
-            yAxis -= xAxis * (xAxis * yAxis);
-            yAxis.Normalize();
-            zAxis = Vector3.Cross(xAxis, yAxis);
-        }
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+
+namespace OpenMetaverse
+{
+    public class CoordinateFrame
+    {
+        public static readonly Vector3 X_AXIS = new Vector3(1f, 0f, 0f);
+        public static readonly Vector3 Y_AXIS = new Vector3(0f, 1f, 0f);
+        public static readonly Vector3 Z_AXIS = new Vector3(0f, 0f, 1f);
+
+        /// <summary>Origin position of this coordinate frame</summary>
+        public Vector3 Origin
+        {
+            get { return origin; }
+            set
+            {
+                if (!value.IsFinite())
+                    throw new ArgumentException("Non-finite in CoordinateFrame.Origin assignment");
+                origin = value;
+            }
+        }
+        /// <summary>X axis of this coordinate frame, or Forward/At in grid terms</summary>
+        public Vector3 XAxis
+        {
+            get { return xAxis; }
+            set
+            {
+                if (!value.IsFinite())
+                    throw new ArgumentException("Non-finite in CoordinateFrame.XAxis assignment");
+                xAxis = value;
+            }
+        }
+        /// <summary>Y axis of this coordinate frame, or Left in grid terms</summary>
+        public Vector3 YAxis
+        {
+            get { return yAxis; }
+            set
+            {
+                if (!value.IsFinite())
+                    throw new ArgumentException("Non-finite in CoordinateFrame.YAxis assignment");
+                yAxis = value;
+            }
+        }
+        /// <summary>Z axis of this coordinate frame, or Up in grid terms</summary>
+        public Vector3 ZAxis
+        {
+            get { return zAxis; }
+            set
+            {
+                if (!value.IsFinite())
+                    throw new ArgumentException("Non-finite in CoordinateFrame.ZAxis assignment");
+                zAxis = value;
+            }
+        }
+
+        protected Vector3 origin;
+        protected Vector3 xAxis;
+        protected Vector3 yAxis;
+        protected Vector3 zAxis;
+
+        #region Constructors
+
+        public CoordinateFrame(Vector3 origin)
+        {
+            this.origin = origin;
+            xAxis = X_AXIS;
+            yAxis = Y_AXIS;
+            zAxis = Z_AXIS;
+
+            if (!this.origin.IsFinite())
+                throw new ArgumentException("Non-finite in CoordinateFrame constructor");
+        }
+
+        public CoordinateFrame(Vector3 origin, Vector3 direction)
+        {
+            this.origin = origin;
+            LookDirection(direction);
+
+            if (!IsFinite())
+                throw new ArgumentException("Non-finite in CoordinateFrame constructor");
+        }
+
+        public CoordinateFrame(Vector3 origin, Vector3 xAxis, Vector3 yAxis, Vector3 zAxis)
+        {
+            this.origin = origin;
+            this.xAxis = xAxis;
+            this.yAxis = yAxis;
+            this.zAxis = zAxis;
+
+            if (!IsFinite())
+                throw new ArgumentException("Non-finite in CoordinateFrame constructor");
+        }
+
+        public CoordinateFrame(Vector3 origin, Matrix4 rotation)
+        {
+            this.origin = origin;
+            xAxis = rotation.AtAxis;
+            yAxis = rotation.LeftAxis;
+            zAxis = rotation.UpAxis;
+
+            if (!IsFinite())
+                throw new ArgumentException("Non-finite in CoordinateFrame constructor");
+        }
+
+        public CoordinateFrame(Vector3 origin, Quaternion rotation)
+        {
+            Matrix4 m = Matrix4.CreateFromQuaternion(rotation);
+
+            this.origin = origin;
+            xAxis = m.AtAxis;
+            yAxis = m.LeftAxis;
+            zAxis = m.UpAxis;
+
+            if (!IsFinite())
+                throw new ArgumentException("Non-finite in CoordinateFrame constructor");
+        }
+
+        #endregion Constructors
+
+        #region Public Methods
+
+        public void ResetAxes()
+        {
+            xAxis = X_AXIS;
+            yAxis = Y_AXIS;
+            zAxis = Z_AXIS;
+        }
+
+        public void Rotate(float angle, Vector3 rotationAxis)
+        {
+            Quaternion q = Quaternion.CreateFromAxisAngle(rotationAxis, angle);
+            Rotate(q);
+        }
+
+        public void Rotate(Quaternion q)
+        {
+            Matrix4 m = Matrix4.CreateFromQuaternion(q);
+            Rotate(m);
+        }
+
+        public void Rotate(Matrix4 m)
+        {
+            xAxis = Vector3.Transform(xAxis, m);
+            yAxis = Vector3.Transform(yAxis, m);
+
+            Orthonormalize();
+
+            if (!IsFinite())
+                throw new Exception("Non-finite in CoordinateFrame.Rotate()");
+        }
+
+        public void Roll(float angle)
+        {
+            Quaternion q = Quaternion.CreateFromAxisAngle(xAxis, angle);
+            Matrix4 m = Matrix4.CreateFromQuaternion(q);
+            Rotate(m);
+
+            if (!yAxis.IsFinite() || !zAxis.IsFinite())
+                throw new Exception("Non-finite in CoordinateFrame.Roll()");
+        }
+
+        public void Pitch(float angle)
+        {
+            Quaternion q = Quaternion.CreateFromAxisAngle(yAxis, angle);
+            Matrix4 m = Matrix4.CreateFromQuaternion(q);
+            Rotate(m);
+
+            if (!xAxis.IsFinite() || !zAxis.IsFinite())
+                throw new Exception("Non-finite in CoordinateFrame.Pitch()");
+        }
+
+        public void Yaw(float angle)
+        {
+            Quaternion q = Quaternion.CreateFromAxisAngle(zAxis, angle);
+            Matrix4 m = Matrix4.CreateFromQuaternion(q);
+            Rotate(m);
+
+            if (!xAxis.IsFinite() || !yAxis.IsFinite())
+                throw new Exception("Non-finite in CoordinateFrame.Yaw()");
+        }
+
+        public void LookDirection(Vector3 at)
+        {
+            LookDirection(at, Z_AXIS);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="at">Looking direction, must be a normalized vector</param>
+        /// <param name="upDirection">Up direction, must be a normalized vector</param>
+        public void LookDirection(Vector3 at, Vector3 upDirection)
+        {
+            // The two parameters cannot be parallel
+            Vector3 left = Vector3.Cross(upDirection, at);
+            if (left == Vector3.Zero)
+            {
+                // Prevent left from being zero
+                at.X += 0.01f;
+                at.Normalize();
+                left = Vector3.Cross(upDirection, at);
+            }
+            left.Normalize();
+
+            xAxis = at;
+            yAxis = left;
+            zAxis = Vector3.Cross(at, left);
+        }
+
+        /// <summary>
+        /// Align the coordinate frame X and Y axis with a given rotation
+        /// around the Z axis in radians
+        /// </summary>
+        /// <param name="heading">Absolute rotation around the Z axis in
+        /// radians</param>
+        public void LookDirection(double heading)
+        {
+            yAxis.X = (float)Math.Cos(heading);
+            yAxis.Y = (float)Math.Sin(heading);
+            xAxis.X = (float)-Math.Sin(heading);
+            xAxis.Y = (float)Math.Cos(heading);
+        }
+
+        public void LookAt(Vector3 origin, Vector3 target)
+        {
+            LookAt(origin, target, new Vector3(0f, 0f, 1f));
+        }
+
+        public void LookAt(Vector3 origin, Vector3 target, Vector3 upDirection)
+        {
+            this.origin = origin;
+            Vector3 at = new Vector3(target - origin);
+            at.Normalize();
+
+            LookDirection(at, upDirection);
+        }
+
+        #endregion Public Methods
+
+        protected bool IsFinite()
+        {
+            if (xAxis.IsFinite() && yAxis.IsFinite() && zAxis.IsFinite())
+                return true;
+            else
+                return false;
+        }
+
+        protected void Orthonormalize()
+        {
+            // Make sure the axis are orthagonal and normalized
+            xAxis.Normalize();
+            yAxis -= xAxis * (xAxis * yAxis);
+            yAxis.Normalize();
+            zAxis = Vector3.Cross(xAxis, yAxis);
+        }
+    }
+}
Index: AgentManagerCamera.cs
===================================================================
--- AgentManagerCamera.cs	(revision 2445)
+++ AgentManagerCamera.cs	(working copy)
@@ -1,136 +1,136 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-
-namespace OpenMetaverse
-{
-    public partial class AgentManager
-    {
-        public partial class AgentMovement
-        {
-            /// <summary>
-            /// Camera controls for the agent, mostly a thin wrapper around
-            /// CoordinateFrame. This class is only responsible for state
-            /// tracking and math, it does not send any packets
-            /// </summary>
-            public class AgentCamera
-            {
-                /// <summary></summary>
-                public float Far;
-
-                /// <summary>The camera is a local frame of reference inside of
-                /// the larger grid space. This is where the math happens</summary>
-                private CoordinateFrame Frame;
-
-                /// <summary></summary>
-                public Vector3 Position
-                {
-                    get { return Frame.Origin; }
-                    set { Frame.Origin = value; }
-                }
-                /// <summary></summary>
-                public Vector3 AtAxis
-                {
-                    get { return Frame.YAxis; }
-                    set { Frame.YAxis = value; }
-                }
-                /// <summary></summary>
-                public Vector3 LeftAxis
-                {
-                    get { return Frame.XAxis; }
-                    set { Frame.XAxis = value; }
-                }
-                /// <summary></summary>
-                public Vector3 UpAxis
-                {
-                    get { return Frame.ZAxis; }
-                    set { Frame.ZAxis = value; }
-                }
-
-                /// <summary>
-                /// Default constructor
-                /// </summary>
-                public AgentCamera()
-                {
-                    Frame = new CoordinateFrame(new Vector3(128f, 128f, 20f));
-                    Far = 128f;
-                }
-
-                public void Roll(float angle)
-                {
-                    Frame.Roll(angle);
-                }
-
-                public void Pitch(float angle)
-                {
-                    Frame.Pitch(angle);
-                }
-
-                public void Yaw(float angle)
-                {
-                    Frame.Yaw(angle);
-                }
-
-                public void LookDirection(Vector3 target)
-                {
-                    Frame.LookDirection(target);
-                }
-
-                public void LookDirection(Vector3 target, Vector3 upDirection)
-                {
-                    Frame.LookDirection(target, upDirection);
-                }
-
-                public void LookDirection(double heading)
-                {
-                    Frame.LookDirection(heading);
-                }
-
-                public void LookAt(Vector3 position, Vector3 target)
-                {
-                    Frame.LookAt(position, target);
-                }
-
-                public void LookAt(Vector3 position, Vector3 target, Vector3 upDirection)
-                {
-                    Frame.LookAt(position, target, upDirection);
-                }
-
-                public void SetPositionOrientation(Vector3 position, float roll, float pitch, float yaw)
-                {
-                    Frame.Origin = position;
-
-                    Frame.ResetAxes();
-
-                    Frame.Roll(roll);
-                    Frame.Pitch(pitch);
-                    Frame.Yaw(yaw);
-                }
-            }
-        }
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+
+namespace OpenMetaverse
+{
+    public partial class AgentManager
+    {
+        public partial class AgentMovement
+        {
+            /// <summary>
+            /// Camera controls for the agent, mostly a thin wrapper around
+            /// CoordinateFrame. This class is only responsible for state
+            /// tracking and math, it does not send any packets
+            /// </summary>
+            public class AgentCamera
+            {
+                /// <summary></summary>
+                public float Far;
+
+                /// <summary>The camera is a local frame of reference inside of
+                /// the larger grid space. This is where the math happens</summary>
+                private CoordinateFrame Frame;
+
+                /// <summary></summary>
+                public Vector3 Position
+                {
+                    get { return Frame.Origin; }
+                    set { Frame.Origin = value; }
+                }
+                /// <summary></summary>
+                public Vector3 AtAxis
+                {
+                    get { return Frame.YAxis; }
+                    set { Frame.YAxis = value; }
+                }
+                /// <summary></summary>
+                public Vector3 LeftAxis
+                {
+                    get { return Frame.XAxis; }
+                    set { Frame.XAxis = value; }
+                }
+                /// <summary></summary>
+                public Vector3 UpAxis
+                {
+                    get { return Frame.ZAxis; }
+                    set { Frame.ZAxis = value; }
+                }
+
+                /// <summary>
+                /// Default constructor
+                /// </summary>
+                public AgentCamera()
+                {
+                    Frame = new CoordinateFrame(new Vector3(128f, 128f, 20f));
+                    Far = 128f;
+                }
+
+                public void Roll(float angle)
+                {
+                    Frame.Roll(angle);
+                }
+
+                public void Pitch(float angle)
+                {
+                    Frame.Pitch(angle);
+                }
+
+                public void Yaw(float angle)
+                {
+                    Frame.Yaw(angle);
+                }
+
+                public void LookDirection(Vector3 target)
+                {
+                    Frame.LookDirection(target);
+                }
+
+                public void LookDirection(Vector3 target, Vector3 upDirection)
+                {
+                    Frame.LookDirection(target, upDirection);
+                }
+
+                public void LookDirection(double heading)
+                {
+                    Frame.LookDirection(heading);
+                }
+
+                public void LookAt(Vector3 position, Vector3 target)
+                {
+                    Frame.LookAt(position, target);
+                }
+
+                public void LookAt(Vector3 position, Vector3 target, Vector3 upDirection)
+                {
+                    Frame.LookAt(position, target, upDirection);
+                }
+
+                public void SetPositionOrientation(Vector3 position, float roll, float pitch, float yaw)
+                {
+                    Frame.Origin = position;
+
+                    Frame.ResetAxes();
+
+                    Frame.Roll(roll);
+                    Frame.Pitch(pitch);
+                    Frame.Yaw(yaw);
+                }
+            }
+        }
+    }
+}
Index: Animations.cs
===================================================================
--- Animations.cs	(revision 2445)
+++ Animations.cs	(working copy)
@@ -1,307 +1,307 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// Static pre-defined animations available to all agents
-    /// </summary>
-    public static class Animations
-    {
-        /// <summary>Agent with afraid expression on face</summary>
-        public readonly static UUID AFRAID = new UUID("6b61c8e8-4747-0d75-12d7-e49ff207a4ca");
-        /// <summary>Agent aiming a bazooka (right handed)</summary>
-        public readonly static UUID AIM_BAZOOKA_R = new UUID("b5b4a67d-0aee-30d2-72cd-77b333e932ef");
-        /// <summary>Agent aiming a bow (left handed)</summary>
-        public readonly static UUID AIM_BOW_L = new UUID("46bb4359-de38-4ed8-6a22-f1f52fe8f506");
-        /// <summary>Agent aiming a hand gun (right handed)</summary>
-        public readonly static UUID AIM_HANDGUN_R = new UUID("3147d815-6338-b932-f011-16b56d9ac18b");
-        /// <summary>Agent aiming a rifle (right handed)</summary>
-        public readonly static UUID AIM_RIFLE_R = new UUID("ea633413-8006-180a-c3ba-96dd1d756720");
-        /// <summary>Agent with angry expression on face</summary>
-        public readonly static UUID ANGRY = new UUID("5747a48e-073e-c331-f6f3-7c2149613d3e");
-        /// <summary>Agent hunched over (away)</summary>
-        public readonly static UUID AWAY = new UUID("fd037134-85d4-f241-72c6-4f42164fedee");
-        /// <summary>Agent doing a backflip</summary>
-        public readonly static UUID BACKFLIP = new UUID("c4ca6188-9127-4f31-0158-23c4e2f93304");
-        /// <summary>Agent laughing while holding belly</summary>
-        public readonly static UUID BELLY_LAUGH = new UUID("18b3a4b5-b463-bd48-e4b6-71eaac76c515");
-        /// <summary>Agent blowing a kiss</summary>
-        public readonly static UUID BLOW_KISS = new UUID("db84829b-462c-ee83-1e27-9bbee66bd624");
-        /// <summary>Agent with bored expression on face</summary>
-        public readonly static UUID BORED = new UUID("b906c4ba-703b-1940-32a3-0c7f7d791510");
-        /// <summary>Agent bowing to audience</summary>
-        public readonly static UUID BOW = new UUID("82e99230-c906-1403-4d9c-3889dd98daba");
-        /// <summary>Agent brushing himself/herself off</summary>
-        public readonly static UUID BRUSH = new UUID("349a3801-54f9-bf2c-3bd0-1ac89772af01");
-        /// <summary>Agent in busy mode</summary>
-        public readonly static UUID BUSY = new UUID("efcf670c-2d18-8128-973a-034ebc806b67");
-        /// <summary>Agent clapping hands</summary>
-        public readonly static UUID CLAP = new UUID("9b0c1c4e-8ac7-7969-1494-28c874c4f668");
-        /// <summary>Agent doing a curtsey bow</summary>
-        public readonly static UUID COURTBOW = new UUID("9ba1c942-08be-e43a-fb29-16ad440efc50");
-        /// <summary>Agent crouching</summary>
-        public readonly static UUID CROUCH = new UUID("201f3fdf-cb1f-dbec-201f-7333e328ae7c");
-        /// <summary>Agent crouching while walking</summary>
-        public readonly static UUID CROUCHWALK = new UUID("47f5f6fb-22e5-ae44-f871-73aaaf4a6022");
-        /// <summary>Agent crying</summary>
-        public readonly static UUID CRY = new UUID("92624d3e-1068-f1aa-a5ec-8244585193ed");
-        /// <summary>Agent unanimated with arms out (e.g. setting appearance)</summary>
-        public readonly static UUID CUSTOMIZE = new UUID("038fcec9-5ebd-8a8e-0e2e-6e71a0a1ac53");
-        /// <summary>Agent re-animated after set appearance finished</summary>
-        public readonly static UUID CUSTOMIZE_DONE = new UUID("6883a61a-b27b-5914-a61e-dda118a9ee2c");
-        /// <summary>Agent dancing</summary>
-        public readonly static UUID DANCE1 = new UUID("b68a3d7c-de9e-fc87-eec8-543d787e5b0d");
-        /// <summary>Agent dancing</summary>
-        public readonly static UUID DANCE2 = new UUID("928cae18-e31d-76fd-9cc9-2f55160ff818");
-        /// <summary>Agent dancing</summary>
-        public readonly static UUID DANCE3 = new UUID("30047778-10ea-1af7-6881-4db7a3a5a114");
-        /// <summary>Agent dancing</summary>
-        public readonly static UUID DANCE4 = new UUID("951469f4-c7b2-c818-9dee-ad7eea8c30b7");
-        /// <summary>Agent dancing</summary>
-        public readonly static UUID DANCE5 = new UUID("4bd69a1d-1114-a0b4-625f-84e0a5237155");
-        /// <summary>Agent dancing</summary>
-        public readonly static UUID DANCE6 = new UUID("cd28b69b-9c95-bb78-3f94-8d605ff1bb12");
-        /// <summary>Agent dancing</summary>
-        public readonly static UUID DANCE7 = new UUID("a54d8ee2-28bb-80a9-7f0c-7afbbe24a5d6");
-        /// <summary>Agent dancing</summary>
-        public readonly static UUID DANCE8 = new UUID("b0dc417c-1f11-af36-2e80-7e7489fa7cdc");
-        /// <summary>Agent on ground unanimated</summary>
-        public readonly static UUID DEAD = new UUID("57abaae6-1d17-7b1b-5f98-6d11a6411276");
-        /// <summary>Agent boozing it up</summary>
-        public readonly static UUID DRINK = new UUID("0f86e355-dd31-a61c-fdb0-3a96b9aad05f");
-        /// <summary>Agent with embarassed expression on face</summary>
-        public readonly static UUID EMBARRASSED = new UUID("514af488-9051-044a-b3fc-d4dbf76377c6");
-        /// <summary>Agent with afraid expression on face</summary>
-        public readonly static UUID EXPRESS_AFRAID = new UUID("aa2df84d-cf8f-7218-527b-424a52de766e");
-        /// <summary>Agent with angry expression on face</summary>
-        public readonly static UUID EXPRESS_ANGER = new UUID("1a03b575-9634-b62a-5767-3a679e81f4de");
-        /// <summary>Agent with bored expression on face</summary>
-        public readonly static UUID EXPRESS_BORED = new UUID("214aa6c1-ba6a-4578-f27c-ce7688f61d0d");
-        /// <summary>Agent crying</summary>
-        public readonly static UUID EXPRESS_CRY = new UUID("d535471b-85bf-3b4d-a542-93bea4f59d33");
-        /// <summary>Agent showing disdain (dislike) for something</summary>
-        public readonly static UUID EXPRESS_DISDAIN = new UUID("d4416ff1-09d3-300f-4183-1b68a19b9fc1");
-        /// <summary>Agent with embarassed expression on face</summary>
-        public readonly static UUID EXPRESS_EMBARRASSED = new UUID("0b8c8211-d78c-33e8-fa28-c51a9594e424");
-        /// <summary>Agent with frowning expression on face</summary>
-        public readonly static UUID EXPRESS_FROWN = new UUID("fee3df48-fa3d-1015-1e26-a205810e3001");
-        /// <summary>Agent with kissy face</summary>
-        public readonly static UUID EXPRESS_KISS = new UUID("1e8d90cc-a84e-e135-884c-7c82c8b03a14");
-        /// <summary>Agent expressing laughgter</summary>
-        public readonly static UUID EXPRESS_LAUGH = new UUID("62570842-0950-96f8-341c-809e65110823");
-        /// <summary>Agent with open mouth</summary>
-        public readonly static UUID EXPRESS_OPEN_MOUTH = new UUID("d63bc1f9-fc81-9625-a0c6-007176d82eb7");
-        /// <summary>Agent with repulsed expression on face</summary>
-        public readonly static UUID EXPRESS_REPULSED = new UUID("f76cda94-41d4-a229-2872-e0296e58afe1");
-        /// <summary>Agent expressing sadness</summary>
-        public readonly static UUID EXPRESS_SAD = new UUID("eb6ebfb2-a4b3-a19c-d388-4dd5c03823f7");
-        /// <summary>Agent shrugging shoulders</summary>
-        public readonly static UUID EXPRESS_SHRUG = new UUID("a351b1bc-cc94-aac2-7bea-a7e6ebad15ef");
-        /// <summary>Agent with a smile</summary>
-        public readonly static UUID EXPRESS_SMILE = new UUID("b7c7c833-e3d3-c4e3-9fc0-131237446312");
-        /// <summary>Agent expressing surprise</summary>
-        public readonly static UUID EXPRESS_SURPRISE = new UUID("728646d9-cc79-08b2-32d6-937f0a835c24");
-        /// <summary>Agent sticking tongue out</summary>
-        public readonly static UUID EXPRESS_TONGUE_OUT = new UUID("835965c6-7f2f-bda2-5deb-2478737f91bf");
-        /// <summary>Agent with big toothy smile</summary>
-        public readonly static UUID EXPRESS_TOOTHSMILE = new UUID("b92ec1a5-e7ce-a76b-2b05-bcdb9311417e");
-        /// <summary>Agent winking</summary>
-        public readonly static UUID EXPRESS_WINK = new UUID("da020525-4d94-59d6-23d7-81fdebf33148");
-        /// <summary>Agent expressing worry</summary>
-        public readonly static UUID EXPRESS_WORRY = new UUID("9c05e5c7-6f07-6ca4-ed5a-b230390c3950");
-        /// <summary>Agent falling down</summary>
-        public readonly static UUID FALLDOWN = new UUID("666307d9-a860-572d-6fd4-c3ab8865c094");
-        /// <summary>Agent walking (feminine version)</summary>
-        public readonly static UUID FEMALE_WALK = new UUID("f5fc7433-043d-e819-8298-f519a119b688");
-        /// <summary>Agent wagging finger (disapproval)</summary>
-        public readonly static UUID FINGER_WAG = new UUID("c1bc7f36-3ba0-d844-f93c-93be945d644f");
-        /// <summary>I'm not sure I want to know</summary>
-        public readonly static UUID FIST_PUMP = new UUID("7db00ccd-f380-f3ee-439d-61968ec69c8a");
-        /// <summary>Agent in superman position</summary>
-        public readonly static UUID FLY = new UUID("aec4610c-757f-bc4e-c092-c6e9caf18daf");
-        /// <summary>Agent in superman position</summary>
-        public readonly static UUID FLYSLOW = new UUID("2b5a38b2-5e00-3a97-a495-4c826bc443e6");
-        /// <summary>Agent greeting another</summary>
-        public readonly static UUID HELLO = new UUID("9b29cd61-c45b-5689-ded2-91756b8d76a9");
-        /// <summary>Agent holding bazooka (right handed)</summary>
-        public readonly static UUID HOLD_BAZOOKA_R = new UUID("ef62d355-c815-4816-2474-b1acc21094a6");
-        /// <summary>Agent holding a bow (left handed)</summary>
-        public readonly static UUID HOLD_BOW_L = new UUID("8b102617-bcba-037b-86c1-b76219f90c88");
-        /// <summary>Agent holding a handgun (right handed)</summary>
-        public readonly static UUID HOLD_HANDGUN_R = new UUID("efdc1727-8b8a-c800-4077-975fc27ee2f2");
-        /// <summary>Agent holding a rifle (right handed)</summary>
-        public readonly static UUID HOLD_RIFLE_R = new UUID("3d94bad0-c55b-7dcc-8763-033c59405d33");
-        /// <summary>Agent throwing an object (right handed)</summary>
-        public readonly static UUID HOLD_THROW_R = new UUID("7570c7b5-1f22-56dd-56ef-a9168241bbb6");
-        /// <summary>Agent in static hover</summary>
-        public readonly static UUID HOVER = new UUID("4ae8016b-31b9-03bb-c401-b1ea941db41d");
-        /// <summary>Agent hovering downward</summary>
-        public readonly static UUID HOVER_DOWN = new UUID("20f063ea-8306-2562-0b07-5c853b37b31e");
-        /// <summary>Agent hovering upward</summary>
-        public readonly static UUID HOVER_UP = new UUID("62c5de58-cb33-5743-3d07-9e4cd4352864");
-        /// <summary>Agent being impatient</summary>
-        public readonly static UUID IMPATIENT = new UUID("5ea3991f-c293-392e-6860-91dfa01278a3");
-        /// <summary>Agent jumping</summary>
-        public readonly static UUID JUMP = new UUID("2305bd75-1ca9-b03b-1faa-b176b8a8c49e");
-        /// <summary>Agent jumping with fervor</summary>
-        public readonly static UUID JUMP_FOR_JOY = new UUID("709ea28e-1573-c023-8bf8-520c8bc637fa");
-        /// <summary>Agent point to lips then rear end</summary>
-        public readonly static UUID KISS_MY_BUTT = new UUID("19999406-3a3a-d58c-a2ac-d72e555dcf51");
-        /// <summary>Agent landing from jump, finished flight, etc</summary>
-        public readonly static UUID LAND = new UUID("7a17b059-12b2-41b1-570a-186368b6aa6f");
-        /// <summary>Agent laughing</summary>
-        public readonly static UUID LAUGH_SHORT = new UUID("ca5b3f14-3194-7a2b-c894-aa699b718d1f");
-        /// <summary>Agent landing from jump, finished flight, etc</summary>
-        public readonly static UUID MEDIUM_LAND = new UUID("f4f00d6e-b9fe-9292-f4cb-0ae06ea58d57");
-        /// <summary>Agent sitting on a motorcycle</summary>
-        public readonly static UUID MOTORCYCLE_SIT = new UUID("08464f78-3a8e-2944-cba5-0c94aff3af29");
-        /// <summary></summary>
-        public readonly static UUID MUSCLE_BEACH = new UUID("315c3a41-a5f3-0ba4-27da-f893f769e69b");
-        /// <summary>Agent moving head side to side</summary>
-        public readonly static UUID NO = new UUID("5a977ed9-7f72-44e9-4c4c-6e913df8ae74");
-        /// <summary>Agent moving head side to side with unhappy expression</summary>
-        public readonly static UUID NO_UNHAPPY = new UUID("d83fa0e5-97ed-7eb2-e798-7bd006215cb4");
-        /// <summary>Agent taunting another</summary>
-        public readonly static UUID NYAH_NYAH = new UUID("f061723d-0a18-754f-66ee-29a44795a32f");
-        /// <summary></summary>
-        public readonly static UUID ONETWO_PUNCH = new UUID("eefc79be-daae-a239-8c04-890f5d23654a");
-        /// <summary>Agent giving peace sign</summary>
-        public readonly static UUID PEACE = new UUID("b312b10e-65ab-a0a4-8b3c-1326ea8e3ed9");
-        /// <summary>Agent pointing at self</summary>
-        public readonly static UUID POINT_ME = new UUID("17c024cc-eef2-f6a0-3527-9869876d7752");
-        /// <summary>Agent pointing at another</summary>
-        public readonly static UUID POINT_YOU = new UUID("ec952cca-61ef-aa3b-2789-4d1344f016de");
-        /// <summary>Agent preparing for jump (bending knees)</summary>
-        public readonly static UUID PRE_JUMP = new UUID("7a4e87fe-de39-6fcb-6223-024b00893244");
-        /// <summary>Agent punching with left hand</summary>
-        public readonly static UUID PUNCH_LEFT = new UUID("f3300ad9-3462-1d07-2044-0fef80062da0");
-        /// <summary>Agent punching with right hand</summary>
-        public readonly static UUID PUNCH_RIGHT = new UUID("c8e42d32-7310-6906-c903-cab5d4a34656");
-        /// <summary>Agent acting repulsed</summary>
-        public readonly static UUID REPULSED = new UUID("36f81a92-f076-5893-dc4b-7c3795e487cf");
-        /// <summary>Agent trying to be Chuck Norris</summary>
-        public readonly static UUID ROUNDHOUSE_KICK = new UUID("49aea43b-5ac3-8a44-b595-96100af0beda");
-        /// <summary>Rocks, Paper, Scissors 1, 2, 3</summary>
-        public readonly static UUID RPS_COUNTDOWN = new UUID("35db4f7e-28c2-6679-cea9-3ee108f7fc7f");
-        /// <summary>Agent with hand flat over other hand</summary>
-        public readonly static UUID RPS_PAPER = new UUID("0836b67f-7f7b-f37b-c00a-460dc1521f5a");
-        /// <summary>Agent with fist over other hand</summary>
-        public readonly static UUID RPS_ROCK = new UUID("42dd95d5-0bc6-6392-f650-777304946c0f");
-        /// <summary>Agent with two fingers spread over other hand</summary>
-        public readonly static UUID RPS_SCISSORS = new UUID("16803a9f-5140-e042-4d7b-d28ba247c325");
-        /// <summary>Agent running</summary>
-        public readonly static UUID RUN = new UUID("05ddbff8-aaa9-92a1-2b74-8fe77a29b445");
-        /// <summary>Agent appearing sad</summary>
-        public readonly static UUID SAD = new UUID("0eb702e2-cc5a-9a88-56a5-661a55c0676a");
-        /// <summary>Agent saluting</summary>
-        public readonly static UUID SALUTE = new UUID("cd7668a6-7011-d7e2-ead8-fc69eff1a104");
-        /// <summary>Agent shooting bow (left handed)</summary>
-        public readonly static UUID SHOOT_BOW_L = new UUID("e04d450d-fdb5-0432-fd68-818aaf5935f8");
-        /// <summary>Agent cupping mouth as if shouting</summary>
-        public readonly static UUID SHOUT = new UUID("6bd01860-4ebd-127a-bb3d-d1427e8e0c42");
-        /// <summary>Agent shrugging shoulders</summary>
-        public readonly static UUID SHRUG = new UUID("70ea714f-3a97-d742-1b01-590a8fcd1db5");
-        /// <summary>Agent in sit position</summary>
-        public readonly static UUID SIT = new UUID("1a5fe8ac-a804-8a5d-7cbd-56bd83184568");
-        /// <summary>Agent in sit position (feminine)</summary>
-        public readonly static UUID SIT_FEMALE = new UUID("b1709c8d-ecd3-54a1-4f28-d55ac0840782");
-        /// <summary>Agent in sit position (generic)</summary>
-        public readonly static UUID SIT_GENERIC = new UUID("245f3c54-f1c0-bf2e-811f-46d8eeb386e7");
-        /// <summary>Agent sitting on ground</summary>
-        public readonly static UUID SIT_GROUND = new UUID("1c7600d6-661f-b87b-efe2-d7421eb93c86");
-        /// <summary>Agent sitting on ground</summary>
-        public readonly static UUID SIT_GROUND_staticRAINED = new UUID("1a2bd58e-87ff-0df8-0b4c-53e047b0bb6e");
-        /// <summary></summary>
-        public readonly static UUID SIT_TO_STAND = new UUID("a8dee56f-2eae-9e7a-05a2-6fb92b97e21e");
-        /// <summary>Agent sleeping on side</summary>
-        public readonly static UUID SLEEP = new UUID("f2bed5f9-9d44-39af-b0cd-257b2a17fe40");
-        /// <summary>Agent smoking</summary>
-        public readonly static UUID SMOKE_IDLE = new UUID("d2f2ee58-8ad1-06c9-d8d3-3827ba31567a");
-        /// <summary>Agent inhaling smoke</summary>
-        public readonly static UUID SMOKE_INHALE = new UUID("6802d553-49da-0778-9f85-1599a2266526");
-        /// <summary></summary>
-        public readonly static UUID SMOKE_THROW_DOWN = new UUID("0a9fb970-8b44-9114-d3a9-bf69cfe804d6");
-        /// <summary>Agent taking a picture</summary>
-        public readonly static UUID SNAPSHOT = new UUID("eae8905b-271a-99e2-4c0e-31106afd100c");
-        /// <summary>Agent standing</summary>
-        public readonly static UUID STAND = new UUID("2408fe9e-df1d-1d7d-f4ff-1384fa7b350f");
-        /// <summary>Agent standing up</summary>
-        public readonly static UUID STANDUP = new UUID("3da1d753-028a-5446-24f3-9c9b856d9422");
-        /// <summary>Agent standing</summary>
-        public readonly static UUID STAND_1 = new UUID("15468e00-3400-bb66-cecc-646d7c14458e");
-        /// <summary>Agent standing</summary>
-        public readonly static UUID STAND_2 = new UUID("370f3a20-6ca6-9971-848c-9a01bc42ae3c");
-        /// <summary>Agent standing</summary>
-        public readonly static UUID STAND_3 = new UUID("42b46214-4b44-79ae-deb8-0df61424ff4b");
-        /// <summary>Agent standing</summary>
-        public readonly static UUID STAND_4 = new UUID("f22fed8b-a5ed-2c93-64d5-bdd8b93c889f");
-        /// <summary>Agent stretching</summary>
-        public readonly static UUID STRETCH = new UUID("80700431-74ec-a008-14f8-77575e73693f");
-        /// <summary>Agent in stride (fast walk)</summary>
-        public readonly static UUID STRIDE = new UUID("1cb562b0-ba21-2202-efb3-30f82cdf9595");
-        /// <summary>Agent surfing</summary>
-        public readonly static UUID SURF = new UUID("41426836-7437-7e89-025d-0aa4d10f1d69");
-        /// <summary>Agent acting surprised</summary>
-        public readonly static UUID SURPRISE = new UUID("313b9881-4302-73c0-c7d0-0e7a36b6c224");
-        /// <summary>Agent striking with a sword</summary>
-        public readonly static UUID SWORD_STRIKE = new UUID("85428680-6bf9-3e64-b489-6f81087c24bd");
-        /// <summary>Agent talking (lips moving)</summary>
-        public readonly static UUID TALK = new UUID("5c682a95-6da4-a463-0bf6-0f5b7be129d1");
-        /// <summary>Agent throwing a tantrum</summary>
-        public readonly static UUID TANTRUM = new UUID("11000694-3f41-adc2-606b-eee1d66f3724");
-        /// <summary>Agent throwing an object (right handed)</summary>
-        public readonly static UUID THROW_R = new UUID("aa134404-7dac-7aca-2cba-435f9db875ca");
-        /// <summary>Agent trying on a shirt</summary>
-        public readonly static UUID TRYON_SHIRT = new UUID("83ff59fe-2346-f236-9009-4e3608af64c1");
-        /// <summary>Agent turning to the left</summary>
-        public readonly static UUID TURNLEFT = new UUID("56e0ba0d-4a9f-7f27-6117-32f2ebbf6135");
-        /// <summary>Agent turning to the right</summary>
-        public readonly static UUID TURNRIGHT = new UUID("2d6daa51-3192-6794-8e2e-a15f8338ec30");
-        /// <summary>Agent typing</summary>
-        public readonly static UUID TYPE = new UUID("c541c47f-e0c0-058b-ad1a-d6ae3a4584d9");
-        /// <summary>Agent walking</summary>
-        public readonly static UUID WALK = new UUID("6ed24bd8-91aa-4b12-ccc7-c97c857ab4e0");
-        /// <summary>Agent whispering</summary>
-        public readonly static UUID WHISPER = new UUID("7693f268-06c7-ea71-fa21-2b30d6533f8f");
-        /// <summary>Agent whispering with fingers in mouth</summary>
-        public readonly static UUID WHISTLE = new UUID("b1ed7982-c68e-a982-7561-52a88a5298c0");
-        /// <summary>Agent winking</summary>
-        public readonly static UUID WINK = new UUID("869ecdad-a44b-671e-3266-56aef2e3ac2e");
-        /// <summary>Agent winking</summary>
-        public readonly static UUID WINK_HOLLYWOOD = new UUID("c0c4030f-c02b-49de-24ba-2331f43fe41c");
-        /// <summary>Agent worried</summary>
-        public readonly static UUID WORRY = new UUID("9f496bd2-589a-709f-16cc-69bf7df1d36c");
-        /// <summary>Agent nodding yes</summary>
-        public readonly static UUID YES = new UUID("15dd911d-be82-2856-26db-27659b142875");
-        /// <summary>Agent nodding yes with happy face</summary>
-        public readonly static UUID YES_HAPPY = new UUID("b8c8b2a3-9008-1771-3bfc-90924955ab2d");
-        /// <summary>Agent floating with legs and arms crossed</summary>
-        public readonly static UUID YOGA_FLOAT = new UUID("42ecd00b-9947-a97c-400a-bbc9174c7aeb");
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// Static pre-defined animations available to all agents
+    /// </summary>
+    public static class Animations
+    {
+        /// <summary>Agent with afraid expression on face</summary>
+        public readonly static UUID AFRAID = new UUID("6b61c8e8-4747-0d75-12d7-e49ff207a4ca");
+        /// <summary>Agent aiming a bazooka (right handed)</summary>
+        public readonly static UUID AIM_BAZOOKA_R = new UUID("b5b4a67d-0aee-30d2-72cd-77b333e932ef");
+        /// <summary>Agent aiming a bow (left handed)</summary>
+        public readonly static UUID AIM_BOW_L = new UUID("46bb4359-de38-4ed8-6a22-f1f52fe8f506");
+        /// <summary>Agent aiming a hand gun (right handed)</summary>
+        public readonly static UUID AIM_HANDGUN_R = new UUID("3147d815-6338-b932-f011-16b56d9ac18b");
+        /// <summary>Agent aiming a rifle (right handed)</summary>
+        public readonly static UUID AIM_RIFLE_R = new UUID("ea633413-8006-180a-c3ba-96dd1d756720");
+        /// <summary>Agent with angry expression on face</summary>
+        public readonly static UUID ANGRY = new UUID("5747a48e-073e-c331-f6f3-7c2149613d3e");
+        /// <summary>Agent hunched over (away)</summary>
+        public readonly static UUID AWAY = new UUID("fd037134-85d4-f241-72c6-4f42164fedee");
+        /// <summary>Agent doing a backflip</summary>
+        public readonly static UUID BACKFLIP = new UUID("c4ca6188-9127-4f31-0158-23c4e2f93304");
+        /// <summary>Agent laughing while holding belly</summary>
+        public readonly static UUID BELLY_LAUGH = new UUID("18b3a4b5-b463-bd48-e4b6-71eaac76c515");
+        /// <summary>Agent blowing a kiss</summary>
+        public readonly static UUID BLOW_KISS = new UUID("db84829b-462c-ee83-1e27-9bbee66bd624");
+        /// <summary>Agent with bored expression on face</summary>
+        public readonly static UUID BORED = new UUID("b906c4ba-703b-1940-32a3-0c7f7d791510");
+        /// <summary>Agent bowing to audience</summary>
+        public readonly static UUID BOW = new UUID("82e99230-c906-1403-4d9c-3889dd98daba");
+        /// <summary>Agent brushing himself/herself off</summary>
+        public readonly static UUID BRUSH = new UUID("349a3801-54f9-bf2c-3bd0-1ac89772af01");
+        /// <summary>Agent in busy mode</summary>
+        public readonly static UUID BUSY = new UUID("efcf670c-2d18-8128-973a-034ebc806b67");
+        /// <summary>Agent clapping hands</summary>
+        public readonly static UUID CLAP = new UUID("9b0c1c4e-8ac7-7969-1494-28c874c4f668");
+        /// <summary>Agent doing a curtsey bow</summary>
+        public readonly static UUID COURTBOW = new UUID("9ba1c942-08be-e43a-fb29-16ad440efc50");
+        /// <summary>Agent crouching</summary>
+        public readonly static UUID CROUCH = new UUID("201f3fdf-cb1f-dbec-201f-7333e328ae7c");
+        /// <summary>Agent crouching while walking</summary>
+        public readonly static UUID CROUCHWALK = new UUID("47f5f6fb-22e5-ae44-f871-73aaaf4a6022");
+        /// <summary>Agent crying</summary>
+        public readonly static UUID CRY = new UUID("92624d3e-1068-f1aa-a5ec-8244585193ed");
+        /// <summary>Agent unanimated with arms out (e.g. setting appearance)</summary>
+        public readonly static UUID CUSTOMIZE = new UUID("038fcec9-5ebd-8a8e-0e2e-6e71a0a1ac53");
+        /// <summary>Agent re-animated after set appearance finished</summary>
+        public readonly static UUID CUSTOMIZE_DONE = new UUID("6883a61a-b27b-5914-a61e-dda118a9ee2c");
+        /// <summary>Agent dancing</summary>
+        public readonly static UUID DANCE1 = new UUID("b68a3d7c-de9e-fc87-eec8-543d787e5b0d");
+        /// <summary>Agent dancing</summary>
+        public readonly static UUID DANCE2 = new UUID("928cae18-e31d-76fd-9cc9-2f55160ff818");
+        /// <summary>Agent dancing</summary>
+        public readonly static UUID DANCE3 = new UUID("30047778-10ea-1af7-6881-4db7a3a5a114");
+        /// <summary>Agent dancing</summary>
+        public readonly static UUID DANCE4 = new UUID("951469f4-c7b2-c818-9dee-ad7eea8c30b7");
+        /// <summary>Agent dancing</summary>
+        public readonly static UUID DANCE5 = new UUID("4bd69a1d-1114-a0b4-625f-84e0a5237155");
+        /// <summary>Agent dancing</summary>
+        public readonly static UUID DANCE6 = new UUID("cd28b69b-9c95-bb78-3f94-8d605ff1bb12");
+        /// <summary>Agent dancing</summary>
+        public readonly static UUID DANCE7 = new UUID("a54d8ee2-28bb-80a9-7f0c-7afbbe24a5d6");
+        /// <summary>Agent dancing</summary>
+        public readonly static UUID DANCE8 = new UUID("b0dc417c-1f11-af36-2e80-7e7489fa7cdc");
+        /// <summary>Agent on ground unanimated</summary>
+        public readonly static UUID DEAD = new UUID("57abaae6-1d17-7b1b-5f98-6d11a6411276");
+        /// <summary>Agent boozing it up</summary>
+        public readonly static UUID DRINK = new UUID("0f86e355-dd31-a61c-fdb0-3a96b9aad05f");
+        /// <summary>Agent with embarassed expression on face</summary>
+        public readonly static UUID EMBARRASSED = new UUID("514af488-9051-044a-b3fc-d4dbf76377c6");
+        /// <summary>Agent with afraid expression on face</summary>
+        public readonly static UUID EXPRESS_AFRAID = new UUID("aa2df84d-cf8f-7218-527b-424a52de766e");
+        /// <summary>Agent with angry expression on face</summary>
+        public readonly static UUID EXPRESS_ANGER = new UUID("1a03b575-9634-b62a-5767-3a679e81f4de");
+        /// <summary>Agent with bored expression on face</summary>
+        public readonly static UUID EXPRESS_BORED = new UUID("214aa6c1-ba6a-4578-f27c-ce7688f61d0d");
+        /// <summary>Agent crying</summary>
+        public readonly static UUID EXPRESS_CRY = new UUID("d535471b-85bf-3b4d-a542-93bea4f59d33");
+        /// <summary>Agent showing disdain (dislike) for something</summary>
+        public readonly static UUID EXPRESS_DISDAIN = new UUID("d4416ff1-09d3-300f-4183-1b68a19b9fc1");
+        /// <summary>Agent with embarassed expression on face</summary>
+        public readonly static UUID EXPRESS_EMBARRASSED = new UUID("0b8c8211-d78c-33e8-fa28-c51a9594e424");
+        /// <summary>Agent with frowning expression on face</summary>
+        public readonly static UUID EXPRESS_FROWN = new UUID("fee3df48-fa3d-1015-1e26-a205810e3001");
+        /// <summary>Agent with kissy face</summary>
+        public readonly static UUID EXPRESS_KISS = new UUID("1e8d90cc-a84e-e135-884c-7c82c8b03a14");
+        /// <summary>Agent expressing laughgter</summary>
+        public readonly static UUID EXPRESS_LAUGH = new UUID("62570842-0950-96f8-341c-809e65110823");
+        /// <summary>Agent with open mouth</summary>
+        public readonly static UUID EXPRESS_OPEN_MOUTH = new UUID("d63bc1f9-fc81-9625-a0c6-007176d82eb7");
+        /// <summary>Agent with repulsed expression on face</summary>
+        public readonly static UUID EXPRESS_REPULSED = new UUID("f76cda94-41d4-a229-2872-e0296e58afe1");
+        /// <summary>Agent expressing sadness</summary>
+        public readonly static UUID EXPRESS_SAD = new UUID("eb6ebfb2-a4b3-a19c-d388-4dd5c03823f7");
+        /// <summary>Agent shrugging shoulders</summary>
+        public readonly static UUID EXPRESS_SHRUG = new UUID("a351b1bc-cc94-aac2-7bea-a7e6ebad15ef");
+        /// <summary>Agent with a smile</summary>
+        public readonly static UUID EXPRESS_SMILE = new UUID("b7c7c833-e3d3-c4e3-9fc0-131237446312");
+        /// <summary>Agent expressing surprise</summary>
+        public readonly static UUID EXPRESS_SURPRISE = new UUID("728646d9-cc79-08b2-32d6-937f0a835c24");
+        /// <summary>Agent sticking tongue out</summary>
+        public readonly static UUID EXPRESS_TONGUE_OUT = new UUID("835965c6-7f2f-bda2-5deb-2478737f91bf");
+        /// <summary>Agent with big toothy smile</summary>
+        public readonly static UUID EXPRESS_TOOTHSMILE = new UUID("b92ec1a5-e7ce-a76b-2b05-bcdb9311417e");
+        /// <summary>Agent winking</summary>
+        public readonly static UUID EXPRESS_WINK = new UUID("da020525-4d94-59d6-23d7-81fdebf33148");
+        /// <summary>Agent expressing worry</summary>
+        public readonly static UUID EXPRESS_WORRY = new UUID("9c05e5c7-6f07-6ca4-ed5a-b230390c3950");
+        /// <summary>Agent falling down</summary>
+        public readonly static UUID FALLDOWN = new UUID("666307d9-a860-572d-6fd4-c3ab8865c094");
+        /// <summary>Agent walking (feminine version)</summary>
+        public readonly static UUID FEMALE_WALK = new UUID("f5fc7433-043d-e819-8298-f519a119b688");
+        /// <summary>Agent wagging finger (disapproval)</summary>
+        public readonly static UUID FINGER_WAG = new UUID("c1bc7f36-3ba0-d844-f93c-93be945d644f");
+        /// <summary>I'm not sure I want to know</summary>
+        public readonly static UUID FIST_PUMP = new UUID("7db00ccd-f380-f3ee-439d-61968ec69c8a");
+        /// <summary>Agent in superman position</summary>
+        public readonly static UUID FLY = new UUID("aec4610c-757f-bc4e-c092-c6e9caf18daf");
+        /// <summary>Agent in superman position</summary>
+        public readonly static UUID FLYSLOW = new UUID("2b5a38b2-5e00-3a97-a495-4c826bc443e6");
+        /// <summary>Agent greeting another</summary>
+        public readonly static UUID HELLO = new UUID("9b29cd61-c45b-5689-ded2-91756b8d76a9");
+        /// <summary>Agent holding bazooka (right handed)</summary>
+        public readonly static UUID HOLD_BAZOOKA_R = new UUID("ef62d355-c815-4816-2474-b1acc21094a6");
+        /// <summary>Agent holding a bow (left handed)</summary>
+        public readonly static UUID HOLD_BOW_L = new UUID("8b102617-bcba-037b-86c1-b76219f90c88");
+        /// <summary>Agent holding a handgun (right handed)</summary>
+        public readonly static UUID HOLD_HANDGUN_R = new UUID("efdc1727-8b8a-c800-4077-975fc27ee2f2");
+        /// <summary>Agent holding a rifle (right handed)</summary>
+        public readonly static UUID HOLD_RIFLE_R = new UUID("3d94bad0-c55b-7dcc-8763-033c59405d33");
+        /// <summary>Agent throwing an object (right handed)</summary>
+        public readonly static UUID HOLD_THROW_R = new UUID("7570c7b5-1f22-56dd-56ef-a9168241bbb6");
+        /// <summary>Agent in static hover</summary>
+        public readonly static UUID HOVER = new UUID("4ae8016b-31b9-03bb-c401-b1ea941db41d");
+        /// <summary>Agent hovering downward</summary>
+        public readonly static UUID HOVER_DOWN = new UUID("20f063ea-8306-2562-0b07-5c853b37b31e");
+        /// <summary>Agent hovering upward</summary>
+        public readonly static UUID HOVER_UP = new UUID("62c5de58-cb33-5743-3d07-9e4cd4352864");
+        /// <summary>Agent being impatient</summary>
+        public readonly static UUID IMPATIENT = new UUID("5ea3991f-c293-392e-6860-91dfa01278a3");
+        /// <summary>Agent jumping</summary>
+        public readonly static UUID JUMP = new UUID("2305bd75-1ca9-b03b-1faa-b176b8a8c49e");
+        /// <summary>Agent jumping with fervor</summary>
+        public readonly static UUID JUMP_FOR_JOY = new UUID("709ea28e-1573-c023-8bf8-520c8bc637fa");
+        /// <summary>Agent point to lips then rear end</summary>
+        public readonly static UUID KISS_MY_BUTT = new UUID("19999406-3a3a-d58c-a2ac-d72e555dcf51");
+        /// <summary>Agent landing from jump, finished flight, etc</summary>
+        public readonly static UUID LAND = new UUID("7a17b059-12b2-41b1-570a-186368b6aa6f");
+        /// <summary>Agent laughing</summary>
+        public readonly static UUID LAUGH_SHORT = new UUID("ca5b3f14-3194-7a2b-c894-aa699b718d1f");
+        /// <summary>Agent landing from jump, finished flight, etc</summary>
+        public readonly static UUID MEDIUM_LAND = new UUID("f4f00d6e-b9fe-9292-f4cb-0ae06ea58d57");
+        /// <summary>Agent sitting on a motorcycle</summary>
+        public readonly static UUID MOTORCYCLE_SIT = new UUID("08464f78-3a8e-2944-cba5-0c94aff3af29");
+        /// <summary></summary>
+        public readonly static UUID MUSCLE_BEACH = new UUID("315c3a41-a5f3-0ba4-27da-f893f769e69b");
+        /// <summary>Agent moving head side to side</summary>
+        public readonly static UUID NO = new UUID("5a977ed9-7f72-44e9-4c4c-6e913df8ae74");
+        /// <summary>Agent moving head side to side with unhappy expression</summary>
+        public readonly static UUID NO_UNHAPPY = new UUID("d83fa0e5-97ed-7eb2-e798-7bd006215cb4");
+        /// <summary>Agent taunting another</summary>
+        public readonly static UUID NYAH_NYAH = new UUID("f061723d-0a18-754f-66ee-29a44795a32f");
+        /// <summary></summary>
+        public readonly static UUID ONETWO_PUNCH = new UUID("eefc79be-daae-a239-8c04-890f5d23654a");
+        /// <summary>Agent giving peace sign</summary>
+        public readonly static UUID PEACE = new UUID("b312b10e-65ab-a0a4-8b3c-1326ea8e3ed9");
+        /// <summary>Agent pointing at self</summary>
+        public readonly static UUID POINT_ME = new UUID("17c024cc-eef2-f6a0-3527-9869876d7752");
+        /// <summary>Agent pointing at another</summary>
+        public readonly static UUID POINT_YOU = new UUID("ec952cca-61ef-aa3b-2789-4d1344f016de");
+        /// <summary>Agent preparing for jump (bending knees)</summary>
+        public readonly static UUID PRE_JUMP = new UUID("7a4e87fe-de39-6fcb-6223-024b00893244");
+        /// <summary>Agent punching with left hand</summary>
+        public readonly static UUID PUNCH_LEFT = new UUID("f3300ad9-3462-1d07-2044-0fef80062da0");
+        /// <summary>Agent punching with right hand</summary>
+        public readonly static UUID PUNCH_RIGHT = new UUID("c8e42d32-7310-6906-c903-cab5d4a34656");
+        /// <summary>Agent acting repulsed</summary>
+        public readonly static UUID REPULSED = new UUID("36f81a92-f076-5893-dc4b-7c3795e487cf");
+        /// <summary>Agent trying to be Chuck Norris</summary>
+        public readonly static UUID ROUNDHOUSE_KICK = new UUID("49aea43b-5ac3-8a44-b595-96100af0beda");
+        /// <summary>Rocks, Paper, Scissors 1, 2, 3</summary>
+        public readonly static UUID RPS_COUNTDOWN = new UUID("35db4f7e-28c2-6679-cea9-3ee108f7fc7f");
+        /// <summary>Agent with hand flat over other hand</summary>
+        public readonly static UUID RPS_PAPER = new UUID("0836b67f-7f7b-f37b-c00a-460dc1521f5a");
+        /// <summary>Agent with fist over other hand</summary>
+        public readonly static UUID RPS_ROCK = new UUID("42dd95d5-0bc6-6392-f650-777304946c0f");
+        /// <summary>Agent with two fingers spread over other hand</summary>
+        public readonly static UUID RPS_SCISSORS = new UUID("16803a9f-5140-e042-4d7b-d28ba247c325");
+        /// <summary>Agent running</summary>
+        public readonly static UUID RUN = new UUID("05ddbff8-aaa9-92a1-2b74-8fe77a29b445");
+        /// <summary>Agent appearing sad</summary>
+        public readonly static UUID SAD = new UUID("0eb702e2-cc5a-9a88-56a5-661a55c0676a");
+        /// <summary>Agent saluting</summary>
+        public readonly static UUID SALUTE = new UUID("cd7668a6-7011-d7e2-ead8-fc69eff1a104");
+        /// <summary>Agent shooting bow (left handed)</summary>
+        public readonly static UUID SHOOT_BOW_L = new UUID("e04d450d-fdb5-0432-fd68-818aaf5935f8");
+        /// <summary>Agent cupping mouth as if shouting</summary>
+        public readonly static UUID SHOUT = new UUID("6bd01860-4ebd-127a-bb3d-d1427e8e0c42");
+        /// <summary>Agent shrugging shoulders</summary>
+        public readonly static UUID SHRUG = new UUID("70ea714f-3a97-d742-1b01-590a8fcd1db5");
+        /// <summary>Agent in sit position</summary>
+        public readonly static UUID SIT = new UUID("1a5fe8ac-a804-8a5d-7cbd-56bd83184568");
+        /// <summary>Agent in sit position (feminine)</summary>
+        public readonly static UUID SIT_FEMALE = new UUID("b1709c8d-ecd3-54a1-4f28-d55ac0840782");
+        /// <summary>Agent in sit position (generic)</summary>
+        public readonly static UUID SIT_GENERIC = new UUID("245f3c54-f1c0-bf2e-811f-46d8eeb386e7");
+        /// <summary>Agent sitting on ground</summary>
+        public readonly static UUID SIT_GROUND = new UUID("1c7600d6-661f-b87b-efe2-d7421eb93c86");
+        /// <summary>Agent sitting on ground</summary>
+        public readonly static UUID SIT_GROUND_staticRAINED = new UUID("1a2bd58e-87ff-0df8-0b4c-53e047b0bb6e");
+        /// <summary></summary>
+        public readonly static UUID SIT_TO_STAND = new UUID("a8dee56f-2eae-9e7a-05a2-6fb92b97e21e");
+        /// <summary>Agent sleeping on side</summary>
+        public readonly static UUID SLEEP = new UUID("f2bed5f9-9d44-39af-b0cd-257b2a17fe40");
+        /// <summary>Agent smoking</summary>
+        public readonly static UUID SMOKE_IDLE = new UUID("d2f2ee58-8ad1-06c9-d8d3-3827ba31567a");
+        /// <summary>Agent inhaling smoke</summary>
+        public readonly static UUID SMOKE_INHALE = new UUID("6802d553-49da-0778-9f85-1599a2266526");
+        /// <summary></summary>
+        public readonly static UUID SMOKE_THROW_DOWN = new UUID("0a9fb970-8b44-9114-d3a9-bf69cfe804d6");
+        /// <summary>Agent taking a picture</summary>
+        public readonly static UUID SNAPSHOT = new UUID("eae8905b-271a-99e2-4c0e-31106afd100c");
+        /// <summary>Agent standing</summary>
+        public readonly static UUID STAND = new UUID("2408fe9e-df1d-1d7d-f4ff-1384fa7b350f");
+        /// <summary>Agent standing up</summary>
+        public readonly static UUID STANDUP = new UUID("3da1d753-028a-5446-24f3-9c9b856d9422");
+        /// <summary>Agent standing</summary>
+        public readonly static UUID STAND_1 = new UUID("15468e00-3400-bb66-cecc-646d7c14458e");
+        /// <summary>Agent standing</summary>
+        public readonly static UUID STAND_2 = new UUID("370f3a20-6ca6-9971-848c-9a01bc42ae3c");
+        /// <summary>Agent standing</summary>
+        public readonly static UUID STAND_3 = new UUID("42b46214-4b44-79ae-deb8-0df61424ff4b");
+        /// <summary>Agent standing</summary>
+        public readonly static UUID STAND_4 = new UUID("f22fed8b-a5ed-2c93-64d5-bdd8b93c889f");
+        /// <summary>Agent stretching</summary>
+        public readonly static UUID STRETCH = new UUID("80700431-74ec-a008-14f8-77575e73693f");
+        /// <summary>Agent in stride (fast walk)</summary>
+        public readonly static UUID STRIDE = new UUID("1cb562b0-ba21-2202-efb3-30f82cdf9595");
+        /// <summary>Agent surfing</summary>
+        public readonly static UUID SURF = new UUID("41426836-7437-7e89-025d-0aa4d10f1d69");
+        /// <summary>Agent acting surprised</summary>
+        public readonly static UUID SURPRISE = new UUID("313b9881-4302-73c0-c7d0-0e7a36b6c224");
+        /// <summary>Agent striking with a sword</summary>
+        public readonly static UUID SWORD_STRIKE = new UUID("85428680-6bf9-3e64-b489-6f81087c24bd");
+        /// <summary>Agent talking (lips moving)</summary>
+        public readonly static UUID TALK = new UUID("5c682a95-6da4-a463-0bf6-0f5b7be129d1");
+        /// <summary>Agent throwing a tantrum</summary>
+        public readonly static UUID TANTRUM = new UUID("11000694-3f41-adc2-606b-eee1d66f3724");
+        /// <summary>Agent throwing an object (right handed)</summary>
+        public readonly static UUID THROW_R = new UUID("aa134404-7dac-7aca-2cba-435f9db875ca");
+        /// <summary>Agent trying on a shirt</summary>
+        public readonly static UUID TRYON_SHIRT = new UUID("83ff59fe-2346-f236-9009-4e3608af64c1");
+        /// <summary>Agent turning to the left</summary>
+        public readonly static UUID TURNLEFT = new UUID("56e0ba0d-4a9f-7f27-6117-32f2ebbf6135");
+        /// <summary>Agent turning to the right</summary>
+        public readonly static UUID TURNRIGHT = new UUID("2d6daa51-3192-6794-8e2e-a15f8338ec30");
+        /// <summary>Agent typing</summary>
+        public readonly static UUID TYPE = new UUID("c541c47f-e0c0-058b-ad1a-d6ae3a4584d9");
+        /// <summary>Agent walking</summary>
+        public readonly static UUID WALK = new UUID("6ed24bd8-91aa-4b12-ccc7-c97c857ab4e0");
+        /// <summary>Agent whispering</summary>
+        public readonly static UUID WHISPER = new UUID("7693f268-06c7-ea71-fa21-2b30d6533f8f");
+        /// <summary>Agent whispering with fingers in mouth</summary>
+        public readonly static UUID WHISTLE = new UUID("b1ed7982-c68e-a982-7561-52a88a5298c0");
+        /// <summary>Agent winking</summary>
+        public readonly static UUID WINK = new UUID("869ecdad-a44b-671e-3266-56aef2e3ac2e");
+        /// <summary>Agent winking</summary>
+        public readonly static UUID WINK_HOLLYWOOD = new UUID("c0c4030f-c02b-49de-24ba-2331f43fe41c");
+        /// <summary>Agent worried</summary>
+        public readonly static UUID WORRY = new UUID("9f496bd2-589a-709f-16cc-69bf7df1d36c");
+        /// <summary>Agent nodding yes</summary>
+        public readonly static UUID YES = new UUID("15dd911d-be82-2856-26db-27659b142875");
+        /// <summary>Agent nodding yes with happy face</summary>
+        public readonly static UUID YES_HAPPY = new UUID("b8c8b2a3-9008-1771-3bfc-90924955ab2d");
+        /// <summary>Agent floating with legs and arms crossed</summary>
+        public readonly static UUID YOGA_FLOAT = new UUID("42ecd00b-9947-a97c-400a-bbc9174c7aeb");
+    }
+}
Index: InventoryNode.cs
===================================================================
--- InventoryNode.cs	(revision 2445)
+++ InventoryNode.cs	(working copy)
@@ -1,104 +1,200 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-
-namespace OpenMetaverse
-{
-    public class InventoryNode
-    {
-        private InventoryBase data;
-        private InventoryNode parent;
-        private InventoryNodeDictionary nodes;
-
-        /// <summary></summary>
-        public InventoryBase Data
-        {
-            get { return data; }
-            set { data = value; }
-        }
-
-        /// <summary></summary>
-        public InventoryNode Parent
-        {
-            get { return parent; }
-            set { parent = value; }
-        }
-
-        /// <summary></summary>
-        public InventoryNodeDictionary Nodes
-        {
-            get
-            {
-                if (nodes == null)
-                    nodes = new InventoryNodeDictionary(this);
-
-                return nodes;
-            }
-            set { nodes = value; }
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        public InventoryNode()
-        {
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="data"></param>
-        public InventoryNode(InventoryBase data)
-        {
-            this.data = data;
-        }
-
-        public InventoryNode(InventoryBase data, InventoryNode parent)
-        {
-            this.data = data;
-            this.parent = parent;
-
-            if (parent != null)
-            {
-                // Add this node to the collection of parent nodes
-                lock (parent.Nodes.SyncRoot) parent.Nodes.Add(data.UUID, this);
-            }
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <returns></returns>
-        public override string ToString()
-        {
-            if (this.Data == null) return "[Empty Node]";
-            return this.Data.ToString();
-        }
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Runtime.Serialization;
+
+namespace OpenMetaverse
+{
+    [Serializable()]
+    public class InventoryNode : ISerializable
+    {
+        private InventoryBase data;
+        private InventoryNode parent;
+        private UUID parentID; //used for de-seralization 
+        private InventoryNodeDictionary nodes;
+
+        /// <summary></summary>
+        public InventoryBase Data
+        {
+            get { return data; }
+            set { data = value; }
+        }
+
+        /// <summary></summary>
+        public InventoryNode Parent
+        {
+            get { return parent; }
+            set { parent = value; }
+        }
+
+        /// <summary></summary>
+        public UUID ParentID
+        {
+            get { return parentID; }
+        }
+
+        /// <summary></summary>
+        public InventoryNodeDictionary Nodes
+        {
+            get
+            {
+                if (nodes == null)
+                    nodes = new InventoryNodeDictionary(this);
+
+                return nodes;
+            }
+            set { nodes = value; }
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        public InventoryNode()
+        {
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="data"></param>
+        public InventoryNode(InventoryBase data)
+        {
+            this.data = data;
+        }
+
+        /// <summary>
+        /// De-serialization constructor for the InventoryNode Class
+        /// </summary>
+        public InventoryNode(InventoryBase data, InventoryNode parent)
+        {
+            this.data = data;
+            this.parent = parent;
+
+            if (parent != null)
+            {
+                // Add this node to the collection of parent nodes
+                lock (parent.Nodes.SyncRoot) parent.Nodes.Add(data.UUID, this);
+            }
+        }
+
+        /// <summary>
+        /// Serialization handler for the InventoryNode Class
+        /// </summary>
+        public void GetObjectData(SerializationInfo info, StreamingContext ctxt)
+        {
+            if(parent!=null)
+                info.AddValue("Parent", parent.Data.UUID, typeof(UUID)); //We need to track the parent UUID for de-serialization
+            else
+                info.AddValue("Parent", UUID.Zero, typeof(UUID));
+
+            info.AddValue("Type", data.GetType(), typeof(Type));
+            
+            if(data is InventoryAnimation)
+                ((InventoryAnimation)data).GetObjectData(info, ctxt);
+            if(data is InventoryAttachment)
+                ((InventoryAttachment)data).GetObjectData(info, ctxt);
+            if(data is InventoryCallingCard)
+                ((InventoryCallingCard)data).GetObjectData(info, ctxt);
+            if(data is InventoryFolder)
+                ((InventoryFolder)data).GetObjectData(info, ctxt);
+            if(data is InventoryGesture)
+                ((InventoryGesture)data).GetObjectData(info, ctxt);
+            if(data is InventoryLandmark)
+                ((InventoryLandmark)data).GetObjectData(info, ctxt);
+            if(data is InventoryLSL)
+                ((InventoryLSL)data).GetObjectData(info, ctxt);
+            if (data is InventoryNotecard)
+                ((InventoryNotecard)data).GetObjectData(info, ctxt);
+            if(data is InventoryObject)
+                ((InventoryObject)data).GetObjectData(info, ctxt);
+            if(data is InventorySnapshot)
+                ((InventorySnapshot)data).GetObjectData(info, ctxt);
+            if(data is InventorySound)
+                ((InventorySound)data).GetObjectData(info, ctxt);
+            if(data is InventoryWearable)
+                ((InventoryWearable)data).GetObjectData(info, ctxt);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public InventoryNode(SerializationInfo info, StreamingContext ctxt)
+        {
+            parentID = (UUID)info.GetValue("Parent", typeof(UUID));
+            Type type = (Type)info.GetValue("Type", typeof(Type));
+           
+            if (type == typeof(InventoryAnimation))
+                data = new InventoryAnimation(info, ctxt);
+
+            if (type == typeof(InventoryAttachment))
+                data = new InventoryAttachment(info, ctxt);
+
+            if (type == typeof(InventoryCallingCard))
+                data = new InventoryCallingCard(info, ctxt);
+
+            if (type == typeof(InventoryFolder))
+                data = new InventoryFolder(info, ctxt);
+
+            if (type == typeof(InventoryGesture))
+                data = new InventoryGesture(info, ctxt);
+
+            if (type == typeof(InventoryLandmark))
+                data = new InventoryLandmark(info, ctxt);
+
+            if (type == typeof(InventoryLSL))
+                data = new InventoryLSL(info, ctxt);
+
+            if (type == typeof(InventoryNotecard))
+                data = new InventoryNotecard(info, ctxt);
+
+            if (type == typeof(InventoryObject))
+                data = new InventoryObject(info, ctxt);
+
+            if (type == typeof(InventorySnapshot))
+                data = new InventorySnapshot(info, ctxt);
+
+            if (type == typeof(InventorySound))
+                data = new InventorySound(info, ctxt);
+
+            if (type == typeof(InventoryWearable))
+                data = new InventoryWearable(info, ctxt);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public override string ToString()
+        {
+            if (this.Data == null) return "[Empty Node]";
+            return this.Data.ToString();
+        }
+    }
+}
Index: AssetTypes.cs
===================================================================
--- AssetTypes.cs	(revision 2445)
+++ AssetTypes.cs	(working copy)
@@ -1,548 +1,548 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using System.Collections.Generic;
-using OpenMetaverse.Imaging;
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    [Flags]
-    public enum WearableType : byte
-    {
-        /// <summary>A shape</summary>
-        Shape = 0,
-        /// <summary></summary>
-        Skin,
-        /// <summary></summary>
-        Hair,
-        /// <summary></summary>
-        Eyes,
-        /// <summary></summary>
-        Shirt,
-        /// <summary></summary>
-        Pants,
-        /// <summary></summary>
-        Shoes,
-        /// <summary></summary>
-        Socks,
-        /// <summary></summary>
-        Jacket,
-        /// <summary></summary>
-        Gloves,
-        /// <summary></summary>
-        Undershirt,
-        /// <summary></summary>
-        Underpants,
-        /// <summary></summary>
-        Skirt,
-        /// <summary></summary>
-        Invalid = 255
-    };
-
-    /// <summary>
-    /// Each inventory AssetType will have its own set of flags, these are the known flags for AssetType=Object
-    /// </summary>
-    [Flags]
-    public enum ObjectType : uint
-    {
-        None = 0,
-        /// <summary>
-        /// A Landmark that has not been previously visited shows up as a dark red pushpin, one that has been
-        /// visited shows up as a light red pushpin
-        /// </summary>
-        VisitedLandmark = 1,
-        /// <summary>If set, indicates rezzed object will have more restrictive permissions masks;
-        /// Which masks will be affected are below</summary>
-        RestrictNextOwner = 0x100,
-        /// <summary>If set, and <c>RestrictNextOwner</c> bit is set indicates BaseMask will be overwritten on Rez</summary>
-        OverwriteBase = 0x010000,
-        /// <summary>If set, and <c>RestrictNextOwner</c> bit is set indicates OwnerMask will be overwritten on Rez</summary>
-        OverwriteOwner = 0x020000,
-        /// <summary>If set, and <c>RestrictNextOwner</c> bit is set indicates GroupMask will be overwritten on Rez</summary>
-        OverwriteGroup = 0x040000,
-        /// <summary>If set, and <c>RestrictNextOwner</c> bit is set indicates EveryoneMask will be overwritten on Rez</summary>
-        OverwriteEveryone = 0x080000,
-        /// <summary>If set, and <c>RestrictNextOwner</c> bit is set indicates NextOwnerMask will be overwritten on Rez</summary>
-        OverwriteNextOwner = 0x100000,
-        /// <summary>If set, indicates item is multiple items coalesced into a single item</summary>
-        MultipleObjects = 0x200000
-    }
-
-    public abstract class Asset
-    {
-        public byte[] AssetData;
-        public bool Temporary;
-
-        private UUID _AssetID;
-        public UUID AssetID
-        {
-            get { return _AssetID; }
-            internal set { _AssetID = value; }
-        }
-
-        public abstract AssetType AssetType
-        {
-            get;
-        }
-
-        public Asset() { }
-
-        public Asset(UUID assetID, byte[] assetData)
-        {
-            _AssetID = assetID;
-            AssetData = assetData;
-        }
-
-        /// <summary>
-        /// Regenerates the <code>AssetData</code> byte array from the properties 
-        /// of the derived class.
-        /// </summary>
-        public abstract void Encode();
-
-        /// <summary>
-        /// Decodes the AssetData, placing it in appropriate properties of the derived
-        /// class.
-        /// </summary>
-        /// <returns>True if the asset decoding succeeded, otherwise false</returns>
-        public abstract bool Decode();
-    }
-
-    public class AssetAnimation : Asset
-    {
-        public override AssetType AssetType { get { return AssetType.Animation; } }
-
-        public AssetAnimation() { }
-
-        public AssetAnimation(UUID assetID, byte[] assetData)
-            : base(assetID, assetData)
-        {
-            AssetData = assetData;
-        }
-
-        public override void Encode() { }
-        public override bool Decode() { return true; }
-    }
-
-    public class AssetNotecard : Asset
-    {
-        public override AssetType AssetType { get { return AssetType.Notecard; } }
-
-        public string Text = null;
-
-        public AssetNotecard() { }
-        
-        public AssetNotecard(UUID assetID, byte[] assetData) : base(assetID, assetData) 
-        {
-            Decode();
-        }
-        
-        public AssetNotecard(string text)
-        {
-            Text = text;
-            Encode();
-        }
-
-        public override void Encode()
-        {
-
-            string temp = "Linden text version 2\n{\nLLEmbeddedItems version 1\n{\ncount 0\n}\nText length ";
-            temp += Text.Length + "\n";
-            temp += Text;
-            temp += "}";
-            AssetData = Utils.StringToBytes(temp);
-        }
-        
-        public override bool Decode()
-        {
-            Text = Utils.BytesToString(AssetData);
-            return true;
-        }
-    }
-
-    public class AssetScriptText : Asset
-    {
-        public override AssetType AssetType { get { return AssetType.LSLText; } }
-
-        public string Source;
-
-        public AssetScriptText() { }
-
-        public AssetScriptText(UUID assetID, byte[] assetData) : base(assetID, assetData) { }
-        
-        public AssetScriptText(string source)
-        {
-            Source = source;
-        }
-
-        public override void Encode()
-        {
-            AssetData = Utils.StringToBytes(Source);
-        }
-
-        public override bool Decode()
-        {
-            Source = Utils.BytesToString(AssetData);
-            return true;
-        }
-    }
-
-    public class AssetScriptBinary : Asset
-    {
-        public override AssetType AssetType { get { return AssetType.LSLBytecode; } }
-
-        public AssetScriptBinary() { }
-
-        public AssetScriptBinary(UUID assetID, byte[] assetData)
-            : base(assetID, assetData)
-        {
-            AssetData = assetData;
-        }
-
-        public override void Encode() { }
-        public override bool Decode() { return true; }
-    }
-
-    public class AssetSound : Asset
-    {
-        public override AssetType AssetType { get { return AssetType.Sound; } }
-
-        public AssetSound() { }
-
-        public AssetSound(UUID assetID, byte[] assetData)
-            : base(assetID, assetData)
-        {
-            AssetData = assetData;
-        }
-
-        public override void Encode() { }
-        public override bool Decode() { return true; }
-    }
-
-    public class AssetTexture : Asset
-    {
-        public override AssetType AssetType { get { return AssetType.Texture; } }
-
-        public ManagedImage Image;
-        public OpenJPEG.J2KLayerInfo[] LayerInfo;
-        public int Components;
-        
-        public AssetTexture() { }
-
-        public AssetTexture(UUID assetID, byte[] assetData) : base(assetID, assetData) { }
-        
-        public AssetTexture(ManagedImage image)
-        {
-            Image = image;
-            Components = 0;
-            if ((Image.Channels & ManagedImage.ImageChannels.Color) != 0)
-                Components += 3;
-            if ((Image.Channels & ManagedImage.ImageChannels.Gray) != 0)
-                ++Components;
-            if ((Image.Channels & ManagedImage.ImageChannels.Bump) != 0)
-                ++Components;
-            if ((Image.Channels & ManagedImage.ImageChannels.Alpha) != 0)
-                ++Components;
-        }
-
-        /// <summary>
-        /// Populates the <seealso cref="AssetData"/> byte array with a JPEG2000
-        /// encoded image created from the data in <seealso cref="Image"/>
-        /// </summary>
-        public override void Encode()
-        {
-            AssetData = OpenJPEG.Encode(Image);
-        }
-        
-        /// <summary>
-        /// Decodes the JPEG2000 data in <code>AssetData</code> to the
-        /// <seealso cref="ManagedImage"/> object <seealso cref="Image"/>
-        /// </summary>
-        /// <returns>True if the decoding was successful, otherwise false</returns>
-        public override bool Decode()
-        {
-            Components = 0;
-
-            if (OpenJPEG.DecodeToImage(AssetData, out Image))
-            {
-                if ((Image.Channels & ManagedImage.ImageChannels.Color) != 0)
-                    Components += 3;
-                if ((Image.Channels & ManagedImage.ImageChannels.Gray) != 0)
-                    ++Components;
-                if ((Image.Channels & ManagedImage.ImageChannels.Bump) != 0)
-                    ++Components;
-                if ((Image.Channels & ManagedImage.ImageChannels.Alpha) != 0)
-                    ++Components;
-
-                return true;
-            }
-            else
-            {
-                return false;
-            }
-        }
-
-        /// <summary>
-        /// Decodes the begin and end byte positions for each quality layer in
-        /// the image
-        /// </summary>
-        /// <returns></returns>
-        public bool DecodeLayerBoundaries()
-        {
-            return OpenJPEG.DecodeLayerBoundaries(AssetData, out LayerInfo, out Components);
-        }
-    }
-
-    public class AssetPrim : Asset
-    {
-        public override AssetType AssetType { get { return AssetType.Object; } }
-
-        public AssetPrim() { }
-
-        public override void Encode() { }
-        public override bool Decode() { return true; }
-    }
-
-    public abstract class AssetWearable : Asset
-    {
-        public string Name = String.Empty;
-        public string Description = String.Empty;
-        public WearableType WearableType = WearableType.Shape;
-        public SaleType ForSale;
-        public int SalePrice;
-        public UUID Creator;
-        public UUID Owner;
-        public UUID LastOwner;
-        public UUID Group;
-        public bool GroupOwned;
-        public Permissions Permissions;
-        public Dictionary<int, float> Params = new Dictionary<int, float>();
-        public Dictionary<AppearanceManager.TextureIndex, UUID> Textures = new Dictionary<AppearanceManager.TextureIndex, UUID>();
-
-        public AssetWearable() { }
-
-        public AssetWearable(UUID assetID, byte[] assetData) : base(assetID, assetData) { }
-
-        public AssetWearable(string source)
-        {
-            AssetData = Utils.StringToBytes(source);
-        }
-
-        public override bool Decode()
-        {
-            int version = -1;
-            Permissions = new Permissions();
-            string data = Utils.BytesToString(AssetData);
-
-            data = data.Replace("\r", String.Empty);
-            string[] lines = data.Split('\n');
-            for (int stri = 0; stri < lines.Length; stri++)
-            {
-                if (stri == 0)
-                {
-                    string versionstring = lines[stri];
-                    version = Int32.Parse(versionstring.Split(' ')[2]);
-                    if (version != 22 && version != 18)
-                        return false;
-                }
-                else if (stri == 1)
-                {
-                    Name = lines[stri];
-                }
-                else if (stri == 2)
-                {
-                    Description = lines[stri];
-                }
-                else
-                {
-                    string line = lines[stri].Trim();
-                    string[] fields = line.Split('\t');
-
-                    if (fields.Length == 1)
-                    {
-                        fields = line.Split(' ');
-                        if (fields[0] == "parameters")
-                        {
-                            int count = Int32.Parse(fields[1]) + stri;
-                            for (; stri < count; )
-                            {
-                                stri++;
-                                line = lines[stri].Trim();
-                                fields = line.Split(' ');
-
-                                int id = Int32.Parse(fields[0]);
-                                if (fields[1] == ",")
-                                    fields[1] = "0";
-                                else
-                                    fields[1] = fields[1].Replace(',', '.');
-
-                                float weight = float.Parse(fields[1], System.Globalization.NumberStyles.Float,
-                                    Utils.EnUsCulture.NumberFormat);
-
-                                Params[id] = weight;
-                            }
-                        }
-                        else if (fields[0] == "textures")
-                        {
-                            int count = Int32.Parse(fields[1]) + stri;
-                            for (; stri < count; )
-                            {
-                                stri++;
-                                line = lines[stri].Trim();
-                                fields = line.Split(' ');
-
-                                AppearanceManager.TextureIndex id = (AppearanceManager.TextureIndex)Int32.Parse(fields[0]);
-                                UUID texture = new UUID(fields[1]);
-
-                                Textures[id] = texture;
-                            }
-                        }
-                        else if (fields[0] == "type")
-                        {
-                            WearableType = (WearableType)Int32.Parse(fields[1]);
-                        }
-
-                    }
-                    else if (fields.Length == 2)
-                    {
-                        switch (fields[0])
-                        {
-                            case "creator_mask":
-                                // Deprecated, apply this as the base mask
-                                Permissions.BaseMask = (PermissionMask)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
-                                break;
-                            case "base_mask":
-                                Permissions.BaseMask = (PermissionMask)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
-                                break;
-                            case "owner_mask":
-                                Permissions.OwnerMask = (PermissionMask)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
-                                break;
-                            case "group_mask":
-                                Permissions.GroupMask = (PermissionMask)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
-                                break;
-                            case "everyone_mask":
-                                Permissions.EveryoneMask = (PermissionMask)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
-                                break;
-                            case "next_owner_mask":
-                                Permissions.NextOwnerMask = (PermissionMask)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
-                                break;
-                            case "creator_id":
-                                Creator = new UUID(fields[1]);
-                                break;
-                            case "owner_id":
-                                Owner = new UUID(fields[1]);
-                                break;
-                            case "last_owner_id":
-                                LastOwner = new UUID(fields[1]);
-                                break;
-                            case "group_id":
-                                Group = new UUID(fields[1]);
-                                break;
-                            case "group_owned":
-                                GroupOwned = (Int32.Parse(fields[1]) != 0);
-                                break;
-                            case "sale_type":
-                                ForSale = InventoryManager.StringToSaleType(fields[1]);
-                                break;
-                            case "sale_price":
-                                SalePrice = Int32.Parse(fields[1]);
-                                break;
-                            case "sale_info":
-                                // Container for sale_type and sale_price, ignore
-                                break;
-                            default:
-                                return false;
-                        }
-                    }
-                }
-            }
-
-            return true;
-        }
-
-        public override void Encode()
-        {
-            const string NL = "\n";
-
-            StringBuilder data = new StringBuilder("LLWearable version 22\n");
-            data.Append(Name); data.Append(NL); data.Append(NL);
-            data.Append("\tpermissions 0\n\t{\n");
-            data.Append("\t\tbase_mask\t"); data.Append(Utils.UIntToHexString((uint)Permissions.BaseMask)); data.Append(NL);
-            data.Append("\t\towner_mask\t"); data.Append(Utils.UIntToHexString((uint)Permissions.OwnerMask)); data.Append(NL);
-            data.Append("\t\tgroup_mask\t"); data.Append(Utils.UIntToHexString((uint)Permissions.GroupMask)); data.Append(NL);
-            data.Append("\t\teveryone_mask\t"); data.Append(Utils.UIntToHexString((uint)Permissions.EveryoneMask)); data.Append(NL);
-            data.Append("\t\tnext_owner_mask\t"); data.Append(Utils.UIntToHexString((uint)Permissions.NextOwnerMask)); data.Append(NL);
-            data.Append("\t\tcreator_id\t"); data.Append(Creator.ToString()); data.Append(NL);
-            data.Append("\t\towner_id\t"); data.Append(Owner.ToString()); data.Append(NL);
-            data.Append("\t\tlast_owner_id\t"); data.Append(LastOwner.ToString()); data.Append(NL);
-            data.Append("\t\tgroup_id\t"); data.Append(Group.ToString()); data.Append(NL);
-            if (GroupOwned) data.Append("\t\tgroup_owned\t1\n");
-            data.Append("\t}\n");
-            data.Append("\tsale_info\t0\n");
-            data.Append("\t{\n");
-            data.Append("\t\tsale_type\t"); data.Append(InventoryManager.SaleTypeToString(ForSale)); data.Append(NL);
-            data.Append("\t\tsale_price\t"); data.Append(SalePrice); data.Append(NL);
-            data.Append("\t}\n");
-            data.Append("type "); data.Append((int)WearableType); data.Append(NL);
-
-            data.Append("parameters "); data.Append(Params.Count); data.Append(NL);
-            foreach (KeyValuePair<int, float> param in Params)
-            {
-                data.Append(param.Key); data.Append(" "); data.Append(Helpers.FloatToTerseString(param.Value)); data.Append(NL);
-            }
-
-            data.Append("textures "); data.Append(Textures.Count); data.Append(NL);
-            foreach (KeyValuePair<AppearanceManager.TextureIndex, UUID> texture in Textures)
-            {
-                data.Append(texture.Key); data.Append(" "); data.Append(texture.Value.ToString()); data.Append(NL);
-            }
-
-            AssetData = Utils.StringToBytes(data.ToString());
-        }
-    }
-
-    public class AssetClothing : AssetWearable
-    {
-        public override AssetType AssetType { get { return AssetType.Clothing; } }
-
-        public AssetClothing() { }
-        public AssetClothing(UUID assetID, byte[] assetData) : base(assetID, assetData) { }
-        public AssetClothing(string source) : base(source) { }
-    }
-
-    public class AssetBodypart : AssetWearable
-    {
-        public override AssetType AssetType { get { return AssetType.Bodypart; } }
-
-        public AssetBodypart() { }
-        public AssetBodypart(UUID assetID, byte[] assetData) : base(assetID, assetData) { }
-        public AssetBodypart(string source) : base(source) { }
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Text;
+using System.Collections.Generic;
+using OpenMetaverse.Imaging;
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// 
+    /// </summary>
+    [Flags]
+    public enum WearableType : byte
+    {
+        /// <summary>A shape</summary>
+        Shape = 0,
+        /// <summary></summary>
+        Skin,
+        /// <summary></summary>
+        Hair,
+        /// <summary></summary>
+        Eyes,
+        /// <summary></summary>
+        Shirt,
+        /// <summary></summary>
+        Pants,
+        /// <summary></summary>
+        Shoes,
+        /// <summary></summary>
+        Socks,
+        /// <summary></summary>
+        Jacket,
+        /// <summary></summary>
+        Gloves,
+        /// <summary></summary>
+        Undershirt,
+        /// <summary></summary>
+        Underpants,
+        /// <summary></summary>
+        Skirt,
+        /// <summary></summary>
+        Invalid = 255
+    };
+
+    /// <summary>
+    /// Each inventory AssetType will have its own set of flags, these are the known flags for AssetType=Object
+    /// </summary>
+    [Flags]
+    public enum ObjectType : uint
+    {
+        None = 0,
+        /// <summary>
+        /// A Landmark that has not been previously visited shows up as a dark red pushpin, one that has been
+        /// visited shows up as a light red pushpin
+        /// </summary>
+        VisitedLandmark = 1,
+        /// <summary>If set, indicates rezzed object will have more restrictive permissions masks;
+        /// Which masks will be affected are below</summary>
+        RestrictNextOwner = 0x100,
+        /// <summary>If set, and <c>RestrictNextOwner</c> bit is set indicates BaseMask will be overwritten on Rez</summary>
+        OverwriteBase = 0x010000,
+        /// <summary>If set, and <c>RestrictNextOwner</c> bit is set indicates OwnerMask will be overwritten on Rez</summary>
+        OverwriteOwner = 0x020000,
+        /// <summary>If set, and <c>RestrictNextOwner</c> bit is set indicates GroupMask will be overwritten on Rez</summary>
+        OverwriteGroup = 0x040000,
+        /// <summary>If set, and <c>RestrictNextOwner</c> bit is set indicates EveryoneMask will be overwritten on Rez</summary>
+        OverwriteEveryone = 0x080000,
+        /// <summary>If set, and <c>RestrictNextOwner</c> bit is set indicates NextOwnerMask will be overwritten on Rez</summary>
+        OverwriteNextOwner = 0x100000,
+        /// <summary>If set, indicates item is multiple items coalesced into a single item</summary>
+        MultipleObjects = 0x200000
+    }
+
+    public abstract class Asset
+    {
+        public byte[] AssetData;
+        public bool Temporary;
+
+        private UUID _AssetID;
+        public UUID AssetID
+        {
+            get { return _AssetID; }
+            internal set { _AssetID = value; }
+        }
+
+        public abstract AssetType AssetType
+        {
+            get;
+        }
+
+        public Asset() { }
+
+        public Asset(UUID assetID, byte[] assetData)
+        {
+            _AssetID = assetID;
+            AssetData = assetData;
+        }
+
+        /// <summary>
+        /// Regenerates the <code>AssetData</code> byte array from the properties 
+        /// of the derived class.
+        /// </summary>
+        public abstract void Encode();
+
+        /// <summary>
+        /// Decodes the AssetData, placing it in appropriate properties of the derived
+        /// class.
+        /// </summary>
+        /// <returns>True if the asset decoding succeeded, otherwise false</returns>
+        public abstract bool Decode();
+    }
+
+    public class AssetAnimation : Asset
+    {
+        public override AssetType AssetType { get { return AssetType.Animation; } }
+
+        public AssetAnimation() { }
+
+        public AssetAnimation(UUID assetID, byte[] assetData)
+            : base(assetID, assetData)
+        {
+            AssetData = assetData;
+        }
+
+        public override void Encode() { }
+        public override bool Decode() { return true; }
+    }
+
+    public class AssetNotecard : Asset
+    {
+        public override AssetType AssetType { get { return AssetType.Notecard; } }
+
+        public string Text = null;
+
+        public AssetNotecard() { }
+        
+        public AssetNotecard(UUID assetID, byte[] assetData) : base(assetID, assetData) 
+        {
+            Decode();
+        }
+        
+        public AssetNotecard(string text)
+        {
+            Text = text;
+            Encode();
+        }
+
+        public override void Encode()
+        {
+
+            string temp = "Linden text version 2\n{\nLLEmbeddedItems version 1\n{\ncount 0\n}\nText length ";
+            temp += Text.Length + "\n";
+            temp += Text;
+            temp += "}";
+            AssetData = Utils.StringToBytes(temp);
+        }
+        
+        public override bool Decode()
+        {
+            Text = Utils.BytesToString(AssetData);
+            return true;
+        }
+    }
+
+    public class AssetScriptText : Asset
+    {
+        public override AssetType AssetType { get { return AssetType.LSLText; } }
+
+        public string Source;
+
+        public AssetScriptText() { }
+
+        public AssetScriptText(UUID assetID, byte[] assetData) : base(assetID, assetData) { }
+        
+        public AssetScriptText(string source)
+        {
+            Source = source;
+        }
+
+        public override void Encode()
+        {
+            AssetData = Utils.StringToBytes(Source);
+        }
+
+        public override bool Decode()
+        {
+            Source = Utils.BytesToString(AssetData);
+            return true;
+        }
+    }
+
+    public class AssetScriptBinary : Asset
+    {
+        public override AssetType AssetType { get { return AssetType.LSLBytecode; } }
+
+        public AssetScriptBinary() { }
+
+        public AssetScriptBinary(UUID assetID, byte[] assetData)
+            : base(assetID, assetData)
+        {
+            AssetData = assetData;
+        }
+
+        public override void Encode() { }
+        public override bool Decode() { return true; }
+    }
+
+    public class AssetSound : Asset
+    {
+        public override AssetType AssetType { get { return AssetType.Sound; } }
+
+        public AssetSound() { }
+
+        public AssetSound(UUID assetID, byte[] assetData)
+            : base(assetID, assetData)
+        {
+            AssetData = assetData;
+        }
+
+        public override void Encode() { }
+        public override bool Decode() { return true; }
+    }
+
+    public class AssetTexture : Asset
+    {
+        public override AssetType AssetType { get { return AssetType.Texture; } }
+
+        public ManagedImage Image;
+        public OpenJPEG.J2KLayerInfo[] LayerInfo;
+        public int Components;
+        
+        public AssetTexture() { }
+
+        public AssetTexture(UUID assetID, byte[] assetData) : base(assetID, assetData) { }
+        
+        public AssetTexture(ManagedImage image)
+        {
+            Image = image;
+            Components = 0;
+            if ((Image.Channels & ManagedImage.ImageChannels.Color) != 0)
+                Components += 3;
+            if ((Image.Channels & ManagedImage.ImageChannels.Gray) != 0)
+                ++Components;
+            if ((Image.Channels & ManagedImage.ImageChannels.Bump) != 0)
+                ++Components;
+            if ((Image.Channels & ManagedImage.ImageChannels.Alpha) != 0)
+                ++Components;
+        }
+
+        /// <summary>
+        /// Populates the <seealso cref="AssetData"/> byte array with a JPEG2000
+        /// encoded image created from the data in <seealso cref="Image"/>
+        /// </summary>
+        public override void Encode()
+        {
+            AssetData = OpenJPEG.Encode(Image);
+        }
+        
+        /// <summary>
+        /// Decodes the JPEG2000 data in <code>AssetData</code> to the
+        /// <seealso cref="ManagedImage"/> object <seealso cref="Image"/>
+        /// </summary>
+        /// <returns>True if the decoding was successful, otherwise false</returns>
+        public override bool Decode()
+        {
+            Components = 0;
+
+            if (OpenJPEG.DecodeToImage(AssetData, out Image))
+            {
+                if ((Image.Channels & ManagedImage.ImageChannels.Color) != 0)
+                    Components += 3;
+                if ((Image.Channels & ManagedImage.ImageChannels.Gray) != 0)
+                    ++Components;
+                if ((Image.Channels & ManagedImage.ImageChannels.Bump) != 0)
+                    ++Components;
+                if ((Image.Channels & ManagedImage.ImageChannels.Alpha) != 0)
+                    ++Components;
+
+                return true;
+            }
+            else
+            {
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Decodes the begin and end byte positions for each quality layer in
+        /// the image
+        /// </summary>
+        /// <returns></returns>
+        public bool DecodeLayerBoundaries()
+        {
+            return OpenJPEG.DecodeLayerBoundaries(AssetData, out LayerInfo, out Components);
+        }
+    }
+
+    public class AssetPrim : Asset
+    {
+        public override AssetType AssetType { get { return AssetType.Object; } }
+
+        public AssetPrim() { }
+
+        public override void Encode() { }
+        public override bool Decode() { return true; }
+    }
+
+    public abstract class AssetWearable : Asset
+    {
+        public string Name = String.Empty;
+        public string Description = String.Empty;
+        public WearableType WearableType = WearableType.Shape;
+        public SaleType ForSale;
+        public int SalePrice;
+        public UUID Creator;
+        public UUID Owner;
+        public UUID LastOwner;
+        public UUID Group;
+        public bool GroupOwned;
+        public Permissions Permissions;
+        public Dictionary<int, float> Params = new Dictionary<int, float>();
+        public Dictionary<AppearanceManager.TextureIndex, UUID> Textures = new Dictionary<AppearanceManager.TextureIndex, UUID>();
+
+        public AssetWearable() { }
+
+        public AssetWearable(UUID assetID, byte[] assetData) : base(assetID, assetData) { }
+
+        public AssetWearable(string source)
+        {
+            AssetData = Utils.StringToBytes(source);
+        }
+
+        public override bool Decode()
+        {
+            int version = -1;
+            Permissions = new Permissions();
+            string data = Utils.BytesToString(AssetData);
+
+            data = data.Replace("\r", String.Empty);
+            string[] lines = data.Split('\n');
+            for (int stri = 0; stri < lines.Length; stri++)
+            {
+                if (stri == 0)
+                {
+                    string versionstring = lines[stri];
+                    version = Int32.Parse(versionstring.Split(' ')[2]);
+                    if (version != 22 && version != 18)
+                        return false;
+                }
+                else if (stri == 1)
+                {
+                    Name = lines[stri];
+                }
+                else if (stri == 2)
+                {
+                    Description = lines[stri];
+                }
+                else
+                {
+                    string line = lines[stri].Trim();
+                    string[] fields = line.Split('\t');
+
+                    if (fields.Length == 1)
+                    {
+                        fields = line.Split(' ');
+                        if (fields[0] == "parameters")
+                        {
+                            int count = Int32.Parse(fields[1]) + stri;
+                            for (; stri < count; )
+                            {
+                                stri++;
+                                line = lines[stri].Trim();
+                                fields = line.Split(' ');
+
+                                int id = Int32.Parse(fields[0]);
+                                if (fields[1] == ",")
+                                    fields[1] = "0";
+                                else
+                                    fields[1] = fields[1].Replace(',', '.');
+
+                                float weight = float.Parse(fields[1], System.Globalization.NumberStyles.Float,
+                                    Utils.EnUsCulture.NumberFormat);
+
+                                Params[id] = weight;
+                            }
+                        }
+                        else if (fields[0] == "textures")
+                        {
+                            int count = Int32.Parse(fields[1]) + stri;
+                            for (; stri < count; )
+                            {
+                                stri++;
+                                line = lines[stri].Trim();
+                                fields = line.Split(' ');
+
+                                AppearanceManager.TextureIndex id = (AppearanceManager.TextureIndex)Int32.Parse(fields[0]);
+                                UUID texture = new UUID(fields[1]);
+
+                                Textures[id] = texture;
+                            }
+                        }
+                        else if (fields[0] == "type")
+                        {
+                            WearableType = (WearableType)Int32.Parse(fields[1]);
+                        }
+
+                    }
+                    else if (fields.Length == 2)
+                    {
+                        switch (fields[0])
+                        {
+                            case "creator_mask":
+                                // Deprecated, apply this as the base mask
+                                Permissions.BaseMask = (PermissionMask)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
+                                break;
+                            case "base_mask":
+                                Permissions.BaseMask = (PermissionMask)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
+                                break;
+                            case "owner_mask":
+                                Permissions.OwnerMask = (PermissionMask)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
+                                break;
+                            case "group_mask":
+                                Permissions.GroupMask = (PermissionMask)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
+                                break;
+                            case "everyone_mask":
+                                Permissions.EveryoneMask = (PermissionMask)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
+                                break;
+                            case "next_owner_mask":
+                                Permissions.NextOwnerMask = (PermissionMask)UInt32.Parse(fields[1], System.Globalization.NumberStyles.HexNumber);
+                                break;
+                            case "creator_id":
+                                Creator = new UUID(fields[1]);
+                                break;
+                            case "owner_id":
+                                Owner = new UUID(fields[1]);
+                                break;
+                            case "last_owner_id":
+                                LastOwner = new UUID(fields[1]);
+                                break;
+                            case "group_id":
+                                Group = new UUID(fields[1]);
+                                break;
+                            case "group_owned":
+                                GroupOwned = (Int32.Parse(fields[1]) != 0);
+                                break;
+                            case "sale_type":
+                                ForSale = InventoryManager.StringToSaleType(fields[1]);
+                                break;
+                            case "sale_price":
+                                SalePrice = Int32.Parse(fields[1]);
+                                break;
+                            case "sale_info":
+                                // Container for sale_type and sale_price, ignore
+                                break;
+                            default:
+                                return false;
+                        }
+                    }
+                }
+            }
+
+            return true;
+        }
+
+        public override void Encode()
+        {
+            const string NL = "\n";
+
+            StringBuilder data = new StringBuilder("LLWearable version 22\n");
+            data.Append(Name); data.Append(NL); data.Append(NL);
+            data.Append("\tpermissions 0\n\t{\n");
+            data.Append("\t\tbase_mask\t"); data.Append(Utils.UIntToHexString((uint)Permissions.BaseMask)); data.Append(NL);
+            data.Append("\t\towner_mask\t"); data.Append(Utils.UIntToHexString((uint)Permissions.OwnerMask)); data.Append(NL);
+            data.Append("\t\tgroup_mask\t"); data.Append(Utils.UIntToHexString((uint)Permissions.GroupMask)); data.Append(NL);
+            data.Append("\t\teveryone_mask\t"); data.Append(Utils.UIntToHexString((uint)Permissions.EveryoneMask)); data.Append(NL);
+            data.Append("\t\tnext_owner_mask\t"); data.Append(Utils.UIntToHexString((uint)Permissions.NextOwnerMask)); data.Append(NL);
+            data.Append("\t\tcreator_id\t"); data.Append(Creator.ToString()); data.Append(NL);
+            data.Append("\t\towner_id\t"); data.Append(Owner.ToString()); data.Append(NL);
+            data.Append("\t\tlast_owner_id\t"); data.Append(LastOwner.ToString()); data.Append(NL);
+            data.Append("\t\tgroup_id\t"); data.Append(Group.ToString()); data.Append(NL);
+            if (GroupOwned) data.Append("\t\tgroup_owned\t1\n");
+            data.Append("\t}\n");
+            data.Append("\tsale_info\t0\n");
+            data.Append("\t{\n");
+            data.Append("\t\tsale_type\t"); data.Append(InventoryManager.SaleTypeToString(ForSale)); data.Append(NL);
+            data.Append("\t\tsale_price\t"); data.Append(SalePrice); data.Append(NL);
+            data.Append("\t}\n");
+            data.Append("type "); data.Append((int)WearableType); data.Append(NL);
+
+            data.Append("parameters "); data.Append(Params.Count); data.Append(NL);
+            foreach (KeyValuePair<int, float> param in Params)
+            {
+                data.Append(param.Key); data.Append(" "); data.Append(Helpers.FloatToTerseString(param.Value)); data.Append(NL);
+            }
+
+            data.Append("textures "); data.Append(Textures.Count); data.Append(NL);
+            foreach (KeyValuePair<AppearanceManager.TextureIndex, UUID> texture in Textures)
+            {
+                data.Append(texture.Key); data.Append(" "); data.Append(texture.Value.ToString()); data.Append(NL);
+            }
+
+            AssetData = Utils.StringToBytes(data.ToString());
+        }
+    }
+
+    public class AssetClothing : AssetWearable
+    {
+        public override AssetType AssetType { get { return AssetType.Clothing; } }
+
+        public AssetClothing() { }
+        public AssetClothing(UUID assetID, byte[] assetData) : base(assetID, assetData) { }
+        public AssetClothing(string source) : base(source) { }
+    }
+
+    public class AssetBodypart : AssetWearable
+    {
+        public override AssetType AssetType { get { return AssetType.Bodypart; } }
+
+        public AssetBodypart() { }
+        public AssetBodypart(UUID assetID, byte[] assetData) : base(assetID, assetData) { }
+        public AssetBodypart(string source) : base(source) { }
+    }
+}
Index: AssetManager.cs
===================================================================
--- AssetManager.cs	(revision 2445)
+++ AssetManager.cs	(working copy)
@@ -1,1526 +1,1526 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using System.Threading;
-using System.IO;
-using OpenMetaverse;
-using OpenMetaverse.Packets;
-
-namespace OpenMetaverse
-{
-    #region Enums
-
-    /// <summary>
-    /// The different types of grid assets
-    /// </summary>
-    public enum AssetType : sbyte
-    {
-        /// <summary>Unknown asset type</summary>
-        Unknown = -1,
-        /// <summary>Texture asset, stores in JPEG2000 J2C stream format</summary>
-        Texture = 0,
-        /// <summary>Sound asset</summary>
-        Sound = 1,
-        /// <summary>Calling card for another avatar</summary>
-        CallingCard = 2,
-        /// <summary>Link to a location in world</summary>
-        Landmark = 3,
-        // <summary>Legacy script asset, you should never see one of these</summary>
-        //[Obsolete]
-        //Script = 4,
-        /// <summary>Collection of textures and parameters that can be 
-        /// worn by an avatar</summary>
-        Clothing = 5,
-        /// <summary>Primitive that can contain textures, sounds, 
-        /// scripts and more</summary>
-        Object = 6,
-        /// <summary>Notecard asset</summary>
-        Notecard = 7,
-        /// <summary>Holds a collection of inventory items</summary>
-        Folder = 8,
-        /// <summary>Root inventory folder</summary>
-        RootFolder = 9,
-        /// <summary>Linden scripting language script</summary>
-        LSLText = 10,
-        /// <summary>LSO bytecode for a script</summary>
-        LSLBytecode = 11,
-        /// <summary>Uncompressed TGA texture</summary>
-        TextureTGA = 12,
-        /// <summary>Collection of textures and shape parameters that can
-        /// be worn</summary>
-        Bodypart = 13,
-        /// <summary>Trash folder</summary>
-        TrashFolder = 14,
-        /// <summary>Snapshot folder</summary>
-        SnapshotFolder = 15,
-        /// <summary>Lost and found folder</summary>
-        LostAndFoundFolder = 16,
-        /// <summary>Uncompressed sound</summary>
-        SoundWAV = 17,
-        /// <summary>Uncompressed TGA non-square image, not to be used as a
-        /// texture</summary>
-        ImageTGA = 18,
-        /// <summary>Compressed JPEG non-square image, not to be used as a
-        /// texture</summary>
-        ImageJPEG = 19,
-        /// <summary>Animation</summary>
-        Animation = 20,
-        /// <summary>Sequence of animations, sounds, chat, and pauses</summary>
-        Gesture = 21,
-        /// <summary>Simstate file</summary>
-        Simstate = 22,
-    }
-
-    public enum EstateAssetType : int
-    {
-        None = -1,
-        Covenant = 0
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public enum StatusCode
-    {
-        /// <summary>OK</summary>
-        OK = 0,
-        /// <summary>Transfer completed</summary>
-        Done = 1,
-        /// <summary></summary>
-        Skip = 2,
-        /// <summary></summary>
-        Abort = 3,
-        /// <summary>Unknown error occurred</summary>
-        Error = -1,
-        /// <summary>Equivalent to a 404 error</summary>
-        UnknownSource = -2,
-        /// <summary>Client does not have permission for that resource</summary>
-        InsufficientPermissiosn = -3,
-        /// <summary>Unknown status</summary>
-        Unknown = -4
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public enum ChannelType : int
-    {
-        /// <summary></summary>
-        Unknown = 0,
-        /// <summary>Unknown</summary>
-        Misc = 1,
-        /// <summary>Virtually all asset transfers use this channel</summary>
-        Asset = 2
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public enum SourceType : int
-    {
-        /// <summary></summary>
-        Unknown = 0,
-        /// <summary>Asset from the asset server</summary>
-        Asset = 2,
-        /// <summary>Inventory item</summary>
-        SimInventoryItem = 3,
-        /// <summary>Estate asset, such as an estate covenant</summary>
-        SimEstate = 4
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public enum TargetType : int
-    {
-        /// <summary></summary>
-        Unknown = 0,
-        /// <summary></summary>
-        File = 1,
-        /// <summary></summary>
-        VFile = 2
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public enum ImageType : byte
-    {
-        /// <summary></summary>
-        Normal = 0,
-        /// <summary></summary>
-        Baked = 1
-    }
-
-    /// <summary>
-    /// Image file format
-    /// </summary>
-    public enum ImageCodec : byte
-    {
-        Invalid = 0,
-        RGB = 1,
-        J2C = 2,
-        BMP = 3,
-        TGA = 4,
-        JPEG = 5,
-        DXT = 6,
-        PNG = 7
-    }
-
-    public enum TransferError : int
-    {
-        None = 0,
-        Failed = -1,
-        AssetNotFound = -3,
-        AssetNotFoundInDatabase = -4,
-        InsufficientPermissions = -5,
-        EOF = -39,
-        CannotOpenFile = -42,
-        FileNotFound = -43,
-        FileIsEmpty = -44,
-        TCPTimeout = -23016,
-        CircuitGone = -23017
-    }
-
-    #endregion Enums
-
-    #region Transfer Classes
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public class Transfer
-    {
-        public UUID ID;
-        public int Size;
-        public byte[] AssetData = new byte[0];
-        public int Transferred;
-        public bool Success;
-        public AssetType AssetType;
-
-        private int transferStart;
-
-        /// <summary>Number of milliseconds passed since the last transfer
-        /// packet was received</summary>
-        public int TimeSinceLastPacket
-        {
-            get { return Environment.TickCount - transferStart; }
-            internal set { transferStart = Environment.TickCount + value; }
-        }
-
-        public Transfer()
-        {
-            AssetData = new byte[0];
-            transferStart = Environment.TickCount;
-        }
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public class AssetDownload : Transfer
-    {
-        public UUID AssetID;
-        public ChannelType Channel;
-        public SourceType Source;
-        public TargetType Target;
-        public StatusCode Status;
-        public float Priority;
-        public Simulator Simulator;
-
-        internal AutoResetEvent HeaderReceivedEvent = new AutoResetEvent(false);
-
-        public AssetDownload()
-            : base()
-        {
-        }
-    }
-
-    public class XferDownload : Transfer
-    {
-        public ulong XferID;
-        public UUID VFileID;
-        public AssetType Type;
-        public uint PacketNum;
-        public string Filename = String.Empty;
-
-        public XferDownload()
-            : base()
-        {
-        }
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public class ImageDownload : Transfer
-    {
-        public ushort PacketCount;
-        public ImageCodec Codec;
-        public bool NotFound;
-        public Simulator Simulator;
-        public SortedList<ushort, ushort> PacketsSeen;
-        public ImageType ImageType;
-        public int DiscardLevel;
-        public float Priority;
-
-        internal int InitialDataSize;
-        internal AutoResetEvent HeaderReceivedEvent = new AutoResetEvent(false);
-
-        public ImageDownload()
-            : base()
-        {
-        }
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public class AssetUpload : Transfer
-    {
-        public UUID AssetID;
-        public AssetType Type;
-        public ulong XferID;
-        public uint PacketNum;
-
-        public AssetUpload()
-            : base()
-        {
-        }
-    }
-
-    public class ImageRequest
-    {
-        public ImageRequest(UUID imageid, ImageType type, float priority, int discardLevel)
-        {
-            ImageID = imageid;
-            Type = type;
-            Priority = priority;
-            DiscardLevel = discardLevel;
-        }
-        public UUID ImageID;
-        public ImageType Type;
-        public float Priority;
-        public int DiscardLevel;
-    }
-    #endregion Transfer Classes
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public class AssetManager
-    {
-        #region Delegates
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="transfer"></param>
-        /// <param name="asset"></param>
-        public delegate void AssetReceivedCallback(AssetDownload transfer, Asset asset);
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="xfer"></param>
-        public delegate void XferReceivedCallback(XferDownload xfer);
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="image"></param>
-        /// <param name="asset"></param>
-        public delegate void ImageReceivedCallback(ImageDownload image, AssetTexture asset);
-        /// <summary>
-        /// 
-        /// </summary>
-        public delegate void ImageReceiveProgressCallback(UUID image, int lastPacket, int recieved, int total);
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="upload"></param>
-        public delegate void AssetUploadedCallback(AssetUpload upload);
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="upload"></param>
-        public delegate void UploadProgressCallback(AssetUpload upload);
-
-        #endregion Delegates
-
-        #region Events
-
-        /// <summary></summary>
-        public event AssetReceivedCallback OnAssetReceived;
-        /// <summary></summary>
-        public event XferReceivedCallback OnXferReceived;
-        /// <summary></summary>
-        public event ImageReceivedCallback OnImageReceived;
-        /// <summary></summary>
-        public event ImageReceiveProgressCallback OnImageReceiveProgress;
-        /// <summary></summary>
-        public event AssetUploadedCallback OnAssetUploaded;
-        /// <summary></summary>
-        public event UploadProgressCallback OnUploadProgress;
-
-        #endregion Events
-
-        /// <summary>Texture download cache</summary>
-        public TextureCache Cache;
-
-        private GridClient Client;
-        private Dictionary<UUID, Transfer> Transfers = new Dictionary<UUID, Transfer>();
-        private AssetUpload PendingUpload;
-        private object PendingUploadLock = new object();
-        private volatile bool WaitingForUploadConfirm = false;
-        private System.Timers.Timer RefreshDownloadsTimer = new System.Timers.Timer(500.0);
-        
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        /// <param name="client">A reference to the GridClient object</param>
-        public AssetManager(GridClient client)
-        {
-            Client = client;
-            Cache = new TextureCache(client);
-
-            // Transfer packets for downloading large assets
-            Client.Network.RegisterCallback(PacketType.TransferInfo, new NetworkManager.PacketCallback(TransferInfoHandler));
-            Client.Network.RegisterCallback(PacketType.TransferPacket, new NetworkManager.PacketCallback(TransferPacketHandler));
-
-            // Image downloading packets
-            Client.Network.RegisterCallback(PacketType.ImageData, new NetworkManager.PacketCallback(ImageDataHandler));
-            Client.Network.RegisterCallback(PacketType.ImagePacket, new NetworkManager.PacketCallback(ImagePacketHandler));
-            Client.Network.RegisterCallback(PacketType.ImageNotInDatabase, new NetworkManager.PacketCallback(ImageNotInDatabaseHandler));
-
-            // Xfer packets for uploading large assets
-            Client.Network.RegisterCallback(PacketType.RequestXfer, new NetworkManager.PacketCallback(RequestXferHandler));
-            Client.Network.RegisterCallback(PacketType.ConfirmXferPacket, new NetworkManager.PacketCallback(ConfirmXferPacketHandler));
-            Client.Network.RegisterCallback(PacketType.AssetUploadComplete, new NetworkManager.PacketCallback(AssetUploadCompleteHandler));
-
-            // Xfer packet for downloading misc assets
-            Client.Network.RegisterCallback(PacketType.SendXferPacket, new NetworkManager.PacketCallback(SendXferPacketHandler));
-
-            // HACK: Re-request stale pending image downloads
-            RefreshDownloadsTimer.Elapsed += new System.Timers.ElapsedEventHandler(RefreshDownloadsTimer_Elapsed);
-            RefreshDownloadsTimer.Start();
-        }
-
-        private void RefreshDownloadsTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
-        {
-            lock (Transfers)
-            {
-                foreach (Transfer transfer in Transfers.Values)
-                {
-                    if (transfer is ImageDownload)
-                    {
-                        ImageDownload download = (ImageDownload)transfer;
-
-                        uint packet = 0;
-                        
-                        if (download.PacketsSeen != null && download.PacketsSeen.Count > 0)
-                        {
-                            lock (download.PacketsSeen)
-                            {
-                                bool first = true;
-                                foreach (KeyValuePair<ushort, ushort> packetSeen in download.PacketsSeen)
-                                {
-                                    if (first)
-                                    {
-                                        // Initially set this to the earliest packet received in the transfer
-                                        packet = packetSeen.Value;
-                                        first = false;
-                                    }
-                                    else
-                                    {
-                                        ++packet;
-
-                                        // If there is a missing packet in the list, break and request the download
-                                        // resume here
-                                        if (packetSeen.Value != packet)
-                                        {
-                                            --packet;
-                                            break;
-                                        }
-                                    }
-                                }
-
-                                ++packet;
-                            }
-                        }
-
-                        if (download.TimeSinceLastPacket > 5000)
-                        {
-                            --download.DiscardLevel;
-                            download.TimeSinceLastPacket = 0;
-                            RequestImage(download.ID, download.ImageType, download.Priority, download.DiscardLevel, packet);
-                        }
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Request an asset download
-        /// </summary>
-        /// <param name="assetID">Asset UUID</param>
-        /// <param name="type">Asset type, must be correct for the transfer to succeed</param>
-        /// <param name="priority">Whether to give this transfer an elevated priority</param>
-        /// <returns>The transaction ID generated for this transfer</returns>
-        public UUID RequestAsset(UUID assetID, AssetType type, bool priority)
-        {
-            AssetDownload transfer = new AssetDownload();
-            transfer.ID = UUID.Random();
-            transfer.AssetID = assetID;
-            //transfer.AssetType = type; // Set in TransferInfoHandler.
-            transfer.Priority = 100.0f + (priority ? 1.0f : 0.0f);
-            transfer.Channel = ChannelType.Asset;
-            transfer.Source = SourceType.Asset;
-            transfer.Simulator = Client.Network.CurrentSim;
-
-            // Add this transfer to the dictionary
-            lock (Transfers) Transfers[transfer.ID] = transfer;
-
-            // Build the request packet and send it
-            TransferRequestPacket request = new TransferRequestPacket();
-            request.TransferInfo.ChannelType = (int)transfer.Channel;
-            request.TransferInfo.Priority = transfer.Priority;
-            request.TransferInfo.SourceType = (int)transfer.Source;
-            request.TransferInfo.TransferID = transfer.ID;
-
-            byte[] paramField = new byte[20];
-            Buffer.BlockCopy(assetID.GetBytes(), 0, paramField, 0, 16);
-            Buffer.BlockCopy(Utils.IntToBytes((int)type), 0, paramField, 16, 4);
-            request.TransferInfo.Params = paramField;
-
-            Client.Network.SendPacket(request, transfer.Simulator);
-            return transfer.ID;
-        }
-
-        /// <summary>
-        /// Request an asset download through the almost deprecated Xfer system
-        /// </summary>
-        /// <param name="filename">Filename of the asset to request</param>
-        /// <param name="deleteOnCompletion">Whether or not to delete the asset
-        /// off the server after it is retrieved</param>
-        /// <param name="useBigPackets">Use large transfer packets or not</param>
-        /// <param name="vFileID">UUID of the file to request, if filename is
-        /// left empty</param>
-        /// <param name="vFileType">Asset type of <code>vFileID</code>, or
-        /// <code>AssetType.Unknown</code> if filename is not empty</param>
-        /// <param name="fromCache">Sets the FilePath in the request to Cache
-        /// (4) if true, otherwise Unknown (0) is used</param>
-        /// <returns></returns>
-        public ulong RequestAssetXfer(string filename, bool deleteOnCompletion, bool useBigPackets, UUID vFileID, AssetType vFileType,
-            bool fromCache)
-        {
-            UUID uuid = UUID.Random();
-            ulong id = uuid.GetULong();
-
-            XferDownload transfer = new XferDownload();
-            transfer.XferID = id;
-            transfer.ID = new UUID(id); // Our dictionary tracks transfers with UUIDs, so convert the ulong back
-            transfer.Filename = filename;
-            transfer.VFileID = vFileID;
-            transfer.AssetType = vFileType;
-
-            // Add this transfer to the dictionary
-            lock (Transfers) Transfers[transfer.ID] = transfer;
-
-            RequestXferPacket request = new RequestXferPacket();
-            request.XferID.ID = id;
-            request.XferID.Filename = Utils.StringToBytes(filename);
-            request.XferID.FilePath = fromCache ? (byte)4 : (byte)0;
-            request.XferID.DeleteOnCompletion = deleteOnCompletion;
-            request.XferID.UseBigPackets = useBigPackets;
-            request.XferID.VFileID = vFileID;
-            request.XferID.VFileType = (short)vFileType;
-
-            Client.Network.SendPacket(request);
-
-            return id;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="assetID">Use UUID.Zero if you do not have the 
-        /// asset ID but have all the necessary permissions</param>
-        /// <param name="itemID">The item ID of this asset in the inventory</param>
-        /// <param name="taskID">Use UUID.Zero if you are not requesting an 
-        /// asset from an object inventory</param>
-        /// <param name="ownerID">The owner of this asset</param>
-        /// <param name="type">Asset type</param>
-        /// <param name="priority">Whether to prioritize this asset download or not</param>
-        public UUID RequestInventoryAsset(UUID assetID, UUID itemID, UUID taskID, UUID ownerID, AssetType type, bool priority)
-        {
-            AssetDownload transfer = new AssetDownload();
-            transfer.ID = UUID.Random();
-            transfer.AssetID = assetID;
-            //transfer.AssetType = type; // Set in TransferInfoHandler.
-            transfer.Priority = 100.0f + (priority ? 1.0f : 0.0f);
-            transfer.Channel = ChannelType.Asset;
-            transfer.Source = SourceType.SimInventoryItem;
-            transfer.Simulator = Client.Network.CurrentSim;
-
-            // Add this transfer to the dictionary
-            lock (Transfers) Transfers[transfer.ID] = transfer;
-
-            // Build the request packet and send it
-            TransferRequestPacket request = new TransferRequestPacket();
-            request.TransferInfo.ChannelType = (int)transfer.Channel;
-            request.TransferInfo.Priority = transfer.Priority;
-            request.TransferInfo.SourceType = (int)transfer.Source;
-            request.TransferInfo.TransferID = transfer.ID;
-
-            byte[] paramField = new byte[100];
-            Buffer.BlockCopy(Client.Self.AgentID.GetBytes(), 0, paramField, 0, 16);
-            Buffer.BlockCopy(Client.Self.SessionID.GetBytes(), 0, paramField, 16, 16);
-            Buffer.BlockCopy(ownerID.GetBytes(), 0, paramField, 32, 16);
-            Buffer.BlockCopy(taskID.GetBytes(), 0, paramField, 48, 16);
-            Buffer.BlockCopy(itemID.GetBytes(), 0, paramField, 64, 16);
-            Buffer.BlockCopy(assetID.GetBytes(), 0, paramField, 80, 16);
-            Buffer.BlockCopy(Utils.IntToBytes((int)type), 0, paramField, 96, 4);
-            request.TransferInfo.Params = paramField;
-
-            Client.Network.SendPacket(request, transfer.Simulator);
-            return transfer.ID;
-        }
-
-        public UUID RequestInventoryAsset(InventoryItem item, bool priority)
-        {
-            return RequestInventoryAsset(item.AssetUUID, item.UUID, UUID.Zero, item.OwnerID, item.AssetType, priority);
-        }
-
-        public void RequestEstateAsset()
-        {
-            throw new Exception("This function is not implemented yet!");
-        }
-
-        /// <summary>
-        /// Initiate an image download. This is an asynchronous function
-        /// </summary>
-        /// <param name="imageID">The image to download</param>
-        /// <param name="type">Type of the image to download, either a baked
-        /// avatar texture or a normal texture</param>
-        public void RequestImage(UUID imageID, ImageType type)
-        {
-            RequestImage(imageID, type, 1013000.0f, 0, 0);
-        }
-
-        /// <summary>
-        /// Initiate an image download. This is an asynchronous function
-        /// </summary>
-        /// <param name="imageID">The image to download</param>
-        /// <param name="type">Type of the image to download, either a baked
-        /// avatar texture or a normal texture</param>
-        /// <param name="priority">Priority level of the download. Default is
-        /// <c>1,013,000.0f</c></param>
-        /// <param name="discardLevel">Number of quality layers to discard.
-        /// This controls the end marker of the data sent</param>
-        /// <param name="packetNum">Packet number to start the download at.
-        /// This controls the start marker of the data sent</param>
-        /// <remarks>Sending a priority of 0 and a discardlevel of -1 aborts
-        /// download</remarks>
-        public void RequestImage(UUID imageID, ImageType type, float priority, int discardLevel, uint packetNum)
-        {
-            if (Cache.HasImage(imageID))
-            {
-                ImageDownload transfer = Cache.GetCachedImage(imageID);
-                transfer.ImageType = type;
-
-                if (null != transfer)
-                {
-                    if (null != OnImageReceived)
-                    {
-                        AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
-
-                        try { OnImageReceived(transfer, asset); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                    }
-                    return;
-                }
-            }
-
-            // Priority == 0 && DiscardLevel == -1 means cancel the transfer
-            if (priority.Equals(0) && discardLevel.Equals(-1))
-            {
-                if (Transfers.ContainsKey(imageID))
-                    Transfers.Remove(imageID);
-
-                RequestImagePacket cancel = new RequestImagePacket();
-                cancel.AgentData.AgentID = Client.Self.AgentID;
-                cancel.AgentData.SessionID = Client.Self.SessionID;
-                cancel.RequestImage = new RequestImagePacket.RequestImageBlock[1];
-                cancel.RequestImage[0] = new RequestImagePacket.RequestImageBlock();
-                cancel.RequestImage[0].DiscardLevel = -1;
-                cancel.RequestImage[0].DownloadPriority = 0;
-                cancel.RequestImage[0].Packet = 0;
-                cancel.RequestImage[0].Image = imageID;
-                cancel.RequestImage[0].Type = 0;
-            }
-            else
-            {
-                Simulator currentSim = Client.Network.CurrentSim;
-
-                if (!Transfers.ContainsKey(imageID))
-                {
-                    // New download
-                    ImageDownload transfer = new ImageDownload();
-                    transfer.ID = imageID;
-                    transfer.Simulator = currentSim;
-                    transfer.ImageType = type;
-                    transfer.DiscardLevel = discardLevel;
-                    transfer.Priority = priority;
-
-                    // Add this transfer to the dictionary
-                    lock (Transfers) Transfers[transfer.ID] = transfer;
-
-                    Logger.DebugLog("Adding image " + imageID.ToString() + " to the download queue");
-                }
-                else
-                {
-                    // Already downloading, just updating the priority
-                    Transfer transfer = Transfers[imageID];
-                    float percentComplete = ((float)transfer.Transferred / (float)transfer.Size) * 100f;
-                    if (Single.IsNaN(percentComplete))
-                        percentComplete = 0f;
-
-                    Logger.DebugLog(String.Format("Updating priority on image transfer {0}, {1}% complete",
-                        imageID, Math.Round(percentComplete, 2)));
-                }
-
-                // Build and send the request packet
-                RequestImagePacket request = new RequestImagePacket();
-                request.AgentData.AgentID = Client.Self.AgentID;
-                request.AgentData.SessionID = Client.Self.SessionID;
-                request.RequestImage = new RequestImagePacket.RequestImageBlock[1];
-                request.RequestImage[0] = new RequestImagePacket.RequestImageBlock();
-                request.RequestImage[0].DiscardLevel = (sbyte)discardLevel;
-                request.RequestImage[0].DownloadPriority = priority;
-                request.RequestImage[0].Packet = packetNum;
-                request.RequestImage[0].Image = imageID;
-                request.RequestImage[0].Type = (byte)type;
-
-                Client.Network.SendPacket(request, currentSim);
-            }
-        }
-
-        /// <summary>
-        /// Requests multiple Images
-        /// </summary>
-        /// <param name="Images">List of requested images</param>
-        public void RequestImages(List<ImageRequest> Images)
-        {
-            for (int iri = 0; iri < Images.Count; iri++)
-            {
-                if (Transfers.ContainsKey(Images[iri].ImageID))
-                {
-                    Images.RemoveAt(iri);
-                }
-
-                if (Cache.HasImage(Images[iri].ImageID))
-                {
-                    ImageDownload transfer = Cache.GetCachedImage(Images[iri].ImageID);
-                    if (null != transfer)
-                    {
-                        if (null != OnImageReceived)
-                        {
-                            AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
-
-                            try { OnImageReceived(transfer, asset); }
-                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                        }
-
-                        Images.RemoveAt(iri);
-                    }
-                }
-            }
-
-            if (Images.Count > 0)
-            {
-                // Build and send the request packet
-                RequestImagePacket request = new RequestImagePacket();
-                request.AgentData.AgentID = Client.Self.AgentID;
-                request.AgentData.SessionID = Client.Self.SessionID;
-                request.RequestImage = new RequestImagePacket.RequestImageBlock[Images.Count];
-
-                for (int iru = 0; iru < Images.Count; ++iru)
-                {
-                    ImageDownload transfer = new ImageDownload();
-                    //transfer.AssetType = AssetType.Texture // Handled in ImageDataHandler.
-                    transfer.ID = Images[iru].ImageID;
-                    transfer.Simulator = Client.Network.CurrentSim;
-                    transfer.ImageType = Images[iru].Type;
-                    transfer.DiscardLevel = Images[iru].DiscardLevel;
-                    transfer.Priority = Images[iru].Priority;
-
-                    // Add this transfer to the dictionary
-                    lock (Transfers) Transfers[transfer.ID] = transfer;
-                    request.RequestImage[iru] = new RequestImagePacket.RequestImageBlock();
-                    request.RequestImage[iru].DiscardLevel = (sbyte)Images[iru].DiscardLevel;
-                    request.RequestImage[iru].DownloadPriority = Images[iru].Priority;
-                    request.RequestImage[iru].Packet = 0;
-                    request.RequestImage[iru].Image = Images[iru].ImageID;
-                    request.RequestImage[iru].Type = (byte)Images[iru].Type;
-                }
-
-                Client.Network.SendPacket(request, Client.Network.CurrentSim);
-            }
-            else
-            {
-                Logger.Log("RequestImages() called for an image(s) we are already downloading or an empty list, ignoring",
-                    Helpers.LogLevel.Info, Client);
-            }
-        }
-
-        public UUID RequestUpload(Asset asset, bool storeLocal)
-        {
-            if (asset.AssetData == null)
-                throw new ArgumentException("Can't upload an asset with no data (did you forget to call Encode?)");
-
-            UUID assetID;
-            UUID transferID = RequestUpload(out assetID, asset.AssetType, asset.AssetData, storeLocal);
-            asset.AssetID = assetID;
-            return transferID;
-        }
-        
-        public UUID RequestUpload(AssetType type, byte[] data, bool storeLocal)
-        {
-            UUID assetID;
-            return RequestUpload(out assetID, type, data, storeLocal);
-        }
-
-        public UUID RequestUpload(out UUID assetID, AssetType type, byte[] data, bool storeLocal)
-		{
-			return RequestUpload(out assetID, type, data, storeLocal, UUID.Random());
-		}
-		
-        /// <summary>
-        /// Initiate an asset upload
-        /// </summary>
-        /// <param name="assetID">The ID this asset will have if the
-        /// upload succeeds</param>
-        /// <param name="type">Asset type to upload this data as</param>
-        /// <param name="data">Raw asset data to upload</param>
-        /// <param name="storeLocal">Whether to store this asset on the local
-        /// simulator or the grid-wide asset server</param>
-        /// <param name="transactionID">The tranaction id for the upload <see cref="RequestCreateItem"/></param>
-        /// <returns>The transaction ID of this transfer</returns>
-        public UUID RequestUpload(out UUID assetID, AssetType type, byte[] data, bool storeLocal, UUID transactionID)
-        {
-            AssetUpload upload = new AssetUpload();
-            upload.AssetData = data;
-            upload.AssetType = type;
-            assetID = UUID.Combine(transactionID, Client.Self.SecureSessionID);
-            upload.AssetID = assetID;
-            upload.Size = data.Length;
-            upload.XferID = 0;
-			upload.ID = transactionID;
-			
-            // Build and send the upload packet
-            AssetUploadRequestPacket request = new AssetUploadRequestPacket();
-            request.AssetBlock.StoreLocal = storeLocal;
-            request.AssetBlock.Tempfile = false; // This field is deprecated
-            request.AssetBlock.TransactionID = transactionID;
-            request.AssetBlock.Type = (sbyte)type;
-
-            if (data.Length + 100 < Settings.MAX_PACKET_SIZE)
-            {
-                Logger.Log(
-                    String.Format("Beginning asset upload [Single Packet], ID: {0}, AssetID: {1}, Size: {2}",
-                    upload.ID.ToString(), upload.AssetID.ToString(), upload.Size), Helpers.LogLevel.Info, Client);
-
-                    Transfers[upload.ID]=upload;         
-                
-                // The whole asset will fit in this packet, makes things easy
-                request.AssetBlock.AssetData = data;
-                upload.Transferred = data.Length;
-            }
-            else
-            {
-                Logger.Log(
-                    String.Format("Beginning asset upload [Multiple Packets], ID: {0}, AssetID: {1}, Size: {2}",
-                    upload.ID.ToString(), upload.AssetID.ToString(), upload.Size), Helpers.LogLevel.Info, Client);
-
-                // Asset is too big, send in multiple packets
-                request.AssetBlock.AssetData = new byte[0];
-            }
-
-            // Wait for the previous upload to receive a RequestXferPacket
-            lock (PendingUploadLock)
-            {
-                const int UPLOAD_CONFIRM_TIMEOUT = 10000;
-                const int SLEEP_INTERVAL = 50;
-                int t = 0;
-                while (WaitingForUploadConfirm && t < UPLOAD_CONFIRM_TIMEOUT)
-                {
-                    System.Threading.Thread.Sleep(SLEEP_INTERVAL);
-                    t += SLEEP_INTERVAL;
-                }
-
-                if (t < UPLOAD_CONFIRM_TIMEOUT)
-                {
-                    WaitingForUploadConfirm = true;
-                    PendingUpload = upload;
-                    Client.Network.SendPacket(request);
-
-                    return upload.ID;
-                }
-                else
-                {
-                    throw new Exception("Timeout waiting for previous asset upload to begin");
-                }
-            }
-        }
-
-        #region Helpers
-
-        private Asset CreateAssetWrapper(AssetType type)
-        {
-            Asset asset;
-
-            switch (type)
-            {
-                case AssetType.Notecard:
-                    asset = new AssetNotecard();
-                    break;
-                case AssetType.LSLText:
-                    asset = new AssetScriptText();
-                    break;
-                case AssetType.LSLBytecode:
-                    asset = new AssetScriptBinary();
-                    break;
-                case AssetType.Texture:
-                    asset = new AssetTexture();
-                    break;
-                case AssetType.Object:
-                    asset = new AssetPrim();
-                    break;
-                case AssetType.Clothing:
-                    asset = new AssetClothing();
-                    break;
-                case AssetType.Bodypart:
-                    asset = new AssetBodypart();
-                    break;
-                case AssetType.Animation:
-                    asset = new AssetAnimation();
-                    break;
-                case AssetType.Sound:
-                    asset = new AssetSound();
-                    break;
-                default:
-                    Logger.Log("Unimplemented asset type: " + type, Helpers.LogLevel.Error, Client);
-                    return null;
-            }
-
-            return asset;
-        }
-
-        private Asset WrapAsset(AssetDownload download)
-        {
-            Asset asset = CreateAssetWrapper(download.AssetType);
-            if (asset != null)
-            {
-                asset.AssetID = download.AssetID;
-                asset.AssetData = download.AssetData;
-                return asset;
-            }
-            else
-            {
-                return null;
-            }
-        }
-
-        private void SendNextUploadPacket(AssetUpload upload)
-        {
-            SendXferPacketPacket send = new SendXferPacketPacket();
-
-            send.XferID.ID = upload.XferID;
-            send.XferID.Packet = upload.PacketNum++;
-
-            if (send.XferID.Packet == 0)
-            {
-                // The first packet reserves the first four bytes of the data for the
-                // total length of the asset and appends 1000 bytes of data after that
-                send.DataPacket.Data = new byte[1004];
-                Buffer.BlockCopy(Utils.IntToBytes(upload.Size), 0, send.DataPacket.Data, 0, 4);
-                Buffer.BlockCopy(upload.AssetData, 0, send.DataPacket.Data, 4, 1000);
-                upload.Transferred += 1000;
-
-                lock (Transfers)
-                {
-                    Transfers.Remove(upload.AssetID);
-                    Transfers[upload.ID] = upload;
-                }
-            }
-            else if ((send.XferID.Packet + 1) * 1000 < upload.Size)
-            {
-                // This packet is somewhere in the middle of the transfer, or a perfectly
-                // aligned packet at the end of the transfer
-                send.DataPacket.Data = new byte[1000];
-                Buffer.BlockCopy(upload.AssetData, upload.Transferred, send.DataPacket.Data, 0, 1000);
-                upload.Transferred += 1000;
-            }
-            else
-            {
-                // Special handler for the last packet which will be less than 1000 bytes
-                int lastlen = upload.Size - ((int)send.XferID.Packet * 1000);
-                send.DataPacket.Data = new byte[lastlen];
-                Buffer.BlockCopy(upload.AssetData, (int)send.XferID.Packet * 1000, send.DataPacket.Data, 0, lastlen);
-                send.XferID.Packet |= (uint)0x80000000; // This signals the final packet
-                upload.Transferred += lastlen;
-            }
-
-            Client.Network.SendPacket(send);
-        }
-
-        private void SendConfirmXferPacket(ulong xferID, uint packetNum)
-        {
-            ConfirmXferPacketPacket confirm = new ConfirmXferPacketPacket();
-            confirm.XferID.ID = xferID;
-            confirm.XferID.Packet = packetNum;
-
-            Client.Network.SendPacket(confirm);
-        }
-
-        #endregion Helpers
-
-        #region Transfer Callbacks
-
-        private void TransferInfoHandler(Packet packet, Simulator simulator)
-        {
-            if (OnAssetReceived != null)
-            {
-                TransferInfoPacket info = (TransferInfoPacket)packet;
-                Transfer transfer;
-                AssetDownload download;
-
-                if (Transfers.TryGetValue(info.TransferInfo.TransferID, out transfer))
-                {
-                    download = (AssetDownload)transfer;
-
-                    download.Channel = (ChannelType)info.TransferInfo.ChannelType;
-                    download.Status = (StatusCode)info.TransferInfo.Status;
-                    download.Target = (TargetType)info.TransferInfo.TargetType;
-                    download.Size = info.TransferInfo.Size;
-
-                    // TODO: Once we support mid-transfer status checking and aborting this
-                    // will need to become smarter
-                    if (download.Status != StatusCode.OK)
-                    {
-                        Logger.Log("Transfer failed with status code " + download.Status, Helpers.LogLevel.Warning, Client);
-
-                        lock (Transfers) Transfers.Remove(download.ID);
-
-                        // No data could have been received before the TransferInfo packet
-                        download.AssetData = null;
-
-                        // Fire the event with our transfer that contains Success = false;
-                        try { OnAssetReceived(download, null); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                    }
-                    else
-                    {
-                        download.AssetData = new byte[download.Size];
-
-                        if (download.Source == SourceType.Asset && info.TransferInfo.Params.Length == 20)
-                        {
-                            download.AssetID = new UUID(info.TransferInfo.Params, 0);
-                            download.AssetType = (AssetType)(sbyte)info.TransferInfo.Params[16];
-
-                            //Client.DebugLog(String.Format("TransferInfo packet received. AssetID: {0} Type: {1}",
-                            //    transfer.AssetID, type));
-                        }
-                        else if (download.Source == SourceType.SimInventoryItem && info.TransferInfo.Params.Length == 100)
-                        {
-                            // TODO: Can we use these?
-                            //UUID agentID = new UUID(info.TransferInfo.Params, 0);
-                            //UUID sessionID = new UUID(info.TransferInfo.Params, 16);
-                            //UUID ownerID = new UUID(info.TransferInfo.Params, 32);
-                            //UUID taskID = new UUID(info.TransferInfo.Params, 48);
-                            //UUID itemID = new UUID(info.TransferInfo.Params, 64);
-                            download.AssetID = new UUID(info.TransferInfo.Params, 80);
-                            download.AssetType = (AssetType)(sbyte)info.TransferInfo.Params[96];
-
-                            //Client.DebugLog(String.Format("TransferInfo packet received. AgentID: {0} SessionID: {1} " + 
-                            //    "OwnerID: {2} TaskID: {3} ItemID: {4} AssetID: {5} Type: {6}", agentID, sessionID, 
-                            //    ownerID, taskID, itemID, transfer.AssetID, type));
-                        }
-                        else
-                        {
-                            Logger.Log("Received a TransferInfo packet with a SourceType of " + download.Source.ToString() +
-                                " and a Params field length of " + info.TransferInfo.Params.Length,
-                                Helpers.LogLevel.Warning, Client);
-                        }
-                    }
-                }
-                else
-                {
-                    Logger.Log("Received a TransferInfo packet for an asset we didn't request, TransferID: " +
-                        info.TransferInfo.TransferID, Helpers.LogLevel.Warning, Client);
-                }
-            }
-        }
-
-        private void TransferPacketHandler(Packet packet, Simulator simulator)
-        {
-            TransferPacketPacket asset = (TransferPacketPacket)packet;
-            Transfer transfer;
-            AssetDownload download;
-
-            if (Transfers.TryGetValue(asset.TransferData.TransferID, out transfer))
-            {
-                download = (AssetDownload)transfer;
-
-                if (download.Size == 0)
-                {
-                    Logger.DebugLog("TransferPacket received ahead of the transfer header, blocking...", Client);
-
-                    // We haven't received the header yet, block until it's received or times out
-                    download.HeaderReceivedEvent.WaitOne(1000 * 5, false);
-
-                    if (download.Size == 0)
-                    {
-                        Logger.Log("Timed out while waiting for the asset header to download for " +
-                            download.ID.ToString(), Helpers.LogLevel.Warning, Client);
-
-                        // Abort the transfer
-                        TransferAbortPacket abort = new TransferAbortPacket();
-                        abort.TransferInfo.ChannelType = (int)download.Channel;
-                        abort.TransferInfo.TransferID = download.ID;
-                        Client.Network.SendPacket(abort, download.Simulator);
-
-                        download.Success = false;
-                        lock (Transfers) Transfers.Remove(download.ID);
-
-                        // Fire the event with our transfer that contains Success = false
-                        if (OnAssetReceived != null)
-                        {
-                            try { OnAssetReceived(download, null); }
-                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                        }
-
-                        return;
-                    }
-                }
-
-                // This assumes that every transfer packet except the last one is exactly 1000 bytes,
-                // hopefully that is a safe assumption to make
-                try
-                {
-                    Buffer.BlockCopy(asset.TransferData.Data, 0, download.AssetData, 1000 * asset.TransferData.Packet,
-                        asset.TransferData.Data.Length);
-                    download.Transferred += asset.TransferData.Data.Length;
-                }
-                catch (ArgumentException)
-                {
-                    Logger.Log(String.Format("TransferPacket handling failed. TransferData.Data.Length={0}, AssetData.Length={1}, TransferData.Packet={2}",
-                        asset.TransferData.Data.Length, download.AssetData.Length, asset.TransferData.Packet), Helpers.LogLevel.Error);
-                    return;
-                }
-
-                //Client.DebugLog(String.Format("Transfer packet {0}, received {1}/{2}/{3} bytes for asset {4}",
-                //    asset.TransferData.Packet, asset.TransferData.Data.Length, transfer.Transferred, transfer.Size,
-                //    transfer.AssetID.ToString()));
-
-                // Check if we downloaded the full asset
-                if (download.Transferred >= download.Size)
-                {
-                    Logger.DebugLog("Transfer for asset " + download.AssetID.ToString() + " completed", Client);
-
-                    download.Success = true;
-                    lock (Transfers) Transfers.Remove(download.ID);
-
-                    if (OnAssetReceived != null)
-                    {
-                        try { OnAssetReceived(download, WrapAsset(download)); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                    }
-                }
-            }
-        }
-
-        #endregion Transfer Callbacks
-
-        #region Xfer Callbacks
-
-        private void RequestXferHandler(Packet packet, Simulator simulator)
-        {
-            if (PendingUpload == null)
-                Logger.Log("Received a RequestXferPacket for an unknown asset upload", Helpers.LogLevel.Warning, Client);
-            else
-            {
-                AssetUpload upload = PendingUpload;
-                PendingUpload = null;
-                WaitingForUploadConfirm = false;
-                RequestXferPacket request = (RequestXferPacket)packet;
-
-                upload.XferID = request.XferID.ID;
-                upload.Type = (AssetType)request.XferID.VFileType;
-
-                UUID transferID = new UUID(upload.XferID);
-                Transfers[transferID] = upload;
-
-                // Send the first packet containing actual asset data
-                SendNextUploadPacket(upload);
-            }
-        }
-
-        private void ConfirmXferPacketHandler(Packet packet, Simulator simulator)
-        {
-            ConfirmXferPacketPacket confirm = (ConfirmXferPacketPacket)packet;
-
-            // Building a new UUID every time an ACK is received for an upload is a horrible
-            // thing, but this whole Xfer system is horrible
-            UUID transferID = new UUID(confirm.XferID.ID);
-            Transfer transfer;
-            AssetUpload upload = null;
-
-            if (Transfers.TryGetValue(transferID, out transfer))
-            {
-                upload = (AssetUpload)transfer;
-
-                //Client.DebugLog(String.Format("ACK for upload {0} of asset type {1} ({2}/{3})",
-                //    upload.AssetID.ToString(), upload.Type, upload.Transferred, upload.Size));
-
-                if (OnUploadProgress != null)
-                {
-                    try { OnUploadProgress(upload); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-
-                if (upload.Transferred < upload.Size)
-                    SendNextUploadPacket(upload);
-            }
-        }
-
-        private void AssetUploadCompleteHandler(Packet packet, Simulator simulator)
-        {
-            AssetUploadCompletePacket complete = (AssetUploadCompletePacket)packet;
-
-            // If we uploaded an asset in a single packet, RequestXferHandler()
-            // will never be called so we need to set this here as well
-            WaitingForUploadConfirm = false;
-
-            if (OnAssetUploaded != null)
-            {
-                bool found = false;
-                KeyValuePair<UUID, Transfer> foundTransfer = new KeyValuePair<UUID, Transfer>();
-
-                // Xfer system sucks really really bad. Where is the damn XferID?
-                lock (Transfers)
-                {
-                    foreach (KeyValuePair<UUID, Transfer> transfer in Transfers)
-                    {
-                        if (transfer.Value.GetType() == typeof(AssetUpload))
-                        {
-                            AssetUpload upload = (AssetUpload)transfer.Value;
-
-                            if ((upload).AssetID == complete.AssetBlock.UUID)
-                            {
-                                found = true;
-                                foundTransfer = transfer;
-                                upload.Success = complete.AssetBlock.Success;
-                                upload.Type = (AssetType)complete.AssetBlock.Type;
-                                break;
-                            }
-                        }
-                    }
-                }
-
-                if (found)
-                {
-                    lock (Transfers) Transfers.Remove(foundTransfer.Key);
-
-                    try { OnAssetUploaded((AssetUpload)foundTransfer.Value); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-                else
-                {
-                    Logger.Log(String.Format(
-                        "Got an AssetUploadComplete on an unrecognized asset, AssetID: {0}, Type: {1}, Success: {2}",
-                        complete.AssetBlock.UUID, (AssetType)complete.AssetBlock.Type, complete.AssetBlock.Success),
-                        Helpers.LogLevel.Warning);
-                }
-            }
-        }
-
-        private void SendXferPacketHandler(Packet packet, Simulator simulator)
-        {
-            SendXferPacketPacket xfer = (SendXferPacketPacket)packet;
-
-            // Lame ulong to UUID conversion, please go away Xfer system
-            UUID transferID = new UUID(xfer.XferID.ID);
-            Transfer transfer;
-            XferDownload download = null;
-
-            if (Transfers.TryGetValue(transferID, out transfer))
-            {
-                download = (XferDownload)transfer;
-
-                // Apply a mask to get rid of the "end of transfer" bit
-                uint packetNum = xfer.XferID.Packet & 0x0FFFFFFF;
-
-                // Check for out of order packets, possibly indicating a resend
-                if (packetNum != download.PacketNum)
-                {
-                    if (packetNum == download.PacketNum - 1)
-                    {
-                        Logger.DebugLog("Resending Xfer download confirmation for packet " + packetNum, Client);
-                        SendConfirmXferPacket(download.XferID, packetNum);
-                    }
-                    else
-                    {
-                        Logger.Log("Out of order Xfer packet in a download, got " + packetNum + " expecting " + download.PacketNum,
-                            Helpers.LogLevel.Warning, Client);
-                        // Re-confirm the last packet we actually received
-                        SendConfirmXferPacket(download.XferID, download.PacketNum - 1);
-                    }
-
-                    return;
-                }
-
-                if (packetNum == 0)
-                {
-                    // This is the first packet received in the download, the first four bytes are a size integer
-                    // in little endian ordering
-                    byte[] bytes = xfer.DataPacket.Data;
-                    download.Size = (bytes[0] + (bytes[1] << 8) + (bytes[2] << 16) + (bytes[3] << 24));
-                    download.AssetData = new byte[download.Size];
-
-                    Logger.DebugLog("Received first packet in an Xfer download of size " + download.Size);
-
-                    Buffer.BlockCopy(xfer.DataPacket.Data, 4, download.AssetData, 0, xfer.DataPacket.Data.Length - 4);
-                    download.Transferred += xfer.DataPacket.Data.Length - 4;
-                }
-                else
-                {
-                    Buffer.BlockCopy(xfer.DataPacket.Data, 0, download.AssetData, 1000 * (int)packetNum, xfer.DataPacket.Data.Length);
-                    download.Transferred += xfer.DataPacket.Data.Length;
-                }
-
-                // Increment the packet number to the packet we are expecting next
-                download.PacketNum++;
-
-                // Confirm receiving this packet
-                SendConfirmXferPacket(download.XferID, packetNum);
-
-                if ((xfer.XferID.Packet & 0x80000000) != 0)
-                {
-                    // This is the last packet in the transfer
-                    if (!String.IsNullOrEmpty(download.Filename))
-                        Logger.DebugLog("Xfer download for asset " + download.Filename + " completed", Client);
-                    else
-                        Logger.DebugLog("Xfer download for asset " + download.VFileID.ToString() + " completed", Client);
-
-                    download.Success = true;
-                    lock (Transfers) Transfers.Remove(download.ID);
-
-                    if (OnXferReceived != null)
-                    {
-                        try { OnXferReceived(download); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                    }
-                }
-            }
-        }
-
-        #endregion Xfer Callbacks
-
-        #region Image Callbacks
-
-        /// <summary>
-        /// Handles the Image Data packet which includes the ID and Size of the image,
-        /// along with the first block of data for the image. If the image is small enough
-        /// there will be no additional packets
-        /// </summary>
-        private void ImageDataHandler(Packet packet, Simulator simulator)
-        {
-            ImageDataPacket data = (ImageDataPacket)packet;
-            ImageDownload transfer = null;
-
-            Logger.DebugLog(String.Format("ImageData: Size={0}, Packets={1}", data.ImageID.Size, data.ImageID.Packets));
-
-            lock (Transfers)
-            {
-                if (Transfers.ContainsKey(data.ImageID.ID))
-                {
-                    transfer = (ImageDownload)Transfers[data.ImageID.ID];
-
-                    // Don't set header information if we have already
-                    // received it (due to re-request)
-                    if (transfer.Size == 0)
-                    {
-                        //Client.DebugLog("Received first " + data.ImageData.Data.Length + " bytes for image " +
-                        //    data.ImageID.ID.ToString());
-
-                        if (OnImageReceiveProgress != null)
-                        {
-                            try { OnImageReceiveProgress(data.ImageID.ID, 0, data.ImageData.Data.Length, transfer.Size); }
-                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                        }
-
-                        transfer.Codec = (ImageCodec)data.ImageID.Codec;
-                        transfer.PacketCount = data.ImageID.Packets;
-                        transfer.Size = (int)data.ImageID.Size;
-                        transfer.AssetData = new byte[transfer.Size];
-                        transfer.AssetType = AssetType.Texture;
-                        transfer.PacketsSeen = new SortedList<ushort, ushort>();
-                        Buffer.BlockCopy(data.ImageData.Data, 0, transfer.AssetData, 0, data.ImageData.Data.Length);
-                        transfer.InitialDataSize = data.ImageData.Data.Length;
-                        transfer.Transferred += data.ImageData.Data.Length;
-			            
-                        // Check if we downloaded the full image
-                        if (transfer.Transferred >= transfer.Size)
-                        {
-                            Transfers.Remove(transfer.ID);
-                            transfer.Success = true;
-                            Cache.SaveImageToCache(transfer.ID, transfer.AssetData);
-                        }
-                    }
-                }
-            }
-
-            if (transfer != null)
-            {
-                transfer.HeaderReceivedEvent.Set();
-
-                if (OnImageReceived != null && transfer.Transferred >= transfer.Size)
-                {
-                    AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
-
-                    try { OnImageReceived(transfer, asset); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Handles the remaining Image data that did not fit in the initial ImageData packet
-        /// </summary>
-        private void ImagePacketHandler(Packet packet, Simulator simulator)
-        {
-            ImagePacketPacket image = (ImagePacketPacket)packet;
-            ImageDownload transfer = null;
-
-            lock (Transfers)
-            {
-                if (Transfers.ContainsKey(image.ImageID.ID))
-                {
-                    transfer = (ImageDownload)Transfers[image.ImageID.ID];
-
-                    if (transfer.Size == 0)
-                    {
-                        // We haven't received the header yet, block until it's received or times out
-                        transfer.HeaderReceivedEvent.WaitOne(1000 * 5, false);
-
-                        if (transfer.Size == 0)
-                        {
-                            Logger.Log("Timed out while waiting for the image header to download for " +
-                                transfer.ID.ToString(), Helpers.LogLevel.Warning, Client);
-
-                            transfer.Success = false;
-                            Transfers.Remove(transfer.ID);
-                            goto Callback;
-                        }
-                    }
-
-                    // The header is downloaded, we can insert this data in to the proper position
-                    // Only insert if we haven't seen this packet before
-                    lock (transfer.PacketsSeen)
-                    {
-                        if (!transfer.PacketsSeen.ContainsKey(image.ImageID.Packet))
-                        {
-                            transfer.PacketsSeen[image.ImageID.Packet] = image.ImageID.Packet;
-                            Buffer.BlockCopy(image.ImageData.Data, 0, transfer.AssetData,
-                                transfer.InitialDataSize + (1000 * (image.ImageID.Packet - 1)),
-                                image.ImageData.Data.Length);
-                            transfer.Transferred += image.ImageData.Data.Length;
-                        }
-                    }
-
-                    //Client.DebugLog("Received " + image.ImageData.Data.Length + "/" + transfer.Transferred +
-                    //    "/" + transfer.Size + " bytes for image " + image.ImageID.ID.ToString());
-
-                    transfer.TimeSinceLastPacket = 0;
-                    
-                    if (OnImageReceiveProgress != null)
-                    {
-                        try { OnImageReceiveProgress(image.ImageID.ID, image.ImageID.Packet, transfer.Transferred, transfer.Size); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                    }
-
-                    // Check if we downloaded the full image
-                    if (transfer.Transferred >= transfer.Size)
-                    {
-                        Cache.SaveImageToCache(transfer.ID, transfer.AssetData);
-                        transfer.Success = true;
-                        Transfers.Remove(transfer.ID);
-                    }
-                }
-            }
-
-        Callback:
-
-            if (transfer != null && OnImageReceived != null && (transfer.Transferred >= transfer.Size || transfer.Size == 0))
-            {
-                AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
-
-                try { OnImageReceived(transfer, asset); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        /// <summary>
-        /// The requested image does not exist on the asset server
-        /// </summary>
-        private void ImageNotInDatabaseHandler(Packet packet, Simulator simulator)
-        {
-            ImageNotInDatabasePacket notin = (ImageNotInDatabasePacket)packet;
-            ImageDownload transfer = null;
-
-            lock (Transfers)
-            {
-                if (Transfers.ContainsKey(notin.ImageID.ID))
-                {
-                    transfer = (ImageDownload)Transfers[notin.ImageID.ID];
-                    transfer.NotFound = true;
-                    Transfers.Remove(transfer.ID);
-                }
-            }
-
-            // Fire the event with our transfer that contains Success = false;
-            if (transfer != null && OnImageReceived != null)
-            {
-                try { OnImageReceived(transfer, null); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        #endregion Image Callbacks
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Threading;
+using System.IO;
+using OpenMetaverse;
+using OpenMetaverse.Packets;
+
+namespace OpenMetaverse
+{
+    #region Enums
+
+    /// <summary>
+    /// The different types of grid assets
+    /// </summary>
+    public enum AssetType : sbyte
+    {
+        /// <summary>Unknown asset type</summary>
+        Unknown = -1,
+        /// <summary>Texture asset, stores in JPEG2000 J2C stream format</summary>
+        Texture = 0,
+        /// <summary>Sound asset</summary>
+        Sound = 1,
+        /// <summary>Calling card for another avatar</summary>
+        CallingCard = 2,
+        /// <summary>Link to a location in world</summary>
+        Landmark = 3,
+        // <summary>Legacy script asset, you should never see one of these</summary>
+        //[Obsolete]
+        //Script = 4,
+        /// <summary>Collection of textures and parameters that can be 
+        /// worn by an avatar</summary>
+        Clothing = 5,
+        /// <summary>Primitive that can contain textures, sounds, 
+        /// scripts and more</summary>
+        Object = 6,
+        /// <summary>Notecard asset</summary>
+        Notecard = 7,
+        /// <summary>Holds a collection of inventory items</summary>
+        Folder = 8,
+        /// <summary>Root inventory folder</summary>
+        RootFolder = 9,
+        /// <summary>Linden scripting language script</summary>
+        LSLText = 10,
+        /// <summary>LSO bytecode for a script</summary>
+        LSLBytecode = 11,
+        /// <summary>Uncompressed TGA texture</summary>
+        TextureTGA = 12,
+        /// <summary>Collection of textures and shape parameters that can
+        /// be worn</summary>
+        Bodypart = 13,
+        /// <summary>Trash folder</summary>
+        TrashFolder = 14,
+        /// <summary>Snapshot folder</summary>
+        SnapshotFolder = 15,
+        /// <summary>Lost and found folder</summary>
+        LostAndFoundFolder = 16,
+        /// <summary>Uncompressed sound</summary>
+        SoundWAV = 17,
+        /// <summary>Uncompressed TGA non-square image, not to be used as a
+        /// texture</summary>
+        ImageTGA = 18,
+        /// <summary>Compressed JPEG non-square image, not to be used as a
+        /// texture</summary>
+        ImageJPEG = 19,
+        /// <summary>Animation</summary>
+        Animation = 20,
+        /// <summary>Sequence of animations, sounds, chat, and pauses</summary>
+        Gesture = 21,
+        /// <summary>Simstate file</summary>
+        Simstate = 22,
+    }
+
+    public enum EstateAssetType : int
+    {
+        None = -1,
+        Covenant = 0
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public enum StatusCode
+    {
+        /// <summary>OK</summary>
+        OK = 0,
+        /// <summary>Transfer completed</summary>
+        Done = 1,
+        /// <summary></summary>
+        Skip = 2,
+        /// <summary></summary>
+        Abort = 3,
+        /// <summary>Unknown error occurred</summary>
+        Error = -1,
+        /// <summary>Equivalent to a 404 error</summary>
+        UnknownSource = -2,
+        /// <summary>Client does not have permission for that resource</summary>
+        InsufficientPermissiosn = -3,
+        /// <summary>Unknown status</summary>
+        Unknown = -4
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public enum ChannelType : int
+    {
+        /// <summary></summary>
+        Unknown = 0,
+        /// <summary>Unknown</summary>
+        Misc = 1,
+        /// <summary>Virtually all asset transfers use this channel</summary>
+        Asset = 2
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public enum SourceType : int
+    {
+        /// <summary></summary>
+        Unknown = 0,
+        /// <summary>Asset from the asset server</summary>
+        Asset = 2,
+        /// <summary>Inventory item</summary>
+        SimInventoryItem = 3,
+        /// <summary>Estate asset, such as an estate covenant</summary>
+        SimEstate = 4
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public enum TargetType : int
+    {
+        /// <summary></summary>
+        Unknown = 0,
+        /// <summary></summary>
+        File = 1,
+        /// <summary></summary>
+        VFile = 2
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public enum ImageType : byte
+    {
+        /// <summary></summary>
+        Normal = 0,
+        /// <summary></summary>
+        Baked = 1
+    }
+
+    /// <summary>
+    /// Image file format
+    /// </summary>
+    public enum ImageCodec : byte
+    {
+        Invalid = 0,
+        RGB = 1,
+        J2C = 2,
+        BMP = 3,
+        TGA = 4,
+        JPEG = 5,
+        DXT = 6,
+        PNG = 7
+    }
+
+    public enum TransferError : int
+    {
+        None = 0,
+        Failed = -1,
+        AssetNotFound = -3,
+        AssetNotFoundInDatabase = -4,
+        InsufficientPermissions = -5,
+        EOF = -39,
+        CannotOpenFile = -42,
+        FileNotFound = -43,
+        FileIsEmpty = -44,
+        TCPTimeout = -23016,
+        CircuitGone = -23017
+    }
+
+    #endregion Enums
+
+    #region Transfer Classes
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public class Transfer
+    {
+        public UUID ID;
+        public int Size;
+        public byte[] AssetData = new byte[0];
+        public int Transferred;
+        public bool Success;
+        public AssetType AssetType;
+
+        private int transferStart;
+
+        /// <summary>Number of milliseconds passed since the last transfer
+        /// packet was received</summary>
+        public int TimeSinceLastPacket
+        {
+            get { return Environment.TickCount - transferStart; }
+            internal set { transferStart = Environment.TickCount + value; }
+        }
+
+        public Transfer()
+        {
+            AssetData = new byte[0];
+            transferStart = Environment.TickCount;
+        }
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public class AssetDownload : Transfer
+    {
+        public UUID AssetID;
+        public ChannelType Channel;
+        public SourceType Source;
+        public TargetType Target;
+        public StatusCode Status;
+        public float Priority;
+        public Simulator Simulator;
+
+        internal AutoResetEvent HeaderReceivedEvent = new AutoResetEvent(false);
+
+        public AssetDownload()
+            : base()
+        {
+        }
+    }
+
+    public class XferDownload : Transfer
+    {
+        public ulong XferID;
+        public UUID VFileID;
+        public AssetType Type;
+        public uint PacketNum;
+        public string Filename = String.Empty;
+
+        public XferDownload()
+            : base()
+        {
+        }
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public class ImageDownload : Transfer
+    {
+        public ushort PacketCount;
+        public ImageCodec Codec;
+        public bool NotFound;
+        public Simulator Simulator;
+        public SortedList<ushort, ushort> PacketsSeen;
+        public ImageType ImageType;
+        public int DiscardLevel;
+        public float Priority;
+
+        internal int InitialDataSize;
+        internal AutoResetEvent HeaderReceivedEvent = new AutoResetEvent(false);
+
+        public ImageDownload()
+            : base()
+        {
+        }
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public class AssetUpload : Transfer
+    {
+        public UUID AssetID;
+        public AssetType Type;
+        public ulong XferID;
+        public uint PacketNum;
+
+        public AssetUpload()
+            : base()
+        {
+        }
+    }
+
+    public class ImageRequest
+    {
+        public ImageRequest(UUID imageid, ImageType type, float priority, int discardLevel)
+        {
+            ImageID = imageid;
+            Type = type;
+            Priority = priority;
+            DiscardLevel = discardLevel;
+        }
+        public UUID ImageID;
+        public ImageType Type;
+        public float Priority;
+        public int DiscardLevel;
+    }
+    #endregion Transfer Classes
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public class AssetManager
+    {
+        #region Delegates
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="transfer"></param>
+        /// <param name="asset"></param>
+        public delegate void AssetReceivedCallback(AssetDownload transfer, Asset asset);
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="xfer"></param>
+        public delegate void XferReceivedCallback(XferDownload xfer);
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="image"></param>
+        /// <param name="asset"></param>
+        public delegate void ImageReceivedCallback(ImageDownload image, AssetTexture asset);
+        /// <summary>
+        /// 
+        /// </summary>
+        public delegate void ImageReceiveProgressCallback(UUID image, int lastPacket, int recieved, int total);
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="upload"></param>
+        public delegate void AssetUploadedCallback(AssetUpload upload);
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="upload"></param>
+        public delegate void UploadProgressCallback(AssetUpload upload);
+
+        #endregion Delegates
+
+        #region Events
+
+        /// <summary></summary>
+        public event AssetReceivedCallback OnAssetReceived;
+        /// <summary></summary>
+        public event XferReceivedCallback OnXferReceived;
+        /// <summary></summary>
+        public event ImageReceivedCallback OnImageReceived;
+        /// <summary></summary>
+        public event ImageReceiveProgressCallback OnImageReceiveProgress;
+        /// <summary></summary>
+        public event AssetUploadedCallback OnAssetUploaded;
+        /// <summary></summary>
+        public event UploadProgressCallback OnUploadProgress;
+
+        #endregion Events
+
+        /// <summary>Texture download cache</summary>
+        public TextureCache Cache;
+
+        private GridClient Client;
+        private Dictionary<UUID, Transfer> Transfers = new Dictionary<UUID, Transfer>();
+        private AssetUpload PendingUpload;
+        private object PendingUploadLock = new object();
+        private volatile bool WaitingForUploadConfirm = false;
+        private System.Timers.Timer RefreshDownloadsTimer = new System.Timers.Timer(500.0);
+        
+        /// <summary>
+        /// Default constructor
+        /// </summary>
+        /// <param name="client">A reference to the GridClient object</param>
+        public AssetManager(GridClient client)
+        {
+            Client = client;
+            Cache = new TextureCache(client);
+
+            // Transfer packets for downloading large assets
+            Client.Network.RegisterCallback(PacketType.TransferInfo, new NetworkManager.PacketCallback(TransferInfoHandler));
+            Client.Network.RegisterCallback(PacketType.TransferPacket, new NetworkManager.PacketCallback(TransferPacketHandler));
+
+            // Image downloading packets
+            Client.Network.RegisterCallback(PacketType.ImageData, new NetworkManager.PacketCallback(ImageDataHandler));
+            Client.Network.RegisterCallback(PacketType.ImagePacket, new NetworkManager.PacketCallback(ImagePacketHandler));
+            Client.Network.RegisterCallback(PacketType.ImageNotInDatabase, new NetworkManager.PacketCallback(ImageNotInDatabaseHandler));
+
+            // Xfer packets for uploading large assets
+            Client.Network.RegisterCallback(PacketType.RequestXfer, new NetworkManager.PacketCallback(RequestXferHandler));
+            Client.Network.RegisterCallback(PacketType.ConfirmXferPacket, new NetworkManager.PacketCallback(ConfirmXferPacketHandler));
+            Client.Network.RegisterCallback(PacketType.AssetUploadComplete, new NetworkManager.PacketCallback(AssetUploadCompleteHandler));
+
+            // Xfer packet for downloading misc assets
+            Client.Network.RegisterCallback(PacketType.SendXferPacket, new NetworkManager.PacketCallback(SendXferPacketHandler));
+
+            // HACK: Re-request stale pending image downloads
+            RefreshDownloadsTimer.Elapsed += new System.Timers.ElapsedEventHandler(RefreshDownloadsTimer_Elapsed);
+            RefreshDownloadsTimer.Start();
+        }
+
+        private void RefreshDownloadsTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
+        {
+            lock (Transfers)
+            {
+                foreach (Transfer transfer in Transfers.Values)
+                {
+                    if (transfer is ImageDownload)
+                    {
+                        ImageDownload download = (ImageDownload)transfer;
+
+                        uint packet = 0;
+                        
+                        if (download.PacketsSeen != null && download.PacketsSeen.Count > 0)
+                        {
+                            lock (download.PacketsSeen)
+                            {
+                                bool first = true;
+                                foreach (KeyValuePair<ushort, ushort> packetSeen in download.PacketsSeen)
+                                {
+                                    if (first)
+                                    {
+                                        // Initially set this to the earliest packet received in the transfer
+                                        packet = packetSeen.Value;
+                                        first = false;
+                                    }
+                                    else
+                                    {
+                                        ++packet;
+
+                                        // If there is a missing packet in the list, break and request the download
+                                        // resume here
+                                        if (packetSeen.Value != packet)
+                                        {
+                                            --packet;
+                                            break;
+                                        }
+                                    }
+                                }
+
+                                ++packet;
+                            }
+                        }
+
+                        if (download.TimeSinceLastPacket > 5000)
+                        {
+                            --download.DiscardLevel;
+                            download.TimeSinceLastPacket = 0;
+                            RequestImage(download.ID, download.ImageType, download.Priority, download.DiscardLevel, packet);
+                        }
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Request an asset download
+        /// </summary>
+        /// <param name="assetID">Asset UUID</param>
+        /// <param name="type">Asset type, must be correct for the transfer to succeed</param>
+        /// <param name="priority">Whether to give this transfer an elevated priority</param>
+        /// <returns>The transaction ID generated for this transfer</returns>
+        public UUID RequestAsset(UUID assetID, AssetType type, bool priority)
+        {
+            AssetDownload transfer = new AssetDownload();
+            transfer.ID = UUID.Random();
+            transfer.AssetID = assetID;
+            //transfer.AssetType = type; // Set in TransferInfoHandler.
+            transfer.Priority = 100.0f + (priority ? 1.0f : 0.0f);
+            transfer.Channel = ChannelType.Asset;
+            transfer.Source = SourceType.Asset;
+            transfer.Simulator = Client.Network.CurrentSim;
+
+            // Add this transfer to the dictionary
+            lock (Transfers) Transfers[transfer.ID] = transfer;
+
+            // Build the request packet and send it
+            TransferRequestPacket request = new TransferRequestPacket();
+            request.TransferInfo.ChannelType = (int)transfer.Channel;
+            request.TransferInfo.Priority = transfer.Priority;
+            request.TransferInfo.SourceType = (int)transfer.Source;
+            request.TransferInfo.TransferID = transfer.ID;
+
+            byte[] paramField = new byte[20];
+            Buffer.BlockCopy(assetID.GetBytes(), 0, paramField, 0, 16);
+            Buffer.BlockCopy(Utils.IntToBytes((int)type), 0, paramField, 16, 4);
+            request.TransferInfo.Params = paramField;
+
+            Client.Network.SendPacket(request, transfer.Simulator);
+            return transfer.ID;
+        }
+
+        /// <summary>
+        /// Request an asset download through the almost deprecated Xfer system
+        /// </summary>
+        /// <param name="filename">Filename of the asset to request</param>
+        /// <param name="deleteOnCompletion">Whether or not to delete the asset
+        /// off the server after it is retrieved</param>
+        /// <param name="useBigPackets">Use large transfer packets or not</param>
+        /// <param name="vFileID">UUID of the file to request, if filename is
+        /// left empty</param>
+        /// <param name="vFileType">Asset type of <code>vFileID</code>, or
+        /// <code>AssetType.Unknown</code> if filename is not empty</param>
+        /// <param name="fromCache">Sets the FilePath in the request to Cache
+        /// (4) if true, otherwise Unknown (0) is used</param>
+        /// <returns></returns>
+        public ulong RequestAssetXfer(string filename, bool deleteOnCompletion, bool useBigPackets, UUID vFileID, AssetType vFileType,
+            bool fromCache)
+        {
+            UUID uuid = UUID.Random();
+            ulong id = uuid.GetULong();
+
+            XferDownload transfer = new XferDownload();
+            transfer.XferID = id;
+            transfer.ID = new UUID(id); // Our dictionary tracks transfers with UUIDs, so convert the ulong back
+            transfer.Filename = filename;
+            transfer.VFileID = vFileID;
+            transfer.AssetType = vFileType;
+
+            // Add this transfer to the dictionary
+            lock (Transfers) Transfers[transfer.ID] = transfer;
+
+            RequestXferPacket request = new RequestXferPacket();
+            request.XferID.ID = id;
+            request.XferID.Filename = Utils.StringToBytes(filename);
+            request.XferID.FilePath = fromCache ? (byte)4 : (byte)0;
+            request.XferID.DeleteOnCompletion = deleteOnCompletion;
+            request.XferID.UseBigPackets = useBigPackets;
+            request.XferID.VFileID = vFileID;
+            request.XferID.VFileType = (short)vFileType;
+
+            Client.Network.SendPacket(request);
+
+            return id;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="assetID">Use UUID.Zero if you do not have the 
+        /// asset ID but have all the necessary permissions</param>
+        /// <param name="itemID">The item ID of this asset in the inventory</param>
+        /// <param name="taskID">Use UUID.Zero if you are not requesting an 
+        /// asset from an object inventory</param>
+        /// <param name="ownerID">The owner of this asset</param>
+        /// <param name="type">Asset type</param>
+        /// <param name="priority">Whether to prioritize this asset download or not</param>
+        public UUID RequestInventoryAsset(UUID assetID, UUID itemID, UUID taskID, UUID ownerID, AssetType type, bool priority)
+        {
+            AssetDownload transfer = new AssetDownload();
+            transfer.ID = UUID.Random();
+            transfer.AssetID = assetID;
+            //transfer.AssetType = type; // Set in TransferInfoHandler.
+            transfer.Priority = 100.0f + (priority ? 1.0f : 0.0f);
+            transfer.Channel = ChannelType.Asset;
+            transfer.Source = SourceType.SimInventoryItem;
+            transfer.Simulator = Client.Network.CurrentSim;
+
+            // Add this transfer to the dictionary
+            lock (Transfers) Transfers[transfer.ID] = transfer;
+
+            // Build the request packet and send it
+            TransferRequestPacket request = new TransferRequestPacket();
+            request.TransferInfo.ChannelType = (int)transfer.Channel;
+            request.TransferInfo.Priority = transfer.Priority;
+            request.TransferInfo.SourceType = (int)transfer.Source;
+            request.TransferInfo.TransferID = transfer.ID;
+
+            byte[] paramField = new byte[100];
+            Buffer.BlockCopy(Client.Self.AgentID.GetBytes(), 0, paramField, 0, 16);
+            Buffer.BlockCopy(Client.Self.SessionID.GetBytes(), 0, paramField, 16, 16);
+            Buffer.BlockCopy(ownerID.GetBytes(), 0, paramField, 32, 16);
+            Buffer.BlockCopy(taskID.GetBytes(), 0, paramField, 48, 16);
+            Buffer.BlockCopy(itemID.GetBytes(), 0, paramField, 64, 16);
+            Buffer.BlockCopy(assetID.GetBytes(), 0, paramField, 80, 16);
+            Buffer.BlockCopy(Utils.IntToBytes((int)type), 0, paramField, 96, 4);
+            request.TransferInfo.Params = paramField;
+
+            Client.Network.SendPacket(request, transfer.Simulator);
+            return transfer.ID;
+        }
+
+        public UUID RequestInventoryAsset(InventoryItem item, bool priority)
+        {
+            return RequestInventoryAsset(item.AssetUUID, item.UUID, UUID.Zero, item.OwnerID, item.AssetType, priority);
+        }
+
+        public void RequestEstateAsset()
+        {
+            throw new Exception("This function is not implemented yet!");
+        }
+
+        /// <summary>
+        /// Initiate an image download. This is an asynchronous function
+        /// </summary>
+        /// <param name="imageID">The image to download</param>
+        /// <param name="type">Type of the image to download, either a baked
+        /// avatar texture or a normal texture</param>
+        public void RequestImage(UUID imageID, ImageType type)
+        {
+            RequestImage(imageID, type, 1013000.0f, 0, 0);
+        }
+
+        /// <summary>
+        /// Initiate an image download. This is an asynchronous function
+        /// </summary>
+        /// <param name="imageID">The image to download</param>
+        /// <param name="type">Type of the image to download, either a baked
+        /// avatar texture or a normal texture</param>
+        /// <param name="priority">Priority level of the download. Default is
+        /// <c>1,013,000.0f</c></param>
+        /// <param name="discardLevel">Number of quality layers to discard.
+        /// This controls the end marker of the data sent</param>
+        /// <param name="packetNum">Packet number to start the download at.
+        /// This controls the start marker of the data sent</param>
+        /// <remarks>Sending a priority of 0 and a discardlevel of -1 aborts
+        /// download</remarks>
+        public void RequestImage(UUID imageID, ImageType type, float priority, int discardLevel, uint packetNum)
+        {
+            if (Cache.HasImage(imageID))
+            {
+                ImageDownload transfer = Cache.GetCachedImage(imageID);
+                transfer.ImageType = type;
+
+                if (null != transfer)
+                {
+                    if (null != OnImageReceived)
+                    {
+                        AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
+
+                        try { OnImageReceived(transfer, asset); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                    }
+                    return;
+                }
+            }
+
+            // Priority == 0 && DiscardLevel == -1 means cancel the transfer
+            if (priority.Equals(0) && discardLevel.Equals(-1))
+            {
+                if (Transfers.ContainsKey(imageID))
+                    Transfers.Remove(imageID);
+
+                RequestImagePacket cancel = new RequestImagePacket();
+                cancel.AgentData.AgentID = Client.Self.AgentID;
+                cancel.AgentData.SessionID = Client.Self.SessionID;
+                cancel.RequestImage = new RequestImagePacket.RequestImageBlock[1];
+                cancel.RequestImage[0] = new RequestImagePacket.RequestImageBlock();
+                cancel.RequestImage[0].DiscardLevel = -1;
+                cancel.RequestImage[0].DownloadPriority = 0;
+                cancel.RequestImage[0].Packet = 0;
+                cancel.RequestImage[0].Image = imageID;
+                cancel.RequestImage[0].Type = 0;
+            }
+            else
+            {
+                Simulator currentSim = Client.Network.CurrentSim;
+
+                if (!Transfers.ContainsKey(imageID))
+                {
+                    // New download
+                    ImageDownload transfer = new ImageDownload();
+                    transfer.ID = imageID;
+                    transfer.Simulator = currentSim;
+                    transfer.ImageType = type;
+                    transfer.DiscardLevel = discardLevel;
+                    transfer.Priority = priority;
+
+                    // Add this transfer to the dictionary
+                    lock (Transfers) Transfers[transfer.ID] = transfer;
+
+                    Logger.DebugLog("Adding image " + imageID.ToString() + " to the download queue");
+                }
+                else
+                {
+                    // Already downloading, just updating the priority
+                    Transfer transfer = Transfers[imageID];
+                    float percentComplete = ((float)transfer.Transferred / (float)transfer.Size) * 100f;
+                    if (Single.IsNaN(percentComplete))
+                        percentComplete = 0f;
+
+                    Logger.DebugLog(String.Format("Updating priority on image transfer {0}, {1}% complete",
+                        imageID, Math.Round(percentComplete, 2)));
+                }
+
+                // Build and send the request packet
+                RequestImagePacket request = new RequestImagePacket();
+                request.AgentData.AgentID = Client.Self.AgentID;
+                request.AgentData.SessionID = Client.Self.SessionID;
+                request.RequestImage = new RequestImagePacket.RequestImageBlock[1];
+                request.RequestImage[0] = new RequestImagePacket.RequestImageBlock();
+                request.RequestImage[0].DiscardLevel = (sbyte)discardLevel;
+                request.RequestImage[0].DownloadPriority = priority;
+                request.RequestImage[0].Packet = packetNum;
+                request.RequestImage[0].Image = imageID;
+                request.RequestImage[0].Type = (byte)type;
+
+                Client.Network.SendPacket(request, currentSim);
+            }
+        }
+
+        /// <summary>
+        /// Requests multiple Images
+        /// </summary>
+        /// <param name="Images">List of requested images</param>
+        public void RequestImages(List<ImageRequest> Images)
+        {
+            for (int iri = 0; iri < Images.Count; iri++)
+            {
+                if (Transfers.ContainsKey(Images[iri].ImageID))
+                {
+                    Images.RemoveAt(iri);
+                }
+
+                if (Cache.HasImage(Images[iri].ImageID))
+                {
+                    ImageDownload transfer = Cache.GetCachedImage(Images[iri].ImageID);
+                    if (null != transfer)
+                    {
+                        if (null != OnImageReceived)
+                        {
+                            AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
+
+                            try { OnImageReceived(transfer, asset); }
+                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                        }
+
+                        Images.RemoveAt(iri);
+                    }
+                }
+            }
+
+            if (Images.Count > 0)
+            {
+                // Build and send the request packet
+                RequestImagePacket request = new RequestImagePacket();
+                request.AgentData.AgentID = Client.Self.AgentID;
+                request.AgentData.SessionID = Client.Self.SessionID;
+                request.RequestImage = new RequestImagePacket.RequestImageBlock[Images.Count];
+
+                for (int iru = 0; iru < Images.Count; ++iru)
+                {
+                    ImageDownload transfer = new ImageDownload();
+                    //transfer.AssetType = AssetType.Texture // Handled in ImageDataHandler.
+                    transfer.ID = Images[iru].ImageID;
+                    transfer.Simulator = Client.Network.CurrentSim;
+                    transfer.ImageType = Images[iru].Type;
+                    transfer.DiscardLevel = Images[iru].DiscardLevel;
+                    transfer.Priority = Images[iru].Priority;
+
+                    // Add this transfer to the dictionary
+                    lock (Transfers) Transfers[transfer.ID] = transfer;
+                    request.RequestImage[iru] = new RequestImagePacket.RequestImageBlock();
+                    request.RequestImage[iru].DiscardLevel = (sbyte)Images[iru].DiscardLevel;
+                    request.RequestImage[iru].DownloadPriority = Images[iru].Priority;
+                    request.RequestImage[iru].Packet = 0;
+                    request.RequestImage[iru].Image = Images[iru].ImageID;
+                    request.RequestImage[iru].Type = (byte)Images[iru].Type;
+                }
+
+                Client.Network.SendPacket(request, Client.Network.CurrentSim);
+            }
+            else
+            {
+                Logger.Log("RequestImages() called for an image(s) we are already downloading or an empty list, ignoring",
+                    Helpers.LogLevel.Info, Client);
+            }
+        }
+
+        public UUID RequestUpload(Asset asset, bool storeLocal)
+        {
+            if (asset.AssetData == null)
+                throw new ArgumentException("Can't upload an asset with no data (did you forget to call Encode?)");
+
+            UUID assetID;
+            UUID transferID = RequestUpload(out assetID, asset.AssetType, asset.AssetData, storeLocal);
+            asset.AssetID = assetID;
+            return transferID;
+        }
+        
+        public UUID RequestUpload(AssetType type, byte[] data, bool storeLocal)
+        {
+            UUID assetID;
+            return RequestUpload(out assetID, type, data, storeLocal);
+        }
+
+        public UUID RequestUpload(out UUID assetID, AssetType type, byte[] data, bool storeLocal)
+		{
+			return RequestUpload(out assetID, type, data, storeLocal, UUID.Random());
+		}
+		
+        /// <summary>
+        /// Initiate an asset upload
+        /// </summary>
+        /// <param name="assetID">The ID this asset will have if the
+        /// upload succeeds</param>
+        /// <param name="type">Asset type to upload this data as</param>
+        /// <param name="data">Raw asset data to upload</param>
+        /// <param name="storeLocal">Whether to store this asset on the local
+        /// simulator or the grid-wide asset server</param>
+        /// <param name="transactionID">The tranaction id for the upload <see cref="RequestCreateItem"/></param>
+        /// <returns>The transaction ID of this transfer</returns>
+        public UUID RequestUpload(out UUID assetID, AssetType type, byte[] data, bool storeLocal, UUID transactionID)
+        {
+            AssetUpload upload = new AssetUpload();
+            upload.AssetData = data;
+            upload.AssetType = type;
+            assetID = UUID.Combine(transactionID, Client.Self.SecureSessionID);
+            upload.AssetID = assetID;
+            upload.Size = data.Length;
+            upload.XferID = 0;
+			upload.ID = transactionID;
+			
+            // Build and send the upload packet
+            AssetUploadRequestPacket request = new AssetUploadRequestPacket();
+            request.AssetBlock.StoreLocal = storeLocal;
+            request.AssetBlock.Tempfile = false; // This field is deprecated
+            request.AssetBlock.TransactionID = transactionID;
+            request.AssetBlock.Type = (sbyte)type;
+
+            if (data.Length + 100 < Settings.MAX_PACKET_SIZE)
+            {
+                Logger.Log(
+                    String.Format("Beginning asset upload [Single Packet], ID: {0}, AssetID: {1}, Size: {2}",
+                    upload.ID.ToString(), upload.AssetID.ToString(), upload.Size), Helpers.LogLevel.Info, Client);
+
+                    Transfers[upload.ID]=upload;         
+                
+                // The whole asset will fit in this packet, makes things easy
+                request.AssetBlock.AssetData = data;
+                upload.Transferred = data.Length;
+            }
+            else
+            {
+                Logger.Log(
+                    String.Format("Beginning asset upload [Multiple Packets], ID: {0}, AssetID: {1}, Size: {2}",
+                    upload.ID.ToString(), upload.AssetID.ToString(), upload.Size), Helpers.LogLevel.Info, Client);
+
+                // Asset is too big, send in multiple packets
+                request.AssetBlock.AssetData = new byte[0];
+            }
+
+            // Wait for the previous upload to receive a RequestXferPacket
+            lock (PendingUploadLock)
+            {
+                const int UPLOAD_CONFIRM_TIMEOUT = 10000;
+                const int SLEEP_INTERVAL = 50;
+                int t = 0;
+                while (WaitingForUploadConfirm && t < UPLOAD_CONFIRM_TIMEOUT)
+                {
+                    System.Threading.Thread.Sleep(SLEEP_INTERVAL);
+                    t += SLEEP_INTERVAL;
+                }
+
+                if (t < UPLOAD_CONFIRM_TIMEOUT)
+                {
+                    WaitingForUploadConfirm = true;
+                    PendingUpload = upload;
+                    Client.Network.SendPacket(request);
+
+                    return upload.ID;
+                }
+                else
+                {
+                    throw new Exception("Timeout waiting for previous asset upload to begin");
+                }
+            }
+        }
+
+        #region Helpers
+
+        private Asset CreateAssetWrapper(AssetType type)
+        {
+            Asset asset;
+
+            switch (type)
+            {
+                case AssetType.Notecard:
+                    asset = new AssetNotecard();
+                    break;
+                case AssetType.LSLText:
+                    asset = new AssetScriptText();
+                    break;
+                case AssetType.LSLBytecode:
+                    asset = new AssetScriptBinary();
+                    break;
+                case AssetType.Texture:
+                    asset = new AssetTexture();
+                    break;
+                case AssetType.Object:
+                    asset = new AssetPrim();
+                    break;
+                case AssetType.Clothing:
+                    asset = new AssetClothing();
+                    break;
+                case AssetType.Bodypart:
+                    asset = new AssetBodypart();
+                    break;
+                case AssetType.Animation:
+                    asset = new AssetAnimation();
+                    break;
+                case AssetType.Sound:
+                    asset = new AssetSound();
+                    break;
+                default:
+                    Logger.Log("Unimplemented asset type: " + type, Helpers.LogLevel.Error, Client);
+                    return null;
+            }
+
+            return asset;
+        }
+
+        private Asset WrapAsset(AssetDownload download)
+        {
+            Asset asset = CreateAssetWrapper(download.AssetType);
+            if (asset != null)
+            {
+                asset.AssetID = download.AssetID;
+                asset.AssetData = download.AssetData;
+                return asset;
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        private void SendNextUploadPacket(AssetUpload upload)
+        {
+            SendXferPacketPacket send = new SendXferPacketPacket();
+
+            send.XferID.ID = upload.XferID;
+            send.XferID.Packet = upload.PacketNum++;
+
+            if (send.XferID.Packet == 0)
+            {
+                // The first packet reserves the first four bytes of the data for the
+                // total length of the asset and appends 1000 bytes of data after that
+                send.DataPacket.Data = new byte[1004];
+                Buffer.BlockCopy(Utils.IntToBytes(upload.Size), 0, send.DataPacket.Data, 0, 4);
+                Buffer.BlockCopy(upload.AssetData, 0, send.DataPacket.Data, 4, 1000);
+                upload.Transferred += 1000;
+
+                lock (Transfers)
+                {
+                    Transfers.Remove(upload.AssetID);
+                    Transfers[upload.ID] = upload;
+                }
+            }
+            else if ((send.XferID.Packet + 1) * 1000 < upload.Size)
+            {
+                // This packet is somewhere in the middle of the transfer, or a perfectly
+                // aligned packet at the end of the transfer
+                send.DataPacket.Data = new byte[1000];
+                Buffer.BlockCopy(upload.AssetData, upload.Transferred, send.DataPacket.Data, 0, 1000);
+                upload.Transferred += 1000;
+            }
+            else
+            {
+                // Special handler for the last packet which will be less than 1000 bytes
+                int lastlen = upload.Size - ((int)send.XferID.Packet * 1000);
+                send.DataPacket.Data = new byte[lastlen];
+                Buffer.BlockCopy(upload.AssetData, (int)send.XferID.Packet * 1000, send.DataPacket.Data, 0, lastlen);
+                send.XferID.Packet |= (uint)0x80000000; // This signals the final packet
+                upload.Transferred += lastlen;
+            }
+
+            Client.Network.SendPacket(send);
+        }
+
+        private void SendConfirmXferPacket(ulong xferID, uint packetNum)
+        {
+            ConfirmXferPacketPacket confirm = new ConfirmXferPacketPacket();
+            confirm.XferID.ID = xferID;
+            confirm.XferID.Packet = packetNum;
+
+            Client.Network.SendPacket(confirm);
+        }
+
+        #endregion Helpers
+
+        #region Transfer Callbacks
+
+        private void TransferInfoHandler(Packet packet, Simulator simulator)
+        {
+            if (OnAssetReceived != null)
+            {
+                TransferInfoPacket info = (TransferInfoPacket)packet;
+                Transfer transfer;
+                AssetDownload download;
+
+                if (Transfers.TryGetValue(info.TransferInfo.TransferID, out transfer))
+                {
+                    download = (AssetDownload)transfer;
+
+                    download.Channel = (ChannelType)info.TransferInfo.ChannelType;
+                    download.Status = (StatusCode)info.TransferInfo.Status;
+                    download.Target = (TargetType)info.TransferInfo.TargetType;
+                    download.Size = info.TransferInfo.Size;
+
+                    // TODO: Once we support mid-transfer status checking and aborting this
+                    // will need to become smarter
+                    if (download.Status != StatusCode.OK)
+                    {
+                        Logger.Log("Transfer failed with status code " + download.Status, Helpers.LogLevel.Warning, Client);
+
+                        lock (Transfers) Transfers.Remove(download.ID);
+
+                        // No data could have been received before the TransferInfo packet
+                        download.AssetData = null;
+
+                        // Fire the event with our transfer that contains Success = false;
+                        try { OnAssetReceived(download, null); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                    }
+                    else
+                    {
+                        download.AssetData = new byte[download.Size];
+
+                        if (download.Source == SourceType.Asset && info.TransferInfo.Params.Length == 20)
+                        {
+                            download.AssetID = new UUID(info.TransferInfo.Params, 0);
+                            download.AssetType = (AssetType)(sbyte)info.TransferInfo.Params[16];
+
+                            //Client.DebugLog(String.Format("TransferInfo packet received. AssetID: {0} Type: {1}",
+                            //    transfer.AssetID, type));
+                        }
+                        else if (download.Source == SourceType.SimInventoryItem && info.TransferInfo.Params.Length == 100)
+                        {
+                            // TODO: Can we use these?
+                            //UUID agentID = new UUID(info.TransferInfo.Params, 0);
+                            //UUID sessionID = new UUID(info.TransferInfo.Params, 16);
+                            //UUID ownerID = new UUID(info.TransferInfo.Params, 32);
+                            //UUID taskID = new UUID(info.TransferInfo.Params, 48);
+                            //UUID itemID = new UUID(info.TransferInfo.Params, 64);
+                            download.AssetID = new UUID(info.TransferInfo.Params, 80);
+                            download.AssetType = (AssetType)(sbyte)info.TransferInfo.Params[96];
+
+                            //Client.DebugLog(String.Format("TransferInfo packet received. AgentID: {0} SessionID: {1} " + 
+                            //    "OwnerID: {2} TaskID: {3} ItemID: {4} AssetID: {5} Type: {6}", agentID, sessionID, 
+                            //    ownerID, taskID, itemID, transfer.AssetID, type));
+                        }
+                        else
+                        {
+                            Logger.Log("Received a TransferInfo packet with a SourceType of " + download.Source.ToString() +
+                                " and a Params field length of " + info.TransferInfo.Params.Length,
+                                Helpers.LogLevel.Warning, Client);
+                        }
+                    }
+                }
+                else
+                {
+                    Logger.Log("Received a TransferInfo packet for an asset we didn't request, TransferID: " +
+                        info.TransferInfo.TransferID, Helpers.LogLevel.Warning, Client);
+                }
+            }
+        }
+
+        private void TransferPacketHandler(Packet packet, Simulator simulator)
+        {
+            TransferPacketPacket asset = (TransferPacketPacket)packet;
+            Transfer transfer;
+            AssetDownload download;
+
+            if (Transfers.TryGetValue(asset.TransferData.TransferID, out transfer))
+            {
+                download = (AssetDownload)transfer;
+
+                if (download.Size == 0)
+                {
+                    Logger.DebugLog("TransferPacket received ahead of the transfer header, blocking...", Client);
+
+                    // We haven't received the header yet, block until it's received or times out
+                    download.HeaderReceivedEvent.WaitOne(1000 * 5, false);
+
+                    if (download.Size == 0)
+                    {
+                        Logger.Log("Timed out while waiting for the asset header to download for " +
+                            download.ID.ToString(), Helpers.LogLevel.Warning, Client);
+
+                        // Abort the transfer
+                        TransferAbortPacket abort = new TransferAbortPacket();
+                        abort.TransferInfo.ChannelType = (int)download.Channel;
+                        abort.TransferInfo.TransferID = download.ID;
+                        Client.Network.SendPacket(abort, download.Simulator);
+
+                        download.Success = false;
+                        lock (Transfers) Transfers.Remove(download.ID);
+
+                        // Fire the event with our transfer that contains Success = false
+                        if (OnAssetReceived != null)
+                        {
+                            try { OnAssetReceived(download, null); }
+                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                        }
+
+                        return;
+                    }
+                }
+
+                // This assumes that every transfer packet except the last one is exactly 1000 bytes,
+                // hopefully that is a safe assumption to make
+                try
+                {
+                    Buffer.BlockCopy(asset.TransferData.Data, 0, download.AssetData, 1000 * asset.TransferData.Packet,
+                        asset.TransferData.Data.Length);
+                    download.Transferred += asset.TransferData.Data.Length;
+                }
+                catch (ArgumentException)
+                {
+                    Logger.Log(String.Format("TransferPacket handling failed. TransferData.Data.Length={0}, AssetData.Length={1}, TransferData.Packet={2}",
+                        asset.TransferData.Data.Length, download.AssetData.Length, asset.TransferData.Packet), Helpers.LogLevel.Error);
+                    return;
+                }
+
+                //Client.DebugLog(String.Format("Transfer packet {0}, received {1}/{2}/{3} bytes for asset {4}",
+                //    asset.TransferData.Packet, asset.TransferData.Data.Length, transfer.Transferred, transfer.Size,
+                //    transfer.AssetID.ToString()));
+
+                // Check if we downloaded the full asset
+                if (download.Transferred >= download.Size)
+                {
+                    Logger.DebugLog("Transfer for asset " + download.AssetID.ToString() + " completed", Client);
+
+                    download.Success = true;
+                    lock (Transfers) Transfers.Remove(download.ID);
+
+                    if (OnAssetReceived != null)
+                    {
+                        try { OnAssetReceived(download, WrapAsset(download)); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                    }
+                }
+            }
+        }
+
+        #endregion Transfer Callbacks
+
+        #region Xfer Callbacks
+
+        private void RequestXferHandler(Packet packet, Simulator simulator)
+        {
+            if (PendingUpload == null)
+                Logger.Log("Received a RequestXferPacket for an unknown asset upload", Helpers.LogLevel.Warning, Client);
+            else
+            {
+                AssetUpload upload = PendingUpload;
+                PendingUpload = null;
+                WaitingForUploadConfirm = false;
+                RequestXferPacket request = (RequestXferPacket)packet;
+
+                upload.XferID = request.XferID.ID;
+                upload.Type = (AssetType)request.XferID.VFileType;
+
+                UUID transferID = new UUID(upload.XferID);
+                Transfers[transferID] = upload;
+
+                // Send the first packet containing actual asset data
+                SendNextUploadPacket(upload);
+            }
+        }
+
+        private void ConfirmXferPacketHandler(Packet packet, Simulator simulator)
+        {
+            ConfirmXferPacketPacket confirm = (ConfirmXferPacketPacket)packet;
+
+            // Building a new UUID every time an ACK is received for an upload is a horrible
+            // thing, but this whole Xfer system is horrible
+            UUID transferID = new UUID(confirm.XferID.ID);
+            Transfer transfer;
+            AssetUpload upload = null;
+
+            if (Transfers.TryGetValue(transferID, out transfer))
+            {
+                upload = (AssetUpload)transfer;
+
+                //Client.DebugLog(String.Format("ACK for upload {0} of asset type {1} ({2}/{3})",
+                //    upload.AssetID.ToString(), upload.Type, upload.Transferred, upload.Size));
+
+                if (OnUploadProgress != null)
+                {
+                    try { OnUploadProgress(upload); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+
+                if (upload.Transferred < upload.Size)
+                    SendNextUploadPacket(upload);
+            }
+        }
+
+        private void AssetUploadCompleteHandler(Packet packet, Simulator simulator)
+        {
+            AssetUploadCompletePacket complete = (AssetUploadCompletePacket)packet;
+
+            // If we uploaded an asset in a single packet, RequestXferHandler()
+            // will never be called so we need to set this here as well
+            WaitingForUploadConfirm = false;
+
+            if (OnAssetUploaded != null)
+            {
+                bool found = false;
+                KeyValuePair<UUID, Transfer> foundTransfer = new KeyValuePair<UUID, Transfer>();
+
+                // Xfer system sucks really really bad. Where is the damn XferID?
+                lock (Transfers)
+                {
+                    foreach (KeyValuePair<UUID, Transfer> transfer in Transfers)
+                    {
+                        if (transfer.Value.GetType() == typeof(AssetUpload))
+                        {
+                            AssetUpload upload = (AssetUpload)transfer.Value;
+
+                            if ((upload).AssetID == complete.AssetBlock.UUID)
+                            {
+                                found = true;
+                                foundTransfer = transfer;
+                                upload.Success = complete.AssetBlock.Success;
+                                upload.Type = (AssetType)complete.AssetBlock.Type;
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                if (found)
+                {
+                    lock (Transfers) Transfers.Remove(foundTransfer.Key);
+
+                    try { OnAssetUploaded((AssetUpload)foundTransfer.Value); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+                else
+                {
+                    Logger.Log(String.Format(
+                        "Got an AssetUploadComplete on an unrecognized asset, AssetID: {0}, Type: {1}, Success: {2}",
+                        complete.AssetBlock.UUID, (AssetType)complete.AssetBlock.Type, complete.AssetBlock.Success),
+                        Helpers.LogLevel.Warning);
+                }
+            }
+        }
+
+        private void SendXferPacketHandler(Packet packet, Simulator simulator)
+        {
+            SendXferPacketPacket xfer = (SendXferPacketPacket)packet;
+
+            // Lame ulong to UUID conversion, please go away Xfer system
+            UUID transferID = new UUID(xfer.XferID.ID);
+            Transfer transfer;
+            XferDownload download = null;
+
+            if (Transfers.TryGetValue(transferID, out transfer))
+            {
+                download = (XferDownload)transfer;
+
+                // Apply a mask to get rid of the "end of transfer" bit
+                uint packetNum = xfer.XferID.Packet & 0x0FFFFFFF;
+
+                // Check for out of order packets, possibly indicating a resend
+                if (packetNum != download.PacketNum)
+                {
+                    if (packetNum == download.PacketNum - 1)
+                    {
+                        Logger.DebugLog("Resending Xfer download confirmation for packet " + packetNum, Client);
+                        SendConfirmXferPacket(download.XferID, packetNum);
+                    }
+                    else
+                    {
+                        Logger.Log("Out of order Xfer packet in a download, got " + packetNum + " expecting " + download.PacketNum,
+                            Helpers.LogLevel.Warning, Client);
+                        // Re-confirm the last packet we actually received
+                        SendConfirmXferPacket(download.XferID, download.PacketNum - 1);
+                    }
+
+                    return;
+                }
+
+                if (packetNum == 0)
+                {
+                    // This is the first packet received in the download, the first four bytes are a size integer
+                    // in little endian ordering
+                    byte[] bytes = xfer.DataPacket.Data;
+                    download.Size = (bytes[0] + (bytes[1] << 8) + (bytes[2] << 16) + (bytes[3] << 24));
+                    download.AssetData = new byte[download.Size];
+
+                    Logger.DebugLog("Received first packet in an Xfer download of size " + download.Size);
+
+                    Buffer.BlockCopy(xfer.DataPacket.Data, 4, download.AssetData, 0, xfer.DataPacket.Data.Length - 4);
+                    download.Transferred += xfer.DataPacket.Data.Length - 4;
+                }
+                else
+                {
+                    Buffer.BlockCopy(xfer.DataPacket.Data, 0, download.AssetData, 1000 * (int)packetNum, xfer.DataPacket.Data.Length);
+                    download.Transferred += xfer.DataPacket.Data.Length;
+                }
+
+                // Increment the packet number to the packet we are expecting next
+                download.PacketNum++;
+
+                // Confirm receiving this packet
+                SendConfirmXferPacket(download.XferID, packetNum);
+
+                if ((xfer.XferID.Packet & 0x80000000) != 0)
+                {
+                    // This is the last packet in the transfer
+                    if (!String.IsNullOrEmpty(download.Filename))
+                        Logger.DebugLog("Xfer download for asset " + download.Filename + " completed", Client);
+                    else
+                        Logger.DebugLog("Xfer download for asset " + download.VFileID.ToString() + " completed", Client);
+
+                    download.Success = true;
+                    lock (Transfers) Transfers.Remove(download.ID);
+
+                    if (OnXferReceived != null)
+                    {
+                        try { OnXferReceived(download); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                    }
+                }
+            }
+        }
+
+        #endregion Xfer Callbacks
+
+        #region Image Callbacks
+
+        /// <summary>
+        /// Handles the Image Data packet which includes the ID and Size of the image,
+        /// along with the first block of data for the image. If the image is small enough
+        /// there will be no additional packets
+        /// </summary>
+        private void ImageDataHandler(Packet packet, Simulator simulator)
+        {
+            ImageDataPacket data = (ImageDataPacket)packet;
+            ImageDownload transfer = null;
+
+            Logger.DebugLog(String.Format("ImageData: Size={0}, Packets={1}", data.ImageID.Size, data.ImageID.Packets));
+
+            lock (Transfers)
+            {
+                if (Transfers.ContainsKey(data.ImageID.ID))
+                {
+                    transfer = (ImageDownload)Transfers[data.ImageID.ID];
+
+                    // Don't set header information if we have already
+                    // received it (due to re-request)
+                    if (transfer.Size == 0)
+                    {
+                        //Client.DebugLog("Received first " + data.ImageData.Data.Length + " bytes for image " +
+                        //    data.ImageID.ID.ToString());
+
+                        if (OnImageReceiveProgress != null)
+                        {
+                            try { OnImageReceiveProgress(data.ImageID.ID, 0, data.ImageData.Data.Length, transfer.Size); }
+                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                        }
+
+                        transfer.Codec = (ImageCodec)data.ImageID.Codec;
+                        transfer.PacketCount = data.ImageID.Packets;
+                        transfer.Size = (int)data.ImageID.Size;
+                        transfer.AssetData = new byte[transfer.Size];
+                        transfer.AssetType = AssetType.Texture;
+                        transfer.PacketsSeen = new SortedList<ushort, ushort>();
+                        Buffer.BlockCopy(data.ImageData.Data, 0, transfer.AssetData, 0, data.ImageData.Data.Length);
+                        transfer.InitialDataSize = data.ImageData.Data.Length;
+                        transfer.Transferred += data.ImageData.Data.Length;
+			            
+                        // Check if we downloaded the full image
+                        if (transfer.Transferred >= transfer.Size)
+                        {
+                            Transfers.Remove(transfer.ID);
+                            transfer.Success = true;
+                            Cache.SaveImageToCache(transfer.ID, transfer.AssetData);
+                        }
+                    }
+                }
+            }
+
+            if (transfer != null)
+            {
+                transfer.HeaderReceivedEvent.Set();
+
+                if (OnImageReceived != null && transfer.Transferred >= transfer.Size)
+                {
+                    AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
+
+                    try { OnImageReceived(transfer, asset); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Handles the remaining Image data that did not fit in the initial ImageData packet
+        /// </summary>
+        private void ImagePacketHandler(Packet packet, Simulator simulator)
+        {
+            ImagePacketPacket image = (ImagePacketPacket)packet;
+            ImageDownload transfer = null;
+
+            lock (Transfers)
+            {
+                if (Transfers.ContainsKey(image.ImageID.ID))
+                {
+                    transfer = (ImageDownload)Transfers[image.ImageID.ID];
+
+                    if (transfer.Size == 0)
+                    {
+                        // We haven't received the header yet, block until it's received or times out
+                        transfer.HeaderReceivedEvent.WaitOne(1000 * 5, false);
+
+                        if (transfer.Size == 0)
+                        {
+                            Logger.Log("Timed out while waiting for the image header to download for " +
+                                transfer.ID.ToString(), Helpers.LogLevel.Warning, Client);
+
+                            transfer.Success = false;
+                            Transfers.Remove(transfer.ID);
+                            goto Callback;
+                        }
+                    }
+
+                    // The header is downloaded, we can insert this data in to the proper position
+                    // Only insert if we haven't seen this packet before
+                    lock (transfer.PacketsSeen)
+                    {
+                        if (!transfer.PacketsSeen.ContainsKey(image.ImageID.Packet))
+                        {
+                            transfer.PacketsSeen[image.ImageID.Packet] = image.ImageID.Packet;
+                            Buffer.BlockCopy(image.ImageData.Data, 0, transfer.AssetData,
+                                transfer.InitialDataSize + (1000 * (image.ImageID.Packet - 1)),
+                                image.ImageData.Data.Length);
+                            transfer.Transferred += image.ImageData.Data.Length;
+                        }
+                    }
+
+                    //Client.DebugLog("Received " + image.ImageData.Data.Length + "/" + transfer.Transferred +
+                    //    "/" + transfer.Size + " bytes for image " + image.ImageID.ID.ToString());
+
+                    transfer.TimeSinceLastPacket = 0;
+                    
+                    if (OnImageReceiveProgress != null)
+                    {
+                        try { OnImageReceiveProgress(image.ImageID.ID, image.ImageID.Packet, transfer.Transferred, transfer.Size); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                    }
+
+                    // Check if we downloaded the full image
+                    if (transfer.Transferred >= transfer.Size)
+                    {
+                        Cache.SaveImageToCache(transfer.ID, transfer.AssetData);
+                        transfer.Success = true;
+                        Transfers.Remove(transfer.ID);
+                    }
+                }
+            }
+
+        Callback:
+
+            if (transfer != null && OnImageReceived != null && (transfer.Transferred >= transfer.Size || transfer.Size == 0))
+            {
+                AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
+
+                try { OnImageReceived(transfer, asset); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        /// <summary>
+        /// The requested image does not exist on the asset server
+        /// </summary>
+        private void ImageNotInDatabaseHandler(Packet packet, Simulator simulator)
+        {
+            ImageNotInDatabasePacket notin = (ImageNotInDatabasePacket)packet;
+            ImageDownload transfer = null;
+
+            lock (Transfers)
+            {
+                if (Transfers.ContainsKey(notin.ImageID.ID))
+                {
+                    transfer = (ImageDownload)Transfers[notin.ImageID.ID];
+                    transfer.NotFound = true;
+                    Transfers.Remove(transfer.ID);
+                }
+            }
+
+            // Fire the event with our transfer that contains Success = false;
+            if (transfer != null && OnImageReceived != null)
+            {
+                try { OnImageReceived(transfer, null); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        #endregion Image Callbacks
+    }
+}
Index: Simulator.cs
===================================================================
--- Simulator.cs	(revision 2445)
+++ Simulator.cs	(working copy)
@@ -866,8 +866,8 @@
             // Check if this packet came from the server we expected it to come from
             if (!remoteEndPoint.Address.Equals(((IPEndPoint)buffer.RemoteEndPoint).Address))
             {
-                Logger.Log("Received " + buffer.DataLength + " bytes of data from unrecognized source " +
-                    ((IPEndPoint)buffer.RemoteEndPoint).ToString(), Helpers.LogLevel.Warning, Client);
+               // Logger.Log("Received " + buffer.DataLength + " bytes of data from unrecognized source " +
+                //    ((IPEndPoint)buffer.RemoteEndPoint).ToString(), Helpers.LogLevel.Warning, Client);
                 return;
             }
 
Index: CapsToPacket.cs
===================================================================
--- CapsToPacket.cs	(revision 2445)
+++ CapsToPacket.cs	(working copy)
@@ -1,285 +1,285 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Reflection;
-using OpenMetaverse.StructuredData;
-
-namespace OpenMetaverse.Packets
-{
-    public abstract partial class Packet
-    {
-        #region Serialization/Deserialization
-
-        public static string ToXmlString(Packet packet)
-        {
-            return OSDParser.SerializeLLSDXmlString(GetLLSD(packet));
-        }
-
-        public static OSD GetLLSD(Packet packet)
-        {
-            OSDMap body = new OSDMap();
-            Type type = packet.GetType();
-
-            foreach (FieldInfo field in type.GetFields())
-            {
-                if (field.IsPublic)
-                {
-                    Type blockType = field.FieldType;
-
-                    if (blockType.IsArray)
-                    {
-                        object blockArray = field.GetValue(packet);
-                        Array array = (Array)blockArray;
-                        OSDArray blockList = new OSDArray(array.Length);
-                        IEnumerator ie = array.GetEnumerator();
-
-                        while (ie.MoveNext())
-                        {
-                            object block = ie.Current;
-                            blockList.Add(BuildLLSDBlock(block));
-                        }
-
-                        body[field.Name] = blockList;
-                    }
-                    else
-                    {
-                        object block = field.GetValue(packet);
-                        body[field.Name] = BuildLLSDBlock(block);
-                    }
-                }
-            }
-
-            return body;
-        }
-
-        public static byte[] ToBinary(Packet packet)
-        {
-            return OSDParser.SerializeLLSDBinary(GetLLSD(packet));
-        }
-
-        public static Packet FromXmlString(string xml)
-        {
-            System.Xml.XmlTextReader reader =
-                new System.Xml.XmlTextReader(new System.IO.MemoryStream(Utils.StringToBytes(xml)));
-
-            return FromLLSD(OSDParser.DeserializeLLSDXml(reader));
-        }
-
-        public static Packet FromLLSD(OSD osd)
-        {
-            // FIXME: Need the inverse of the reflection magic above done here
-            throw new NotImplementedException();
-        }
-
-        #endregion Serialization/Deserialization
-
-        /// <summary>
-        /// Attempts to convert an LLSD structure to a known Packet type
-        /// </summary>
-        /// <param name="capsEventName">Event name, this must match an actual
-        /// packet name for a Packet to be successfully built</param>
-        /// <param name="body">LLSD to convert to a Packet</param>
-        /// <returns>A Packet on success, otherwise null</returns>
-        public static Packet BuildPacket(string capsEventName, OSDMap body)
-        {
-            Assembly assembly = Assembly.GetExecutingAssembly();
-
-            // Check if we have a subclass of packet with the same name as this event
-            Type type = assembly.GetType("OpenMetaverse.Packets." + capsEventName + "Packet", false);
-            if (type == null)
-                return null;
-
-            Packet packet = null;
-
-            try
-            {
-                // Create an instance of the object
-                packet = (Packet)Activator.CreateInstance(type);
-
-                // Iterate over all of the fields in the packet class, looking for matches in the LLSD
-                foreach (FieldInfo field in type.GetFields())
-                {
-                    if (body.ContainsKey(field.Name))
-                    {
-                        Type blockType = field.FieldType;
-
-                        if (blockType.IsArray)
-                        {
-                            OSDArray array = (OSDArray)body[field.Name];
-                            Type elementType = blockType.GetElementType();
-                            object[] blockArray = (object[])Array.CreateInstance(elementType, array.Count);
-
-                            for (int i = 0; i < array.Count; i++)
-                            {
-                                OSDMap map = (OSDMap)array[i];
-                                blockArray[i] = ParseLLSDBlock(map, elementType);
-                            }
-
-                            field.SetValue(packet, blockArray);
-                        }
-                        else
-                        {
-                            OSDMap map = (OSDMap)((OSDArray)body[field.Name])[0];
-                            field.SetValue(packet, ParseLLSDBlock(map, blockType));
-                        }
-                    }
-                }
-            }
-            catch (Exception e)
-            {
-                Logger.Log(e.Message, Helpers.LogLevel.Error, e);
-            }
-
-            return packet;
-        }
-
-        private static object ParseLLSDBlock(OSDMap blockData, Type blockType)
-        {
-            object block = Activator.CreateInstance(blockType);
-
-            // Iterate over each field and set the value if a match was found in the LLSD
-            foreach (FieldInfo field in blockType.GetFields())
-            {
-                if (blockData.ContainsKey(field.Name))
-                {
-                    Type fieldType = field.FieldType;
-
-                    if (fieldType == typeof(ulong))
-                    {
-                        // ulongs come in as a byte array, convert it manually here
-                        byte[] bytes = blockData[field.Name].AsBinary();
-                        ulong value = Utils.BytesToUInt64(bytes);
-                        field.SetValue(block, value);
-                    }
-                    else if (fieldType == typeof(uint))
-                    {
-                        // uints come in as a byte array, convert it manually here
-                        byte[] bytes = blockData[field.Name].AsBinary();
-                        uint value = Utils.BytesToUInt(bytes);
-                        field.SetValue(block, value);
-                    }
-                    else if (fieldType == typeof(ushort))
-                    {
-                        // Just need a bit of manual typecasting love here
-                        field.SetValue(block, (ushort)blockData[field.Name].AsInteger());
-                    }
-                    else if (fieldType == typeof(byte))
-                    {
-                        // Just need a bit of manual typecasting love here
-                        field.SetValue(block, (byte)blockData[field.Name].AsInteger());
-                    }
-                    else if (fieldType == typeof(short))
-                    {
-                        field.SetValue(block, (short)blockData[field.Name].AsInteger());
-                    }
-                    else if (fieldType == typeof(string))
-                    {
-                        field.SetValue(block, blockData[field.Name].AsString());
-                    }
-                    else if (fieldType == typeof(bool))
-                    {
-                        field.SetValue(block, blockData[field.Name].AsBoolean());
-                    }
-                    else if (fieldType == typeof(float))
-                    {
-                        field.SetValue(block, (float)blockData[field.Name].AsReal());
-                    }
-                    else if (fieldType == typeof(double))
-                    {
-                        field.SetValue(block, blockData[field.Name].AsReal());
-                    }
-                    else if (fieldType == typeof(int))
-                    {
-                        field.SetValue(block, blockData[field.Name].AsInteger());
-                    }
-                    else if (fieldType == typeof(UUID))
-                    {
-                        field.SetValue(block, blockData[field.Name].AsUUID());
-                    }
-                    else if (fieldType == typeof(Vector3))
-                    {
-                        Vector3 vec = ((OSDArray)blockData[field.Name]).AsVector3();
-                        field.SetValue(block, vec);
-                    }
-                    else if (fieldType == typeof(Vector4))
-                    {
-                        Vector4 vec = ((OSDArray)blockData[field.Name]).AsVector4();
-                        field.SetValue(block, vec);
-                    }
-                    else if (fieldType == typeof(Quaternion))
-                    {
-                        Quaternion quat = ((OSDArray)blockData[field.Name]).AsQuaternion();
-                        field.SetValue(block, quat);
-                    }
-                }
-            }
-
-            // Additional fields come as properties, Handle those as well.
-            foreach (PropertyInfo property in blockType.GetProperties())
-            {
-                if (blockData.ContainsKey(property.Name))
-                {
-                    OSDType proptype = blockData[property.Name].Type;
-                    MethodInfo set = property.GetSetMethod();
-
-                    if (proptype.Equals(OSDType.Binary))
-                    {
-                        set.Invoke(block, new object[] { blockData[property.Name].AsBinary() });
-                    }
-                    else
-                        set.Invoke(block, new object[] { Utils.StringToBytes(blockData[property.Name].AsString()) });
-                }
-            }
-
-            return block;
-        }
-
-        private static OSD BuildLLSDBlock(object block)
-        {
-            OSDMap map = new OSDMap();
-            Type blockType = block.GetType();
-
-            foreach (FieldInfo field in blockType.GetFields())
-            {
-                if (field.IsPublic)
-                    map[field.Name] = OSD.FromObject(field.GetValue(block));
-            }
-
-            foreach (PropertyInfo property in blockType.GetProperties())
-            {
-                if (property.Name != "Length")
-                {
-                    map[property.Name] = OSD.FromObject(property.GetValue(block, null));
-                }
-            }
-
-            return map;
-        }
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Reflection;
+using OpenMetaverse.StructuredData;
+
+namespace OpenMetaverse.Packets
+{
+    public abstract partial class Packet
+    {
+        #region Serialization/Deserialization
+
+        public static string ToXmlString(Packet packet)
+        {
+            return OSDParser.SerializeLLSDXmlString(GetLLSD(packet));
+        }
+
+        public static OSD GetLLSD(Packet packet)
+        {
+            OSDMap body = new OSDMap();
+            Type type = packet.GetType();
+
+            foreach (FieldInfo field in type.GetFields())
+            {
+                if (field.IsPublic)
+                {
+                    Type blockType = field.FieldType;
+
+                    if (blockType.IsArray)
+                    {
+                        object blockArray = field.GetValue(packet);
+                        Array array = (Array)blockArray;
+                        OSDArray blockList = new OSDArray(array.Length);
+                        IEnumerator ie = array.GetEnumerator();
+
+                        while (ie.MoveNext())
+                        {
+                            object block = ie.Current;
+                            blockList.Add(BuildLLSDBlock(block));
+                        }
+
+                        body[field.Name] = blockList;
+                    }
+                    else
+                    {
+                        object block = field.GetValue(packet);
+                        body[field.Name] = BuildLLSDBlock(block);
+                    }
+                }
+            }
+
+            return body;
+        }
+
+        public static byte[] ToBinary(Packet packet)
+        {
+            return OSDParser.SerializeLLSDBinary(GetLLSD(packet));
+        }
+
+        public static Packet FromXmlString(string xml)
+        {
+            System.Xml.XmlTextReader reader =
+                new System.Xml.XmlTextReader(new System.IO.MemoryStream(Utils.StringToBytes(xml)));
+
+            return FromLLSD(OSDParser.DeserializeLLSDXml(reader));
+        }
+
+        public static Packet FromLLSD(OSD osd)
+        {
+            // FIXME: Need the inverse of the reflection magic above done here
+            throw new NotImplementedException();
+        }
+
+        #endregion Serialization/Deserialization
+
+        /// <summary>
+        /// Attempts to convert an LLSD structure to a known Packet type
+        /// </summary>
+        /// <param name="capsEventName">Event name, this must match an actual
+        /// packet name for a Packet to be successfully built</param>
+        /// <param name="body">LLSD to convert to a Packet</param>
+        /// <returns>A Packet on success, otherwise null</returns>
+        public static Packet BuildPacket(string capsEventName, OSDMap body)
+        {
+            Assembly assembly = Assembly.GetExecutingAssembly();
+
+            // Check if we have a subclass of packet with the same name as this event
+            Type type = assembly.GetType("OpenMetaverse.Packets." + capsEventName + "Packet", false);
+            if (type == null)
+                return null;
+
+            Packet packet = null;
+
+            try
+            {
+                // Create an instance of the object
+                packet = (Packet)Activator.CreateInstance(type);
+
+                // Iterate over all of the fields in the packet class, looking for matches in the LLSD
+                foreach (FieldInfo field in type.GetFields())
+                {
+                    if (body.ContainsKey(field.Name))
+                    {
+                        Type blockType = field.FieldType;
+
+                        if (blockType.IsArray)
+                        {
+                            OSDArray array = (OSDArray)body[field.Name];
+                            Type elementType = blockType.GetElementType();
+                            object[] blockArray = (object[])Array.CreateInstance(elementType, array.Count);
+
+                            for (int i = 0; i < array.Count; i++)
+                            {
+                                OSDMap map = (OSDMap)array[i];
+                                blockArray[i] = ParseLLSDBlock(map, elementType);
+                            }
+
+                            field.SetValue(packet, blockArray);
+                        }
+                        else
+                        {
+                            OSDMap map = (OSDMap)((OSDArray)body[field.Name])[0];
+                            field.SetValue(packet, ParseLLSDBlock(map, blockType));
+                        }
+                    }
+                }
+            }
+            catch (Exception e)
+            {
+                Logger.Log(e.Message, Helpers.LogLevel.Error, e);
+            }
+
+            return packet;
+        }
+
+        private static object ParseLLSDBlock(OSDMap blockData, Type blockType)
+        {
+            object block = Activator.CreateInstance(blockType);
+
+            // Iterate over each field and set the value if a match was found in the LLSD
+            foreach (FieldInfo field in blockType.GetFields())
+            {
+                if (blockData.ContainsKey(field.Name))
+                {
+                    Type fieldType = field.FieldType;
+
+                    if (fieldType == typeof(ulong))
+                    {
+                        // ulongs come in as a byte array, convert it manually here
+                        byte[] bytes = blockData[field.Name].AsBinary();
+                        ulong value = Utils.BytesToUInt64(bytes);
+                        field.SetValue(block, value);
+                    }
+                    else if (fieldType == typeof(uint))
+                    {
+                        // uints come in as a byte array, convert it manually here
+                        byte[] bytes = blockData[field.Name].AsBinary();
+                        uint value = Utils.BytesToUInt(bytes);
+                        field.SetValue(block, value);
+                    }
+                    else if (fieldType == typeof(ushort))
+                    {
+                        // Just need a bit of manual typecasting love here
+                        field.SetValue(block, (ushort)blockData[field.Name].AsInteger());
+                    }
+                    else if (fieldType == typeof(byte))
+                    {
+                        // Just need a bit of manual typecasting love here
+                        field.SetValue(block, (byte)blockData[field.Name].AsInteger());
+                    }
+                    else if (fieldType == typeof(short))
+                    {
+                        field.SetValue(block, (short)blockData[field.Name].AsInteger());
+                    }
+                    else if (fieldType == typeof(string))
+                    {
+                        field.SetValue(block, blockData[field.Name].AsString());
+                    }
+                    else if (fieldType == typeof(bool))
+                    {
+                        field.SetValue(block, blockData[field.Name].AsBoolean());
+                    }
+                    else if (fieldType == typeof(float))
+                    {
+                        field.SetValue(block, (float)blockData[field.Name].AsReal());
+                    }
+                    else if (fieldType == typeof(double))
+                    {
+                        field.SetValue(block, blockData[field.Name].AsReal());
+                    }
+                    else if (fieldType == typeof(int))
+                    {
+                        field.SetValue(block, blockData[field.Name].AsInteger());
+                    }
+                    else if (fieldType == typeof(UUID))
+                    {
+                        field.SetValue(block, blockData[field.Name].AsUUID());
+                    }
+                    else if (fieldType == typeof(Vector3))
+                    {
+                        Vector3 vec = ((OSDArray)blockData[field.Name]).AsVector3();
+                        field.SetValue(block, vec);
+                    }
+                    else if (fieldType == typeof(Vector4))
+                    {
+                        Vector4 vec = ((OSDArray)blockData[field.Name]).AsVector4();
+                        field.SetValue(block, vec);
+                    }
+                    else if (fieldType == typeof(Quaternion))
+                    {
+                        Quaternion quat = ((OSDArray)blockData[field.Name]).AsQuaternion();
+                        field.SetValue(block, quat);
+                    }
+                }
+            }
+
+            // Additional fields come as properties, Handle those as well.
+            foreach (PropertyInfo property in blockType.GetProperties())
+            {
+                if (blockData.ContainsKey(property.Name))
+                {
+                    OSDType proptype = blockData[property.Name].Type;
+                    MethodInfo set = property.GetSetMethod();
+
+                    if (proptype.Equals(OSDType.Binary))
+                    {
+                        set.Invoke(block, new object[] { blockData[property.Name].AsBinary() });
+                    }
+                    else
+                        set.Invoke(block, new object[] { Utils.StringToBytes(blockData[property.Name].AsString()) });
+                }
+            }
+
+            return block;
+        }
+
+        private static OSD BuildLLSDBlock(object block)
+        {
+            OSDMap map = new OSDMap();
+            Type blockType = block.GetType();
+
+            foreach (FieldInfo field in blockType.GetFields())
+            {
+                if (field.IsPublic)
+                    map[field.Name] = OSD.FromObject(field.GetValue(block));
+            }
+
+            foreach (PropertyInfo property in blockType.GetProperties())
+            {
+                if (property.Name != "Length")
+                {
+                    map[property.Name] = OSD.FromObject(property.GetValue(block, null));
+                }
+            }
+
+            return map;
+        }
+    }
+}
Index: TerrainCompressor.cs
===================================================================
--- TerrainCompressor.cs	(revision 2445)
+++ TerrainCompressor.cs	(working copy)
@@ -1,821 +1,821 @@
-using System;
-using OpenMetaverse.Packets;
-
-namespace OpenMetaverse
-{
-    public class TerrainPatch
-    {
-        #region Enums and Structs
-
-        public enum LayerType : byte
-        {
-            Land = 0x4C,
-            Water = 0x57,
-            Wind = 0x37,
-            Cloud = 0x38
-        }
-
-        public struct GroupHeader
-        {
-            public int Stride;
-            public int PatchSize;
-            public LayerType Type;
-        }
-
-        public struct Header
-        {
-            public float DCOffset;
-            public int Range;
-            public int QuantWBits;
-            public int PatchIDs;
-            public uint WordBits;
-
-            public int X
-            {
-                get { return PatchIDs >> 5; }
-                set { PatchIDs += (value << 5); }
-            }
-
-            public int Y
-            {
-                get { return PatchIDs & 0x1F; }
-                set { PatchIDs |= value & 0x1F; }
-            }
-        }
-
-        #endregion Enums and Structs
-
-        /// <summary>X position of this patch</summary>
-        public int X;
-        /// <summary>Y position of this patch</summary>
-        public int Y;
-        /// <summary>A 16x16 array of floats holding decompressed layer data</summary>
-        public float[] Data;
-    }
-
-    public static class TerrainCompressor
-    {
-        public const int PATCHES_PER_EDGE = 16;
-        public const int END_OF_PATCHES = 97;
-
-        private const float OO_SQRT2 = 0.7071067811865475244008443621049f;
-        private const int STRIDE = 264;
-
-        private const int ZERO_CODE = 0x0;
-        private const int ZERO_EOB = 0x2;
-        private const int POSITIVE_VALUE = 0x6;
-        private const int NEGATIVE_VALUE = 0x7;
-
-        private static readonly float[] DequantizeTable16 = new float[16 * 16];
-        private static readonly float[] DequantizeTable32 = new float[16 * 16];
-        private static readonly float[] CosineTable16 = new float[16 * 16];
-        //private static readonly float[] CosineTable32 = new float[16 * 16];
-        private static readonly int[] CopyMatrix16 = new int[16 * 16];
-        private static readonly int[] CopyMatrix32 = new int[16 * 16];
-        private static readonly float[] QuantizeTable16 = new float[16 * 16];
-
-        static TerrainCompressor()
-        {
-            // Initialize the decompression tables
-            BuildDequantizeTable16();
-            SetupCosines16();
-            BuildCopyMatrix16();
-            BuildQuantizeTable16();
-        }
-
-        public static LayerDataPacket CreateLayerDataPacket(TerrainPatch[] patches, TerrainPatch.LayerType type)
-        {
-            LayerDataPacket layer = new LayerDataPacket();
-            layer.LayerID.Type = (byte)type;
-
-            TerrainPatch.GroupHeader header = new TerrainPatch.GroupHeader();
-            header.Stride = STRIDE;
-            header.PatchSize = 16;
-            header.Type = type;
-
-            // Should be enough to fit even the most poorly packed data
-            byte[] data = new byte[patches.Length * 16 * 16 * 2];
-            BitPack bitpack = new BitPack(data, 0);
-            bitpack.PackBits(header.Stride, 16);
-            bitpack.PackBits(header.PatchSize, 8);
-            bitpack.PackBits((int)header.Type, 8);
-
-            for (int i = 0; i < patches.Length; i++)
-                CreatePatch(bitpack, patches[i].Data, patches[i].X, patches[i].Y);
-
-            bitpack.PackBits(END_OF_PATCHES, 8);
-
-            layer.LayerData.Data = new byte[bitpack.BytePos + 1];
-            Buffer.BlockCopy(bitpack.Data, 0, layer.LayerData.Data, 0, bitpack.BytePos + 1);
-
-            return layer;
-        }
-
-        /// <summary>
-        /// Creates a LayerData packet for compressed land data given a full
-        /// simulator heightmap and an array of indices of patches to compress
-        /// </summary>
-        /// <param name="heightmap">A 256 * 256 array of floating point values
-        /// specifying the height at each meter in the simulator</param>
-        /// <param name="patches">Array of indexes in the 16x16 grid of patches
-        /// for this simulator. For example if 1 and 17 are specified, patches
-        /// x=1,y=0 and x=1,y=1 are sent</param>
-        /// <returns></returns>
-        public static LayerDataPacket CreateLandPacket(float[] heightmap, int[] patches)
-        {
-            LayerDataPacket layer = new LayerDataPacket();
-            layer.LayerID.Type = (byte)TerrainPatch.LayerType.Land;
-
-            TerrainPatch.GroupHeader header = new TerrainPatch.GroupHeader();
-            header.Stride = STRIDE;
-            header.PatchSize = 16;
-            header.Type = TerrainPatch.LayerType.Land;
-
-            byte[] data = new byte[1536];
-            BitPack bitpack = new BitPack(data, 0);
-            bitpack.PackBits(header.Stride, 16);
-            bitpack.PackBits(header.PatchSize, 8);
-            bitpack.PackBits((int)header.Type, 8);
-
-            for (int i = 0; i < patches.Length; i++)
-                CreatePatchFromHeightmap(bitpack, heightmap, patches[i] % 16, (patches[i] - (patches[i] % 16)) / 16);
-
-            bitpack.PackBits(END_OF_PATCHES, 8);
-
-            layer.LayerData.Data = new byte[bitpack.BytePos + 1];
-            Buffer.BlockCopy(bitpack.Data, 0, layer.LayerData.Data, 0, bitpack.BytePos + 1);
-
-            return layer;
-        }
-
-        public static LayerDataPacket CreateLandPacket(float[] patchData, int x, int y)
-        {
-            LayerDataPacket layer = new LayerDataPacket();
-            layer.LayerID.Type = (byte)TerrainPatch.LayerType.Land;
-
-            TerrainPatch.GroupHeader header = new TerrainPatch.GroupHeader();
-            header.Stride = STRIDE;
-            header.PatchSize = 16;
-            header.Type = TerrainPatch.LayerType.Land;
-
-            byte[] data = new byte[1536];
-            BitPack bitpack = new BitPack(data, 0);
-            bitpack.PackBits(header.Stride, 16);
-            bitpack.PackBits(header.PatchSize, 8);
-            bitpack.PackBits((int)header.Type, 8);
-
-            CreatePatch(bitpack, patchData, x, y);
-
-            bitpack.PackBits(END_OF_PATCHES, 8);
-
-            layer.LayerData.Data = new byte[bitpack.BytePos + 1];
-            Buffer.BlockCopy(bitpack.Data, 0, layer.LayerData.Data, 0, bitpack.BytePos + 1);
-
-            return layer;
-        }
-
-        public static LayerDataPacket CreateLandPacket(float[,] patchData, int x, int y)
-        {
-            LayerDataPacket layer = new LayerDataPacket();
-            layer.LayerID.Type = (byte)TerrainPatch.LayerType.Land;
-
-            TerrainPatch.GroupHeader header = new TerrainPatch.GroupHeader();
-            header.Stride = STRIDE;
-            header.PatchSize = 16;
-            header.Type = TerrainPatch.LayerType.Land;
-
-            byte[] data = new byte[1536];
-            BitPack bitpack = new BitPack(data, 0);
-            bitpack.PackBits(header.Stride, 16);
-            bitpack.PackBits(header.PatchSize, 8);
-            bitpack.PackBits((int)header.Type, 8);
-
-            CreatePatch(bitpack, patchData, x, y);
-
-            bitpack.PackBits(END_OF_PATCHES, 8);
-
-            layer.LayerData.Data = new byte[bitpack.BytePos + 1];
-            Buffer.BlockCopy(bitpack.Data, 0, layer.LayerData.Data, 0, bitpack.BytePos + 1);
-
-            return layer;
-        }
-
-        public static void CreatePatch(BitPack output, float[] patchData, int x, int y)
-        {
-            if (patchData.Length != 16 * 16)
-                throw new ArgumentException("Patch data must be a 16x16 array");
-
-            TerrainPatch.Header header = PrescanPatch(patchData);
-            header.QuantWBits = 136;
-            header.PatchIDs = (y & 0x1F);
-            header.PatchIDs += (x << 5);
-
-            // NOTE: No idea what prequant and postquant should be or what they do
-            int[] patch = CompressPatch(patchData, header, 10);
-            int wbits = EncodePatchHeader(output, header, patch);
-            EncodePatch(output, patch, 0, wbits);
-        }
-
-        public static void CreatePatch(BitPack output, float[,] patchData, int x, int y)
-        {
-            if (patchData.Length != 16 * 16)
-                throw new ArgumentException("Patch data must be a 16x16 array");
-
-            TerrainPatch.Header header = PrescanPatch(patchData);
-            header.QuantWBits = 136;
-            header.PatchIDs = (y & 0x1F);
-            header.PatchIDs += (x << 5);
-
-            // NOTE: No idea what prequant and postquant should be or what they do
-            int[] patch = CompressPatch(patchData, header, 10);
-            int wbits = EncodePatchHeader(output, header, patch);
-            EncodePatch(output, patch, 0, wbits);
-        }
-
-        /// <summary>
-        /// Add a patch of terrain to a BitPacker
-        /// </summary>
-        /// <param name="output">BitPacker to write the patch to</param>
-        /// <param name="heightmap">Heightmap of the simulator, must be a 256 *
-        /// 256 float array</param>
-        /// <param name="x">X offset of the patch to create, valid values are
-        /// from 0 to 15</param>
-        /// <param name="y">Y offset of the patch to create, valid values are
-        /// from 0 to 15</param>
-        public static void CreatePatchFromHeightmap(BitPack output, float[] heightmap, int x, int y)
-        {
-            if (heightmap.Length != 256 * 256)
-                throw new ArgumentException("Heightmap data must be 256x256");
-
-            if (x < 0 || x > 15 || y < 0 || y > 15)
-                throw new ArgumentException("X and Y patch offsets must be from 0 to 15");
-
-            TerrainPatch.Header header = PrescanPatch(heightmap, x, y);
-            header.QuantWBits = 136;
-            header.PatchIDs = (y & 0x1F);
-            header.PatchIDs += (x << 5);
-
-            // NOTE: No idea what prequant and postquant should be or what they do
-            int[] patch = CompressPatch(heightmap, x, y, header, 10);
-            int wbits = EncodePatchHeader(output, header, patch);
-            EncodePatch(output, patch, 0, wbits);
-        }
-
-        private static TerrainPatch.Header PrescanPatch(float[] patch)
-        {
-            TerrainPatch.Header header = new TerrainPatch.Header();
-            float zmax = -99999999.0f;
-            float zmin = 99999999.0f;
-
-            for (int j = 0; j < 16; j++)
-            {
-                for (int i = 0; i < 16; i++)
-                {
-                    float val = patch[j * 16 + i];
-                    if (val > zmax) zmax = val;
-                    if (val < zmin) zmin = val;
-                }
-            }
-
-            header.DCOffset = zmin;
-            header.Range = (int)((zmax - zmin) + 1.0f);
-
-            return header;
-        }
-
-        private static TerrainPatch.Header PrescanPatch(float[,] patch)
-        {
-            TerrainPatch.Header header = new TerrainPatch.Header();
-            float zmax = -99999999.0f;
-            float zmin = 99999999.0f;
-
-            for (int j = 0; j < 16; j++)
-            {
-                for (int i = 0; i < 16; i++)
-                {
-                    float val = patch[j, i];
-                    if (val > zmax) zmax = val;
-                    if (val < zmin) zmin = val;
-                }
-            }
-
-            header.DCOffset = zmin;
-            header.Range = (int)((zmax - zmin) + 1.0f);
-
-            return header;
-        }
-
-        private static TerrainPatch.Header PrescanPatch(float[] heightmap, int patchX, int patchY)
-        {
-            TerrainPatch.Header header = new TerrainPatch.Header();
-            float zmax = -99999999.0f;
-            float zmin = 99999999.0f;
-
-            for (int j = patchY * 16; j < (patchY + 1) * 16; j++)
-            {
-                for (int i = patchX * 16; i < (patchX + 1) * 16; i++)
-                {
-                    float val = heightmap[j * 256 + i];
-                    if (val > zmax) zmax = val;
-                    if (val < zmin) zmin = val;
-                }
-            }
-
-            header.DCOffset = zmin;
-            header.Range = (int)((zmax - zmin) + 1.0f);
-
-            return header;
-        }
-
-        public static TerrainPatch.Header DecodePatchHeader(BitPack bitpack)
-        {
-            TerrainPatch.Header header = new TerrainPatch.Header();
-
-            // Quantized word bits
-            header.QuantWBits = bitpack.UnpackBits(8);
-            if (header.QuantWBits == END_OF_PATCHES)
-                return header;
-
-            // DC offset
-            header.DCOffset = bitpack.UnpackFloat();
-
-            // Range
-            header.Range = bitpack.UnpackBits(16);
-
-            // Patch IDs (10 bits)
-            header.PatchIDs = bitpack.UnpackBits(10);
-
-            // Word bits
-            header.WordBits = (uint)((header.QuantWBits & 0x0f) + 2);
-
-            return header;
-        }
-
-        private static int EncodePatchHeader(BitPack output, TerrainPatch.Header header, int[] patch)
-        {
-            int temp;
-            int wbits = (header.QuantWBits & 0x0f) + 2;
-            uint maxWbits = (uint)wbits + 5;
-            uint minWbits = ((uint)wbits >> 1);
-
-            wbits = (int)minWbits;
-
-            for (int i = 0; i < patch.Length; i++)
-            {
-                temp = patch[i];
-
-                if (temp != 0)
-                {
-                    // Get the absolute value
-                    if (temp < 0) temp *= -1;
-
-                    for (int j = (int)maxWbits; j > (int)minWbits; j--)
-                    {
-                        if ((temp & (1 << j)) != 0)
-                        {
-                            if (j > wbits) wbits = j;
-                            break;
-                        }
-                    }
-                }
-            }
-
-            wbits += 1;
-
-            header.QuantWBits &= 0xf0;
-
-            if (wbits > 17 || wbits < 2)
-            {
-                Logger.Log("Bits needed per word in EncodePatchHeader() are outside the allowed range",
-                    Helpers.LogLevel.Error);
-            }
-
-            header.QuantWBits |= (wbits - 2);
-
-            output.PackBits(header.QuantWBits, 8);
-            output.PackFloat(header.DCOffset);
-            output.PackBits(header.Range, 16);
-            output.PackBits(header.PatchIDs, 10);
-
-            return wbits;
-        }
-
-        private static void IDCTColumn16(float[] linein, float[] lineout, int column)
-        {
-            float total;
-            int usize;
-
-            for (int n = 0; n < 16; n++)
-            {
-                total = OO_SQRT2 * linein[column];
-
-                for (int u = 1; u < 16; u++)
-                {
-                    usize = u * 16;
-                    total += linein[usize + column] * CosineTable16[usize + n];
-                }
-
-                lineout[16 * n + column] = total;
-            }
-        }
-
-        private static void IDCTLine16(float[] linein, float[] lineout, int line)
-        {
-            const float oosob = 2.0f / 16.0f;
-            int lineSize = line * 16;
-            float total;
-
-            for (int n = 0; n < 16; n++)
-            {
-                total = OO_SQRT2 * linein[lineSize];
-
-                for (int u = 1; u < 16; u++)
-                {
-                    total += linein[lineSize + u] * CosineTable16[u * 16 + n];
-                }
-
-                lineout[lineSize + n] = total * oosob;
-            }
-        }
-
-        private static void DCTLine16(float[] linein, float[] lineout, int line)
-        {
-            float total = 0.0f;
-            int lineSize = line * 16;
-
-            for (int n = 0; n < 16; n++)
-            {
-                total += linein[lineSize + n];
-            }
-
-            lineout[lineSize] = OO_SQRT2 * total;
-
-            for (int u = 1; u < 16; u++)
-            {
-                total = 0.0f;
-
-                for (int n = 0; n < 16; n++)
-                {
-                    total += linein[lineSize + n] * CosineTable16[u * 16 + n];
-                }
-
-                lineout[lineSize + u] = total;
-            }
-        }
-
-        private static void DCTColumn16(float[] linein, int[] lineout, int column)
-        {
-            float total = 0.0f;
-            const float oosob = 2.0f / 16.0f;
-
-            for (int n = 0; n < 16; n++)
-            {
-                total += linein[16 * n + column];
-            }
-
-            lineout[CopyMatrix16[column]] = (int)(OO_SQRT2 * total * oosob * QuantizeTable16[column]);
-
-            for (int u = 1; u < 16; u++)
-            {
-                total = 0.0f;
-
-                for (int n = 0; n < 16; n++)
-                {
-                    total += linein[16 * n + column] * CosineTable16[u * 16 + n];
-                }
-
-                lineout[CopyMatrix16[16 * u + column]] = (int)(total * oosob * QuantizeTable16[16 * u + column]);
-            }
-        }
-
-        public static void DecodePatch(int[] patches, BitPack bitpack, TerrainPatch.Header header, int size)
-        {
-            int temp;
-            for (int n = 0; n < size * size; n++)
-            {
-                // ?
-                temp = bitpack.UnpackBits(1);
-                if (temp != 0)
-                {
-                    // Value or EOB
-                    temp = bitpack.UnpackBits(1);
-                    if (temp != 0)
-                    {
-                        // Value
-                        temp = bitpack.UnpackBits(1);
-                        if (temp != 0)
-                        {
-                            // Negative
-                            temp = bitpack.UnpackBits((int)header.WordBits);
-                            patches[n] = temp * -1;
-                        }
-                        else
-                        {
-                            // Positive
-                            temp = bitpack.UnpackBits((int)header.WordBits);
-                            patches[n] = temp;
-                        }
-                    }
-                    else
-                    {
-                        // Set the rest to zero
-                        // TODO: This might not be necessary
-                        for (int o = n; o < size * size; o++)
-                        {
-                            patches[o] = 0;
-                        }
-                        break;
-                    }
-                }
-                else
-                {
-                    patches[n] = 0;
-                }
-            }
-        }
-
-        private static void EncodePatch(BitPack output, int[] patch, int postquant, int wbits)
-        {
-            int temp;
-            bool eob;
-
-            if (postquant > 16 * 16 || postquant < 0)
-            {
-                Logger.Log("Postquant is outside the range of allowed values in EncodePatch()", Helpers.LogLevel.Error);
-                return;
-            }
-
-            if (postquant != 0) patch[16 * 16 - postquant] = 0;
-
-            for (int i = 0; i < 16 * 16; i++)
-            {
-                eob = false;
-                temp = patch[i];
-
-                if (temp == 0)
-                {
-                    eob = true;
-
-                    for (int j = i; j < 16 * 16 - postquant; j++)
-                    {
-                        if (patch[j] != 0)
-                        {
-                            eob = false;
-                            break;
-                        }
-                    }
-
-                    if (eob)
-                    {
-                        output.PackBits(ZERO_EOB, 2);
-                        return;
-                    }
-                    else
-                    {
-                        output.PackBits(ZERO_CODE, 1);
-                    }
-                }
-                else
-                {
-                    if (temp < 0)
-                    {
-                        temp *= -1;
-
-                        if (temp > (1 << wbits)) temp = (1 << wbits);
-
-                        output.PackBits(NEGATIVE_VALUE, 3);
-                        output.PackBits(temp, wbits);
-                    }
-                    else
-                    {
-                        if (temp > (1 << wbits)) temp = (1 << wbits);
-
-                        output.PackBits(POSITIVE_VALUE, 3);
-                        output.PackBits(temp, wbits);
-                    }
-                }
-            }
-        }
-
-        public static float[] DecompressPatch(int[] patches, TerrainPatch.Header header, TerrainPatch.GroupHeader group)
-        {
-            float[] block = new float[group.PatchSize * group.PatchSize];
-            float[] output = new float[group.PatchSize * group.PatchSize];
-            int prequant = (header.QuantWBits >> 4) + 2;
-            int quantize = 1 << prequant;
-            float ooq = 1.0f / (float)quantize;
-            float mult = ooq * (float)header.Range;
-            float addval = mult * (float)(1 << (prequant - 1)) + header.DCOffset;
-
-            if (group.PatchSize == 16)
-            {
-                for (int n = 0; n < 16 * 16; n++)
-                {
-                    block[n] = patches[CopyMatrix16[n]] * DequantizeTable16[n];
-                }
-
-                float[] ftemp = new float[16 * 16];
-
-                for (int o = 0; o < 16; o++)
-                    IDCTColumn16(block, ftemp, o);
-                for (int o = 0; o < 16; o++)
-                    IDCTLine16(ftemp, block, o);
-            }
-            else
-            {
-                for (int n = 0; n < 32 * 32; n++)
-                {
-                    block[n] = patches[CopyMatrix32[n]] * DequantizeTable32[n];
-                }
-
-                Logger.Log("Implement IDCTPatchLarge", Helpers.LogLevel.Error);
-            }
-
-            for (int j = 0; j < block.Length; j++)
-            {
-                output[j] = block[j] * mult + addval;
-            }
-
-            return output;
-        }
-
-        private static int[] CompressPatch(float[] patchData, TerrainPatch.Header header, int prequant)
-        {
-            float[] block = new float[16 * 16];
-            int wordsize = prequant;
-            float oozrange = 1.0f / (float)header.Range;
-            float range = (float)(1 << prequant);
-            float premult = oozrange * range;
-            float sub = (float)(1 << (prequant - 1)) + header.DCOffset * premult;
-
-            header.QuantWBits = wordsize - 2;
-            header.QuantWBits |= (prequant - 2) << 4;
-
-            int k = 0;
-            for (int j = 0; j < 16; j++)
-            {
-                for (int i = 0; i < 16; i++)
-                    block[k++] = patchData[j * 16 + i] * premult - sub;
-            }
-
-            float[] ftemp = new float[16 * 16];
-            int[] itemp = new int[16 * 16];
-
-            for (int o = 0; o < 16; o++)
-                DCTLine16(block, ftemp, o);
-            for (int o = 0; o < 16; o++)
-                DCTColumn16(ftemp, itemp, o);
-
-            return itemp;
-        }
-
-        private static int[] CompressPatch(float[,] patchData, TerrainPatch.Header header, int prequant)
-        {
-            float[] block = new float[16 * 16];
-            int wordsize = prequant;
-            float oozrange = 1.0f / (float)header.Range;
-            float range = (float)(1 << prequant);
-            float premult = oozrange * range;
-            float sub = (float)(1 << (prequant - 1)) + header.DCOffset * premult;
-
-            header.QuantWBits = wordsize - 2;
-            header.QuantWBits |= (prequant - 2) << 4;
-
-            int k = 0;
-            for (int j = 0; j < 16; j++)
-            {
-                for (int i = 0; i < 16; i++)
-                    block[k++] = patchData[j, i] * premult - sub;
-            }
-
-            float[] ftemp = new float[16 * 16];
-            int[] itemp = new int[16 * 16];
-
-            for (int o = 0; o < 16; o++)
-                DCTLine16(block, ftemp, o);
-            for (int o = 0; o < 16; o++)
-                DCTColumn16(ftemp, itemp, o);
-
-            return itemp;
-        }
-
-        private static int[] CompressPatch(float[] heightmap, int patchX, int patchY, TerrainPatch.Header header, int prequant)
-        {
-            float[] block = new float[16 * 16];
-            int wordsize = prequant;
-            float oozrange = 1.0f / (float)header.Range;
-            float range = (float)(1 << prequant);
-            float premult = oozrange * range;
-            float sub = (float)(1 << (prequant - 1)) + header.DCOffset * premult;
-
-            header.QuantWBits = wordsize - 2;
-            header.QuantWBits |= (prequant - 2) << 4;
-
-            int k = 0;
-            for (int j = patchY * 16; j < (patchY + 1) * 16; j++)
-            {
-                for (int i = patchX * 16; i < (patchX + 1) * 16; i++)
-                    block[k++] = heightmap[j * 256 + i] * premult - sub;
-            }
-
-            float[] ftemp = new float[16 * 16];
-            int[] itemp = new int[16 * 16];
-
-            for (int o = 0; o < 16; o++)
-                DCTLine16(block, ftemp, o);
-            for (int o = 0; o < 16; o++)
-                DCTColumn16(ftemp, itemp, o);
-
-            return itemp;
-        }
-
-
-        #region Initialization
-
-        private static void BuildDequantizeTable16()
-        {
-            for (int j = 0; j < 16; j++)
-            {
-                for (int i = 0; i < 16; i++)
-                {
-                    DequantizeTable16[j * 16 + i] = 1.0f + 2.0f * (float)(i + j);
-                }
-            }
-        }
-
-        private static void BuildQuantizeTable16()
-        {
-            for (int j = 0; j < 16; j++)
-            {
-                for (int i = 0; i < 16; i++)
-                {
-                    QuantizeTable16[j * 16 + i] = 1.0f / (1.0f + 2.0f * ((float)i + (float)j));
-                }
-            }
-        }
-
-        private static void SetupCosines16()
-        {
-            const float hposz = (float)Math.PI * 0.5f / 16.0f;
-
-            for (int u = 0; u < 16; u++)
-            {
-                for (int n = 0; n < 16; n++)
-                {
-                    CosineTable16[u * 16 + n] = (float)Math.Cos((2.0f * (float)n + 1.0f) * (float)u * hposz);
-                }
-            }
-        }
-
-        private static void BuildCopyMatrix16()
-        {
-            bool diag = false;
-            bool right = true;
-            int i = 0;
-            int j = 0;
-            int count = 0;
-
-            while (i < 16 && j < 16)
-            {
-                CopyMatrix16[j * 16 + i] = count++;
-
-                if (!diag)
-                {
-                    if (right)
-                    {
-                        if (i < 16 - 1) i++;
-                        else j++;
-
-                        right = false;
-                        diag = true;
-                    }
-                    else
-                    {
-                        if (j < 16 - 1) j++;
-                        else i++;
-
-                        right = true;
-                        diag = true;
-                    }
-                }
-                else
-                {
-                    if (right)
-                    {
-                        i++;
-                        j--;
-                        if (i == 16 - 1 || j == 0) diag = false;
-                    }
-                    else
-                    {
-                        i--;
-                        j++;
-                        if (j == 16 - 1 || i == 0) diag = false;
-                    }
-                }
-            }
-        }
-
-        #endregion Initialization
-    }
-}
+using System;
+using OpenMetaverse.Packets;
+
+namespace OpenMetaverse
+{
+    public class TerrainPatch
+    {
+        #region Enums and Structs
+
+        public enum LayerType : byte
+        {
+            Land = 0x4C,
+            Water = 0x57,
+            Wind = 0x37,
+            Cloud = 0x38
+        }
+
+        public struct GroupHeader
+        {
+            public int Stride;
+            public int PatchSize;
+            public LayerType Type;
+        }
+
+        public struct Header
+        {
+            public float DCOffset;
+            public int Range;
+            public int QuantWBits;
+            public int PatchIDs;
+            public uint WordBits;
+
+            public int X
+            {
+                get { return PatchIDs >> 5; }
+                set { PatchIDs += (value << 5); }
+            }
+
+            public int Y
+            {
+                get { return PatchIDs & 0x1F; }
+                set { PatchIDs |= value & 0x1F; }
+            }
+        }
+
+        #endregion Enums and Structs
+
+        /// <summary>X position of this patch</summary>
+        public int X;
+        /// <summary>Y position of this patch</summary>
+        public int Y;
+        /// <summary>A 16x16 array of floats holding decompressed layer data</summary>
+        public float[] Data;
+    }
+
+    public static class TerrainCompressor
+    {
+        public const int PATCHES_PER_EDGE = 16;
+        public const int END_OF_PATCHES = 97;
+
+        private const float OO_SQRT2 = 0.7071067811865475244008443621049f;
+        private const int STRIDE = 264;
+
+        private const int ZERO_CODE = 0x0;
+        private const int ZERO_EOB = 0x2;
+        private const int POSITIVE_VALUE = 0x6;
+        private const int NEGATIVE_VALUE = 0x7;
+
+        private static readonly float[] DequantizeTable16 = new float[16 * 16];
+        private static readonly float[] DequantizeTable32 = new float[16 * 16];
+        private static readonly float[] CosineTable16 = new float[16 * 16];
+        //private static readonly float[] CosineTable32 = new float[16 * 16];
+        private static readonly int[] CopyMatrix16 = new int[16 * 16];
+        private static readonly int[] CopyMatrix32 = new int[16 * 16];
+        private static readonly float[] QuantizeTable16 = new float[16 * 16];
+
+        static TerrainCompressor()
+        {
+            // Initialize the decompression tables
+            BuildDequantizeTable16();
+            SetupCosines16();
+            BuildCopyMatrix16();
+            BuildQuantizeTable16();
+        }
+
+        public static LayerDataPacket CreateLayerDataPacket(TerrainPatch[] patches, TerrainPatch.LayerType type)
+        {
+            LayerDataPacket layer = new LayerDataPacket();
+            layer.LayerID.Type = (byte)type;
+
+            TerrainPatch.GroupHeader header = new TerrainPatch.GroupHeader();
+            header.Stride = STRIDE;
+            header.PatchSize = 16;
+            header.Type = type;
+
+            // Should be enough to fit even the most poorly packed data
+            byte[] data = new byte[patches.Length * 16 * 16 * 2];
+            BitPack bitpack = new BitPack(data, 0);
+            bitpack.PackBits(header.Stride, 16);
+            bitpack.PackBits(header.PatchSize, 8);
+            bitpack.PackBits((int)header.Type, 8);
+
+            for (int i = 0; i < patches.Length; i++)
+                CreatePatch(bitpack, patches[i].Data, patches[i].X, patches[i].Y);
+
+            bitpack.PackBits(END_OF_PATCHES, 8);
+
+            layer.LayerData.Data = new byte[bitpack.BytePos + 1];
+            Buffer.BlockCopy(bitpack.Data, 0, layer.LayerData.Data, 0, bitpack.BytePos + 1);
+
+            return layer;
+        }
+
+        /// <summary>
+        /// Creates a LayerData packet for compressed land data given a full
+        /// simulator heightmap and an array of indices of patches to compress
+        /// </summary>
+        /// <param name="heightmap">A 256 * 256 array of floating point values
+        /// specifying the height at each meter in the simulator</param>
+        /// <param name="patches">Array of indexes in the 16x16 grid of patches
+        /// for this simulator. For example if 1 and 17 are specified, patches
+        /// x=1,y=0 and x=1,y=1 are sent</param>
+        /// <returns></returns>
+        public static LayerDataPacket CreateLandPacket(float[] heightmap, int[] patches)
+        {
+            LayerDataPacket layer = new LayerDataPacket();
+            layer.LayerID.Type = (byte)TerrainPatch.LayerType.Land;
+
+            TerrainPatch.GroupHeader header = new TerrainPatch.GroupHeader();
+            header.Stride = STRIDE;
+            header.PatchSize = 16;
+            header.Type = TerrainPatch.LayerType.Land;
+
+            byte[] data = new byte[1536];
+            BitPack bitpack = new BitPack(data, 0);
+            bitpack.PackBits(header.Stride, 16);
+            bitpack.PackBits(header.PatchSize, 8);
+            bitpack.PackBits((int)header.Type, 8);
+
+            for (int i = 0; i < patches.Length; i++)
+                CreatePatchFromHeightmap(bitpack, heightmap, patches[i] % 16, (patches[i] - (patches[i] % 16)) / 16);
+
+            bitpack.PackBits(END_OF_PATCHES, 8);
+
+            layer.LayerData.Data = new byte[bitpack.BytePos + 1];
+            Buffer.BlockCopy(bitpack.Data, 0, layer.LayerData.Data, 0, bitpack.BytePos + 1);
+
+            return layer;
+        }
+
+        public static LayerDataPacket CreateLandPacket(float[] patchData, int x, int y)
+        {
+            LayerDataPacket layer = new LayerDataPacket();
+            layer.LayerID.Type = (byte)TerrainPatch.LayerType.Land;
+
+            TerrainPatch.GroupHeader header = new TerrainPatch.GroupHeader();
+            header.Stride = STRIDE;
+            header.PatchSize = 16;
+            header.Type = TerrainPatch.LayerType.Land;
+
+            byte[] data = new byte[1536];
+            BitPack bitpack = new BitPack(data, 0);
+            bitpack.PackBits(header.Stride, 16);
+            bitpack.PackBits(header.PatchSize, 8);
+            bitpack.PackBits((int)header.Type, 8);
+
+            CreatePatch(bitpack, patchData, x, y);
+
+            bitpack.PackBits(END_OF_PATCHES, 8);
+
+            layer.LayerData.Data = new byte[bitpack.BytePos + 1];
+            Buffer.BlockCopy(bitpack.Data, 0, layer.LayerData.Data, 0, bitpack.BytePos + 1);
+
+            return layer;
+        }
+
+        public static LayerDataPacket CreateLandPacket(float[,] patchData, int x, int y)
+        {
+            LayerDataPacket layer = new LayerDataPacket();
+            layer.LayerID.Type = (byte)TerrainPatch.LayerType.Land;
+
+            TerrainPatch.GroupHeader header = new TerrainPatch.GroupHeader();
+            header.Stride = STRIDE;
+            header.PatchSize = 16;
+            header.Type = TerrainPatch.LayerType.Land;
+
+            byte[] data = new byte[1536];
+            BitPack bitpack = new BitPack(data, 0);
+            bitpack.PackBits(header.Stride, 16);
+            bitpack.PackBits(header.PatchSize, 8);
+            bitpack.PackBits((int)header.Type, 8);
+
+            CreatePatch(bitpack, patchData, x, y);
+
+            bitpack.PackBits(END_OF_PATCHES, 8);
+
+            layer.LayerData.Data = new byte[bitpack.BytePos + 1];
+            Buffer.BlockCopy(bitpack.Data, 0, layer.LayerData.Data, 0, bitpack.BytePos + 1);
+
+            return layer;
+        }
+
+        public static void CreatePatch(BitPack output, float[] patchData, int x, int y)
+        {
+            if (patchData.Length != 16 * 16)
+                throw new ArgumentException("Patch data must be a 16x16 array");
+
+            TerrainPatch.Header header = PrescanPatch(patchData);
+            header.QuantWBits = 136;
+            header.PatchIDs = (y & 0x1F);
+            header.PatchIDs += (x << 5);
+
+            // NOTE: No idea what prequant and postquant should be or what they do
+            int[] patch = CompressPatch(patchData, header, 10);
+            int wbits = EncodePatchHeader(output, header, patch);
+            EncodePatch(output, patch, 0, wbits);
+        }
+
+        public static void CreatePatch(BitPack output, float[,] patchData, int x, int y)
+        {
+            if (patchData.Length != 16 * 16)
+                throw new ArgumentException("Patch data must be a 16x16 array");
+
+            TerrainPatch.Header header = PrescanPatch(patchData);
+            header.QuantWBits = 136;
+            header.PatchIDs = (y & 0x1F);
+            header.PatchIDs += (x << 5);
+
+            // NOTE: No idea what prequant and postquant should be or what they do
+            int[] patch = CompressPatch(patchData, header, 10);
+            int wbits = EncodePatchHeader(output, header, patch);
+            EncodePatch(output, patch, 0, wbits);
+        }
+
+        /// <summary>
+        /// Add a patch of terrain to a BitPacker
+        /// </summary>
+        /// <param name="output">BitPacker to write the patch to</param>
+        /// <param name="heightmap">Heightmap of the simulator, must be a 256 *
+        /// 256 float array</param>
+        /// <param name="x">X offset of the patch to create, valid values are
+        /// from 0 to 15</param>
+        /// <param name="y">Y offset of the patch to create, valid values are
+        /// from 0 to 15</param>
+        public static void CreatePatchFromHeightmap(BitPack output, float[] heightmap, int x, int y)
+        {
+            if (heightmap.Length != 256 * 256)
+                throw new ArgumentException("Heightmap data must be 256x256");
+
+            if (x < 0 || x > 15 || y < 0 || y > 15)
+                throw new ArgumentException("X and Y patch offsets must be from 0 to 15");
+
+            TerrainPatch.Header header = PrescanPatch(heightmap, x, y);
+            header.QuantWBits = 136;
+            header.PatchIDs = (y & 0x1F);
+            header.PatchIDs += (x << 5);
+
+            // NOTE: No idea what prequant and postquant should be or what they do
+            int[] patch = CompressPatch(heightmap, x, y, header, 10);
+            int wbits = EncodePatchHeader(output, header, patch);
+            EncodePatch(output, patch, 0, wbits);
+        }
+
+        private static TerrainPatch.Header PrescanPatch(float[] patch)
+        {
+            TerrainPatch.Header header = new TerrainPatch.Header();
+            float zmax = -99999999.0f;
+            float zmin = 99999999.0f;
+
+            for (int j = 0; j < 16; j++)
+            {
+                for (int i = 0; i < 16; i++)
+                {
+                    float val = patch[j * 16 + i];
+                    if (val > zmax) zmax = val;
+                    if (val < zmin) zmin = val;
+                }
+            }
+
+            header.DCOffset = zmin;
+            header.Range = (int)((zmax - zmin) + 1.0f);
+
+            return header;
+        }
+
+        private static TerrainPatch.Header PrescanPatch(float[,] patch)
+        {
+            TerrainPatch.Header header = new TerrainPatch.Header();
+            float zmax = -99999999.0f;
+            float zmin = 99999999.0f;
+
+            for (int j = 0; j < 16; j++)
+            {
+                for (int i = 0; i < 16; i++)
+                {
+                    float val = patch[j, i];
+                    if (val > zmax) zmax = val;
+                    if (val < zmin) zmin = val;
+                }
+            }
+
+            header.DCOffset = zmin;
+            header.Range = (int)((zmax - zmin) + 1.0f);
+
+            return header;
+        }
+
+        private static TerrainPatch.Header PrescanPatch(float[] heightmap, int patchX, int patchY)
+        {
+            TerrainPatch.Header header = new TerrainPatch.Header();
+            float zmax = -99999999.0f;
+            float zmin = 99999999.0f;
+
+            for (int j = patchY * 16; j < (patchY + 1) * 16; j++)
+            {
+                for (int i = patchX * 16; i < (patchX + 1) * 16; i++)
+                {
+                    float val = heightmap[j * 256 + i];
+                    if (val > zmax) zmax = val;
+                    if (val < zmin) zmin = val;
+                }
+            }
+
+            header.DCOffset = zmin;
+            header.Range = (int)((zmax - zmin) + 1.0f);
+
+            return header;
+        }
+
+        public static TerrainPatch.Header DecodePatchHeader(BitPack bitpack)
+        {
+            TerrainPatch.Header header = new TerrainPatch.Header();
+
+            // Quantized word bits
+            header.QuantWBits = bitpack.UnpackBits(8);
+            if (header.QuantWBits == END_OF_PATCHES)
+                return header;
+
+            // DC offset
+            header.DCOffset = bitpack.UnpackFloat();
+
+            // Range
+            header.Range = bitpack.UnpackBits(16);
+
+            // Patch IDs (10 bits)
+            header.PatchIDs = bitpack.UnpackBits(10);
+
+            // Word bits
+            header.WordBits = (uint)((header.QuantWBits & 0x0f) + 2);
+
+            return header;
+        }
+
+        private static int EncodePatchHeader(BitPack output, TerrainPatch.Header header, int[] patch)
+        {
+            int temp;
+            int wbits = (header.QuantWBits & 0x0f) + 2;
+            uint maxWbits = (uint)wbits + 5;
+            uint minWbits = ((uint)wbits >> 1);
+
+            wbits = (int)minWbits;
+
+            for (int i = 0; i < patch.Length; i++)
+            {
+                temp = patch[i];
+
+                if (temp != 0)
+                {
+                    // Get the absolute value
+                    if (temp < 0) temp *= -1;
+
+                    for (int j = (int)maxWbits; j > (int)minWbits; j--)
+                    {
+                        if ((temp & (1 << j)) != 0)
+                        {
+                            if (j > wbits) wbits = j;
+                            break;
+                        }
+                    }
+                }
+            }
+
+            wbits += 1;
+
+            header.QuantWBits &= 0xf0;
+
+            if (wbits > 17 || wbits < 2)
+            {
+                Logger.Log("Bits needed per word in EncodePatchHeader() are outside the allowed range",
+                    Helpers.LogLevel.Error);
+            }
+
+            header.QuantWBits |= (wbits - 2);
+
+            output.PackBits(header.QuantWBits, 8);
+            output.PackFloat(header.DCOffset);
+            output.PackBits(header.Range, 16);
+            output.PackBits(header.PatchIDs, 10);
+
+            return wbits;
+        }
+
+        private static void IDCTColumn16(float[] linein, float[] lineout, int column)
+        {
+            float total;
+            int usize;
+
+            for (int n = 0; n < 16; n++)
+            {
+                total = OO_SQRT2 * linein[column];
+
+                for (int u = 1; u < 16; u++)
+                {
+                    usize = u * 16;
+                    total += linein[usize + column] * CosineTable16[usize + n];
+                }
+
+                lineout[16 * n + column] = total;
+            }
+        }
+
+        private static void IDCTLine16(float[] linein, float[] lineout, int line)
+        {
+            const float oosob = 2.0f / 16.0f;
+            int lineSize = line * 16;
+            float total;
+
+            for (int n = 0; n < 16; n++)
+            {
+                total = OO_SQRT2 * linein[lineSize];
+
+                for (int u = 1; u < 16; u++)
+                {
+                    total += linein[lineSize + u] * CosineTable16[u * 16 + n];
+                }
+
+                lineout[lineSize + n] = total * oosob;
+            }
+        }
+
+        private static void DCTLine16(float[] linein, float[] lineout, int line)
+        {
+            float total = 0.0f;
+            int lineSize = line * 16;
+
+            for (int n = 0; n < 16; n++)
+            {
+                total += linein[lineSize + n];
+            }
+
+            lineout[lineSize] = OO_SQRT2 * total;
+
+            for (int u = 1; u < 16; u++)
+            {
+                total = 0.0f;
+
+                for (int n = 0; n < 16; n++)
+                {
+                    total += linein[lineSize + n] * CosineTable16[u * 16 + n];
+                }
+
+                lineout[lineSize + u] = total;
+            }
+        }
+
+        private static void DCTColumn16(float[] linein, int[] lineout, int column)
+        {
+            float total = 0.0f;
+            const float oosob = 2.0f / 16.0f;
+
+            for (int n = 0; n < 16; n++)
+            {
+                total += linein[16 * n + column];
+            }
+
+            lineout[CopyMatrix16[column]] = (int)(OO_SQRT2 * total * oosob * QuantizeTable16[column]);
+
+            for (int u = 1; u < 16; u++)
+            {
+                total = 0.0f;
+
+                for (int n = 0; n < 16; n++)
+                {
+                    total += linein[16 * n + column] * CosineTable16[u * 16 + n];
+                }
+
+                lineout[CopyMatrix16[16 * u + column]] = (int)(total * oosob * QuantizeTable16[16 * u + column]);
+            }
+        }
+
+        public static void DecodePatch(int[] patches, BitPack bitpack, TerrainPatch.Header header, int size)
+        {
+            int temp;
+            for (int n = 0; n < size * size; n++)
+            {
+                // ?
+                temp = bitpack.UnpackBits(1);
+                if (temp != 0)
+                {
+                    // Value or EOB
+                    temp = bitpack.UnpackBits(1);
+                    if (temp != 0)
+                    {
+                        // Value
+                        temp = bitpack.UnpackBits(1);
+                        if (temp != 0)
+                        {
+                            // Negative
+                            temp = bitpack.UnpackBits((int)header.WordBits);
+                            patches[n] = temp * -1;
+                        }
+                        else
+                        {
+                            // Positive
+                            temp = bitpack.UnpackBits((int)header.WordBits);
+                            patches[n] = temp;
+                        }
+                    }
+                    else
+                    {
+                        // Set the rest to zero
+                        // TODO: This might not be necessary
+                        for (int o = n; o < size * size; o++)
+                        {
+                            patches[o] = 0;
+                        }
+                        break;
+                    }
+                }
+                else
+                {
+                    patches[n] = 0;
+                }
+            }
+        }
+
+        private static void EncodePatch(BitPack output, int[] patch, int postquant, int wbits)
+        {
+            int temp;
+            bool eob;
+
+            if (postquant > 16 * 16 || postquant < 0)
+            {
+                Logger.Log("Postquant is outside the range of allowed values in EncodePatch()", Helpers.LogLevel.Error);
+                return;
+            }
+
+            if (postquant != 0) patch[16 * 16 - postquant] = 0;
+
+            for (int i = 0; i < 16 * 16; i++)
+            {
+                eob = false;
+                temp = patch[i];
+
+                if (temp == 0)
+                {
+                    eob = true;
+
+                    for (int j = i; j < 16 * 16 - postquant; j++)
+                    {
+                        if (patch[j] != 0)
+                        {
+                            eob = false;
+                            break;
+                        }
+                    }
+
+                    if (eob)
+                    {
+                        output.PackBits(ZERO_EOB, 2);
+                        return;
+                    }
+                    else
+                    {
+                        output.PackBits(ZERO_CODE, 1);
+                    }
+                }
+                else
+                {
+                    if (temp < 0)
+                    {
+                        temp *= -1;
+
+                        if (temp > (1 << wbits)) temp = (1 << wbits);
+
+                        output.PackBits(NEGATIVE_VALUE, 3);
+                        output.PackBits(temp, wbits);
+                    }
+                    else
+                    {
+                        if (temp > (1 << wbits)) temp = (1 << wbits);
+
+                        output.PackBits(POSITIVE_VALUE, 3);
+                        output.PackBits(temp, wbits);
+                    }
+                }
+            }
+        }
+
+        public static float[] DecompressPatch(int[] patches, TerrainPatch.Header header, TerrainPatch.GroupHeader group)
+        {
+            float[] block = new float[group.PatchSize * group.PatchSize];
+            float[] output = new float[group.PatchSize * group.PatchSize];
+            int prequant = (header.QuantWBits >> 4) + 2;
+            int quantize = 1 << prequant;
+            float ooq = 1.0f / (float)quantize;
+            float mult = ooq * (float)header.Range;
+            float addval = mult * (float)(1 << (prequant - 1)) + header.DCOffset;
+
+            if (group.PatchSize == 16)
+            {
+                for (int n = 0; n < 16 * 16; n++)
+                {
+                    block[n] = patches[CopyMatrix16[n]] * DequantizeTable16[n];
+                }
+
+                float[] ftemp = new float[16 * 16];
+
+                for (int o = 0; o < 16; o++)
+                    IDCTColumn16(block, ftemp, o);
+                for (int o = 0; o < 16; o++)
+                    IDCTLine16(ftemp, block, o);
+            }
+            else
+            {
+                for (int n = 0; n < 32 * 32; n++)
+                {
+                    block[n] = patches[CopyMatrix32[n]] * DequantizeTable32[n];
+                }
+
+                Logger.Log("Implement IDCTPatchLarge", Helpers.LogLevel.Error);
+            }
+
+            for (int j = 0; j < block.Length; j++)
+            {
+                output[j] = block[j] * mult + addval;
+            }
+
+            return output;
+        }
+
+        private static int[] CompressPatch(float[] patchData, TerrainPatch.Header header, int prequant)
+        {
+            float[] block = new float[16 * 16];
+            int wordsize = prequant;
+            float oozrange = 1.0f / (float)header.Range;
+            float range = (float)(1 << prequant);
+            float premult = oozrange * range;
+            float sub = (float)(1 << (prequant - 1)) + header.DCOffset * premult;
+
+            header.QuantWBits = wordsize - 2;
+            header.QuantWBits |= (prequant - 2) << 4;
+
+            int k = 0;
+            for (int j = 0; j < 16; j++)
+            {
+                for (int i = 0; i < 16; i++)
+                    block[k++] = patchData[j * 16 + i] * premult - sub;
+            }
+
+            float[] ftemp = new float[16 * 16];
+            int[] itemp = new int[16 * 16];
+
+            for (int o = 0; o < 16; o++)
+                DCTLine16(block, ftemp, o);
+            for (int o = 0; o < 16; o++)
+                DCTColumn16(ftemp, itemp, o);
+
+            return itemp;
+        }
+
+        private static int[] CompressPatch(float[,] patchData, TerrainPatch.Header header, int prequant)
+        {
+            float[] block = new float[16 * 16];
+            int wordsize = prequant;
+            float oozrange = 1.0f / (float)header.Range;
+            float range = (float)(1 << prequant);
+            float premult = oozrange * range;
+            float sub = (float)(1 << (prequant - 1)) + header.DCOffset * premult;
+
+            header.QuantWBits = wordsize - 2;
+            header.QuantWBits |= (prequant - 2) << 4;
+
+            int k = 0;
+            for (int j = 0; j < 16; j++)
+            {
+                for (int i = 0; i < 16; i++)
+                    block[k++] = patchData[j, i] * premult - sub;
+            }
+
+            float[] ftemp = new float[16 * 16];
+            int[] itemp = new int[16 * 16];
+
+            for (int o = 0; o < 16; o++)
+                DCTLine16(block, ftemp, o);
+            for (int o = 0; o < 16; o++)
+                DCTColumn16(ftemp, itemp, o);
+
+            return itemp;
+        }
+
+        private static int[] CompressPatch(float[] heightmap, int patchX, int patchY, TerrainPatch.Header header, int prequant)
+        {
+            float[] block = new float[16 * 16];
+            int wordsize = prequant;
+            float oozrange = 1.0f / (float)header.Range;
+            float range = (float)(1 << prequant);
+            float premult = oozrange * range;
+            float sub = (float)(1 << (prequant - 1)) + header.DCOffset * premult;
+
+            header.QuantWBits = wordsize - 2;
+            header.QuantWBits |= (prequant - 2) << 4;
+
+            int k = 0;
+            for (int j = patchY * 16; j < (patchY + 1) * 16; j++)
+            {
+                for (int i = patchX * 16; i < (patchX + 1) * 16; i++)
+                    block[k++] = heightmap[j * 256 + i] * premult - sub;
+            }
+
+            float[] ftemp = new float[16 * 16];
+            int[] itemp = new int[16 * 16];
+
+            for (int o = 0; o < 16; o++)
+                DCTLine16(block, ftemp, o);
+            for (int o = 0; o < 16; o++)
+                DCTColumn16(ftemp, itemp, o);
+
+            return itemp;
+        }
+
+
+        #region Initialization
+
+        private static void BuildDequantizeTable16()
+        {
+            for (int j = 0; j < 16; j++)
+            {
+                for (int i = 0; i < 16; i++)
+                {
+                    DequantizeTable16[j * 16 + i] = 1.0f + 2.0f * (float)(i + j);
+                }
+            }
+        }
+
+        private static void BuildQuantizeTable16()
+        {
+            for (int j = 0; j < 16; j++)
+            {
+                for (int i = 0; i < 16; i++)
+                {
+                    QuantizeTable16[j * 16 + i] = 1.0f / (1.0f + 2.0f * ((float)i + (float)j));
+                }
+            }
+        }
+
+        private static void SetupCosines16()
+        {
+            const float hposz = (float)Math.PI * 0.5f / 16.0f;
+
+            for (int u = 0; u < 16; u++)
+            {
+                for (int n = 0; n < 16; n++)
+                {
+                    CosineTable16[u * 16 + n] = (float)Math.Cos((2.0f * (float)n + 1.0f) * (float)u * hposz);
+                }
+            }
+        }
+
+        private static void BuildCopyMatrix16()
+        {
+            bool diag = false;
+            bool right = true;
+            int i = 0;
+            int j = 0;
+            int count = 0;
+
+            while (i < 16 && j < 16)
+            {
+                CopyMatrix16[j * 16 + i] = count++;
+
+                if (!diag)
+                {
+                    if (right)
+                    {
+                        if (i < 16 - 1) i++;
+                        else j++;
+
+                        right = false;
+                        diag = true;
+                    }
+                    else
+                    {
+                        if (j < 16 - 1) j++;
+                        else i++;
+
+                        right = true;
+                        diag = true;
+                    }
+                }
+                else
+                {
+                    if (right)
+                    {
+                        i++;
+                        j--;
+                        if (i == 16 - 1 || j == 0) diag = false;
+                    }
+                    else
+                    {
+                        i--;
+                        j++;
+                        if (j == 16 - 1 || i == 0) diag = false;
+                    }
+                }
+            }
+        }
+
+        #endregion Initialization
+    }
+}
Index: UDPBase.cs
===================================================================
--- UDPBase.cs	(revision 2445)
+++ UDPBase.cs	(working copy)
@@ -1,339 +1,339 @@
-/*
- * Copyright (c) 2006, Clutch, Inc.
- * Original Author: Jeff Cesnik
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Net;
-using System.Net.Sockets;
-using System.Threading;
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    public abstract class UDPBase
-    {
-        // these abstract methods must be implemented in a derived class to actually do
-        // something with the packets that are sent and received.
-        protected abstract void PacketReceived(UDPPacketBuffer buffer);
-        protected abstract void PacketSent(UDPPacketBuffer buffer, int bytesSent);
-
-        // the port to listen on
-        internal int udpPort;
-
-        // the UDP socket
-        private Socket udpSocket;
-
-        // the ReaderWriterLock is used solely for the purposes of shutdown (Stop()).
-        // since there are potentially many "reader" threads in the internal .NET IOCP
-        // thread pool, this is a cheaper synchronization primitive than using
-        // a Mutex object.  This allows many UDP socket "reads" concurrently - when
-        // Stop() is called, it attempts to obtain a writer lock which will then
-        // wait until all outstanding operations are completed before shutting down.
-        // this avoids the problem of closing the socket with outstanding operations
-        // and trying to catch the inevitable ObjectDisposedException.
-        private ReaderWriterLock rwLock = new ReaderWriterLock();
-
-        // number of outstanding operations.  This is a reference count
-        // which we use to ensure that the threads exit cleanly. Note that
-        // we need this because the threads will potentially still need to process
-        // data even after the socket is closed.
-        private int rwOperationCount = 0;
-
-        // the all important shutdownFlag.  This is synchronized through the ReaderWriterLock.
-        private volatile bool shutdownFlag = true;
-
-        // the remote endpoint to communicate with
-        protected IPEndPoint remoteEndPoint = null;
-
-
-        /// <summary>
-        /// Initialize the UDP packet handler in server mode
-        /// </summary>
-        /// <param name="port">Port to listening for incoming UDP packets on</param>
-        public UDPBase(int port)
-        {
-            udpPort = port;
-        }
-
-        /// <summary>
-        /// Initialize the UDP packet handler in client mode
-        /// </summary>
-        /// <param name="endPoint">Remote UDP server to connect to</param>
-        public UDPBase(IPEndPoint endPoint)
-        {
-            remoteEndPoint = endPoint;
-            udpPort = 0;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        public void Start()
-        {
-            if (shutdownFlag)
-            {
-                if (remoteEndPoint == null)
-                {
-                    // Server mode
-
-                    // create and bind the socket
-                    IPEndPoint ipep = new IPEndPoint(Settings.BIND_ADDR, udpPort);
-                    udpSocket = new Socket(
-                        AddressFamily.InterNetwork,
-                        SocketType.Dgram,
-                        ProtocolType.Udp);
-                    udpSocket.Bind(ipep);
-                }
-                else
-                {
-                    // Client mode
-                    IPEndPoint ipep = new IPEndPoint(Settings.BIND_ADDR, udpPort);
-                    udpSocket = new Socket(
-                        AddressFamily.InterNetwork,
-                        SocketType.Dgram,
-                        ProtocolType.Udp);
-                    udpSocket.Bind(ipep);
-                    //udpSocket.Connect(remoteEndPoint);
-                }
-
-                // we're not shutting down, we're starting up
-                shutdownFlag = false;
-
-                // kick off an async receive.  The Start() method will return, the
-                // actual receives will occur asynchronously and will be caught in
-                // AsyncEndRecieve().
-                AsyncBeginReceive();
-            }
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        public void Stop()
-        {
-            if (!shutdownFlag)
-            {
-                // wait indefinitely for a writer lock.  Once this is called, the .NET runtime
-                // will deny any more reader locks, in effect blocking all other send/receive
-                // threads.  Once we have the lock, we set shutdownFlag to inform the other
-                // threads that the socket is closed.
-                rwLock.AcquireWriterLock(-1);
-                shutdownFlag = true;
-                udpSocket.Close();
-                rwLock.ReleaseWriterLock();
-
-                // wait for any pending operations to complete on other
-                // threads before exiting.
-                const int FORCE_STOP = 100;
-                int i = 0;
-                while (rwOperationCount > 0 && i < FORCE_STOP)
-                {
-                    Thread.Sleep(10);
-                    ++i;
-                }
-
-                if (i >= FORCE_STOP)
-                {
-                    Logger.Log("UDPBase.Stop() forced shutdown while waiting on pending operations",
-                        Helpers.LogLevel.Warning);
-                }
-            }
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        public bool IsRunning
-        {
-            get { return !shutdownFlag; }
-        }
-
-        private void AsyncBeginReceive()
-        {
-            // this method actually kicks off the async read on the socket.
-            // we aquire a reader lock here to ensure that no other thread
-            // is trying to set shutdownFlag and close the socket.
-            rwLock.AcquireReaderLock(-1);
-
-            if (!shutdownFlag)
-            {
-                // increment the count of pending operations
-                Interlocked.Increment(ref rwOperationCount);
-
-                // allocate a packet buffer
-                //WrappedObject<UDPPacketBuffer> wrappedBuffer = Pool.CheckOut();
-                UDPPacketBuffer buf = new UDPPacketBuffer();
-
-                try
-                {
-                    // kick off an async read
-                    udpSocket.BeginReceiveFrom(
-                        //wrappedBuffer.Instance.Data,
-                        buf.Data,
-                        0,
-                        UDPPacketBuffer.BUFFER_SIZE,
-                        SocketFlags.None,
-                        //ref wrappedBuffer.Instance.RemoteEndPoint,
-                        ref buf.RemoteEndPoint,
-                        new AsyncCallback(AsyncEndReceive),
-                        //wrappedBuffer);
-                        buf);
-                }
-                catch (SocketException)
-                {
-                    // something bad happened
-                    //Logger.Log(
-                    //    "A SocketException occurred in UDPServer.AsyncBeginReceive()", 
-                    //    Helpers.LogLevel.Error, se);
-
-                    // an error occurred, therefore the operation is void.  Decrement the reference count.
-                    Interlocked.Decrement(ref rwOperationCount);
-                }
-            }
-
-            // we're done with the socket for now, release the reader lock.
-            rwLock.ReleaseReaderLock();
-        }
-
-        private void AsyncEndReceive(IAsyncResult iar)
-        {
-            // Asynchronous receive operations will complete here through the call
-            // to AsyncBeginReceive
-
-            // aquire a reader lock
-            rwLock.AcquireReaderLock(-1);
-
-            if (!shutdownFlag)
-            {
-                // start another receive - this keeps the server going!
-                AsyncBeginReceive();
-
-                // get the buffer that was created in AsyncBeginReceive
-                // this is the received data
-                //WrappedObject<UDPPacketBuffer> wrappedBuffer = (WrappedObject<UDPPacketBuffer>)iar.AsyncState;
-                //UDPPacketBuffer buffer = wrappedBuffer.Instance;
-                UDPPacketBuffer buffer = (UDPPacketBuffer)iar.AsyncState;
-
-                try
-                {
-                    // get the length of data actually read from the socket, store it with the
-                    // buffer
-                    buffer.DataLength = udpSocket.EndReceiveFrom(iar, ref buffer.RemoteEndPoint);
-
-                    // this operation is now complete, decrement the reference count
-                    Interlocked.Decrement(ref rwOperationCount);
-
-                    // we're done with the socket, release the reader lock
-                    rwLock.ReleaseReaderLock();
-
-                    // call the abstract method PacketReceived(), passing the buffer that
-                    // has just been filled from the socket read.
-                    PacketReceived(buffer);
-                }
-                catch (SocketException)
-                {
-                    // an error occurred, therefore the operation is void.  Decrement the reference count.
-                    Interlocked.Decrement(ref rwOperationCount);
-
-                    // we're done with the socket for now, release the reader lock.
-                    rwLock.ReleaseReaderLock();
-                }
-                finally
-                {
-                    //wrappedBuffer.Dispose();
-                }
-            }
-            else
-            {
-                // nothing bad happened, but we are done with the operation
-                // decrement the reference count and release the reader lock
-                Interlocked.Decrement(ref rwOperationCount);
-                rwLock.ReleaseReaderLock();
-            }
-        }
-
-        public void AsyncBeginSend(UDPPacketBuffer buf)
-        {
-            rwLock.AcquireReaderLock(-1);
-
-            if (!shutdownFlag)
-            {
-                try
-                {
-                    Interlocked.Increment(ref rwOperationCount);
-                    udpSocket.BeginSendTo(
-                        buf.Data,
-                        0,
-                        buf.DataLength,
-                        SocketFlags.None,
-                        buf.RemoteEndPoint,
-                        new AsyncCallback(AsyncEndSend),
-                        buf);
-                }
-                catch (SocketException)
-                {
-                    //Logger.Log(
-                    //    "A SocketException occurred in UDPServer.AsyncBeginSend()",
-                    //    Helpers.LogLevel.Error, se);
-                }
-            }
-
-            rwLock.ReleaseReaderLock();
-        }
-
-        private void AsyncEndSend(IAsyncResult iar)
-        {
-            rwLock.AcquireReaderLock(-1);
-
-            if (!shutdownFlag)
-            {
-                UDPPacketBuffer buffer = (UDPPacketBuffer)iar.AsyncState;
-
-                try
-                {
-                    int bytesSent = udpSocket.EndSendTo(iar);
-
-                    // note that call to the abstract PacketSent() method - we are passing the number
-                    // of bytes sent in a separate parameter, since we can't use buffer.DataLength which
-                    // is the number of bytes to send (or bytes received depending upon whether this
-                    // buffer was part of a send or a receive).
-                    PacketSent(buffer, bytesSent);
-                }
-                catch (SocketException)
-                {
-                    //Logger.Log(
-                    //    "A SocketException occurred in UDPServer.AsyncEndSend()",
-                    //    Helpers.LogLevel.Error, se);
-                }
-            }
-
-            Interlocked.Decrement(ref rwOperationCount);
-            rwLock.ReleaseReaderLock();
-        }
-    }
-}
+/*
+ * Copyright (c) 2006, Clutch, Inc.
+ * Original Author: Jeff Cesnik
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Net;
+using System.Net.Sockets;
+using System.Threading;
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// 
+    /// </summary>
+    public abstract class UDPBase
+    {
+        // these abstract methods must be implemented in a derived class to actually do
+        // something with the packets that are sent and received.
+        protected abstract void PacketReceived(UDPPacketBuffer buffer);
+        protected abstract void PacketSent(UDPPacketBuffer buffer, int bytesSent);
+
+        // the port to listen on
+        internal int udpPort;
+
+        // the UDP socket
+        private Socket udpSocket;
+
+        // the ReaderWriterLock is used solely for the purposes of shutdown (Stop()).
+        // since there are potentially many "reader" threads in the internal .NET IOCP
+        // thread pool, this is a cheaper synchronization primitive than using
+        // a Mutex object.  This allows many UDP socket "reads" concurrently - when
+        // Stop() is called, it attempts to obtain a writer lock which will then
+        // wait until all outstanding operations are completed before shutting down.
+        // this avoids the problem of closing the socket with outstanding operations
+        // and trying to catch the inevitable ObjectDisposedException.
+        private ReaderWriterLock rwLock = new ReaderWriterLock();
+
+        // number of outstanding operations.  This is a reference count
+        // which we use to ensure that the threads exit cleanly. Note that
+        // we need this because the threads will potentially still need to process
+        // data even after the socket is closed.
+        private int rwOperationCount = 0;
+
+        // the all important shutdownFlag.  This is synchronized through the ReaderWriterLock.
+        private volatile bool shutdownFlag = true;
+
+        // the remote endpoint to communicate with
+        protected IPEndPoint remoteEndPoint = null;
+
+
+        /// <summary>
+        /// Initialize the UDP packet handler in server mode
+        /// </summary>
+        /// <param name="port">Port to listening for incoming UDP packets on</param>
+        public UDPBase(int port)
+        {
+            udpPort = port;
+        }
+
+        /// <summary>
+        /// Initialize the UDP packet handler in client mode
+        /// </summary>
+        /// <param name="endPoint">Remote UDP server to connect to</param>
+        public UDPBase(IPEndPoint endPoint)
+        {
+            remoteEndPoint = endPoint;
+            udpPort = 0;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        public void Start()
+        {
+            if (shutdownFlag)
+            {
+                if (remoteEndPoint == null)
+                {
+                    // Server mode
+
+                    // create and bind the socket
+                    IPEndPoint ipep = new IPEndPoint(Settings.BIND_ADDR, udpPort);
+                    udpSocket = new Socket(
+                        AddressFamily.InterNetwork,
+                        SocketType.Dgram,
+                        ProtocolType.Udp);
+                    udpSocket.Bind(ipep);
+                }
+                else
+                {
+                    // Client mode
+                    IPEndPoint ipep = new IPEndPoint(Settings.BIND_ADDR, udpPort);
+                    udpSocket = new Socket(
+                        AddressFamily.InterNetwork,
+                        SocketType.Dgram,
+                        ProtocolType.Udp);
+                    udpSocket.Bind(ipep);
+                    //udpSocket.Connect(remoteEndPoint);
+                }
+
+                // we're not shutting down, we're starting up
+                shutdownFlag = false;
+
+                // kick off an async receive.  The Start() method will return, the
+                // actual receives will occur asynchronously and will be caught in
+                // AsyncEndRecieve().
+                AsyncBeginReceive();
+            }
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        public void Stop()
+        {
+            if (!shutdownFlag)
+            {
+                // wait indefinitely for a writer lock.  Once this is called, the .NET runtime
+                // will deny any more reader locks, in effect blocking all other send/receive
+                // threads.  Once we have the lock, we set shutdownFlag to inform the other
+                // threads that the socket is closed.
+                rwLock.AcquireWriterLock(-1);
+                shutdownFlag = true;
+                udpSocket.Close();
+                rwLock.ReleaseWriterLock();
+
+                // wait for any pending operations to complete on other
+                // threads before exiting.
+                const int FORCE_STOP = 100;
+                int i = 0;
+                while (rwOperationCount > 0 && i < FORCE_STOP)
+                {
+                    Thread.Sleep(10);
+                    ++i;
+                }
+
+                if (i >= FORCE_STOP)
+                {
+                    Logger.Log("UDPBase.Stop() forced shutdown while waiting on pending operations",
+                        Helpers.LogLevel.Warning);
+                }
+            }
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        public bool IsRunning
+        {
+            get { return !shutdownFlag; }
+        }
+
+        private void AsyncBeginReceive()
+        {
+            // this method actually kicks off the async read on the socket.
+            // we aquire a reader lock here to ensure that no other thread
+            // is trying to set shutdownFlag and close the socket.
+            rwLock.AcquireReaderLock(-1);
+
+            if (!shutdownFlag)
+            {
+                // increment the count of pending operations
+                Interlocked.Increment(ref rwOperationCount);
+
+                // allocate a packet buffer
+                //WrappedObject<UDPPacketBuffer> wrappedBuffer = Pool.CheckOut();
+                UDPPacketBuffer buf = new UDPPacketBuffer();
+
+                try
+                {
+                    // kick off an async read
+                    udpSocket.BeginReceiveFrom(
+                        //wrappedBuffer.Instance.Data,
+                        buf.Data,
+                        0,
+                        UDPPacketBuffer.BUFFER_SIZE,
+                        SocketFlags.None,
+                        //ref wrappedBuffer.Instance.RemoteEndPoint,
+                        ref buf.RemoteEndPoint,
+                        new AsyncCallback(AsyncEndReceive),
+                        //wrappedBuffer);
+                        buf);
+                }
+                catch (SocketException)
+                {
+                    // something bad happened
+                    //Logger.Log(
+                    //    "A SocketException occurred in UDPServer.AsyncBeginReceive()", 
+                    //    Helpers.LogLevel.Error, se);
+
+                    // an error occurred, therefore the operation is void.  Decrement the reference count.
+                    Interlocked.Decrement(ref rwOperationCount);
+                }
+            }
+
+            // we're done with the socket for now, release the reader lock.
+            rwLock.ReleaseReaderLock();
+        }
+
+        private void AsyncEndReceive(IAsyncResult iar)
+        {
+            // Asynchronous receive operations will complete here through the call
+            // to AsyncBeginReceive
+
+            // aquire a reader lock
+            rwLock.AcquireReaderLock(-1);
+
+            if (!shutdownFlag)
+            {
+                // start another receive - this keeps the server going!
+                AsyncBeginReceive();
+
+                // get the buffer that was created in AsyncBeginReceive
+                // this is the received data
+                //WrappedObject<UDPPacketBuffer> wrappedBuffer = (WrappedObject<UDPPacketBuffer>)iar.AsyncState;
+                //UDPPacketBuffer buffer = wrappedBuffer.Instance;
+                UDPPacketBuffer buffer = (UDPPacketBuffer)iar.AsyncState;
+
+                try
+                {
+                    // get the length of data actually read from the socket, store it with the
+                    // buffer
+                    buffer.DataLength = udpSocket.EndReceiveFrom(iar, ref buffer.RemoteEndPoint);
+
+                    // this operation is now complete, decrement the reference count
+                    Interlocked.Decrement(ref rwOperationCount);
+
+                    // we're done with the socket, release the reader lock
+                    rwLock.ReleaseReaderLock();
+
+                    // call the abstract method PacketReceived(), passing the buffer that
+                    // has just been filled from the socket read.
+                    PacketReceived(buffer);
+                }
+                catch (SocketException)
+                {
+                    // an error occurred, therefore the operation is void.  Decrement the reference count.
+                    Interlocked.Decrement(ref rwOperationCount);
+
+                    // we're done with the socket for now, release the reader lock.
+                    rwLock.ReleaseReaderLock();
+                }
+                finally
+                {
+                    //wrappedBuffer.Dispose();
+                }
+            }
+            else
+            {
+                // nothing bad happened, but we are done with the operation
+                // decrement the reference count and release the reader lock
+                Interlocked.Decrement(ref rwOperationCount);
+                rwLock.ReleaseReaderLock();
+            }
+        }
+
+        public void AsyncBeginSend(UDPPacketBuffer buf)
+        {
+            rwLock.AcquireReaderLock(-1);
+
+            if (!shutdownFlag)
+            {
+                try
+                {
+                    Interlocked.Increment(ref rwOperationCount);
+                    udpSocket.BeginSendTo(
+                        buf.Data,
+                        0,
+                        buf.DataLength,
+                        SocketFlags.None,
+                        buf.RemoteEndPoint,
+                        new AsyncCallback(AsyncEndSend),
+                        buf);
+                }
+                catch (SocketException)
+                {
+                    //Logger.Log(
+                    //    "A SocketException occurred in UDPServer.AsyncBeginSend()",
+                    //    Helpers.LogLevel.Error, se);
+                }
+            }
+
+            rwLock.ReleaseReaderLock();
+        }
+
+        private void AsyncEndSend(IAsyncResult iar)
+        {
+            rwLock.AcquireReaderLock(-1);
+
+            if (!shutdownFlag)
+            {
+                UDPPacketBuffer buffer = (UDPPacketBuffer)iar.AsyncState;
+
+                try
+                {
+                    int bytesSent = udpSocket.EndSendTo(iar);
+
+                    // note that call to the abstract PacketSent() method - we are passing the number
+                    // of bytes sent in a separate parameter, since we can't use buffer.DataLength which
+                    // is the number of bytes to send (or bytes received depending upon whether this
+                    // buffer was part of a send or a receive).
+                    PacketSent(buffer, bytesSent);
+                }
+                catch (SocketException)
+                {
+                    //Logger.Log(
+                    //    "A SocketException occurred in UDPServer.AsyncEndSend()",
+                    //    Helpers.LogLevel.Error, se);
+                }
+            }
+
+            Interlocked.Decrement(ref rwOperationCount);
+            rwLock.ReleaseReaderLock();
+        }
+    }
+}
Index: TextureCache.cs
===================================================================
--- TextureCache.cs	(revision 2445)
+++ TextureCache.cs	(working copy)
@@ -1,370 +1,370 @@
-/*
- * Copyright (c) 2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Threading;
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// Class that handles the local image cache
-    /// </summary>
-    public class TextureCache
-    {
-        private GridClient Client;
-        private Thread cleanerThread;
-        private System.Timers.Timer cleanerTimer;
-        private double pruneInterval = 1000 * 60 * 5;
-
-        /// <summary>
-        /// Allows setting weather to periodicale prune the cache if it grows too big
-        /// Default is enabled, when caching is enabled
-        /// </summary>
-        public bool AutoPruneEnabled
-        {
-            set
-            {
-                if (!Operational())
-                {
-                    return;
-                }
-                else
-                {
-                    cleanerTimer.Enabled = value;
-                }
-            }
-            get { return cleanerTimer.Enabled; }
-        }
-
-        /// <summary>
-        /// How long (in ms) between cache checks (default is 5 min.) 
-        /// </summary>
-        public double AutoPruneInterval
-        {
-            get { return pruneInterval; }
-            set
-            {
-                pruneInterval = value;
-                cleanerTimer.Interval = pruneInterval;
-            }
-        }
-
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        /// <param name="client">A reference to the GridClient object</param>
-        public TextureCache(GridClient client)
-        {
-            Client = client;
-            cleanerTimer = new System.Timers.Timer(pruneInterval);
-            cleanerTimer.Elapsed += new System.Timers.ElapsedEventHandler(cleanerTimer_Elapsed);
-            if (Operational())
-            {
-                cleanerTimer.Enabled = true;
-            }
-            else
-            {
-                cleanerTimer.Enabled = false;
-            }
-        }
-
-        /// <summary>
-        /// Return bytes read from the local image cache, null if it does not exist
-        /// </summary>
-        /// <param name="imageID">UUID of the image we want to get</param>
-        /// <returns>Raw bytes of the image, or null on failure</returns>
-        public byte[] GetCachedImageBytes(UUID imageID)
-        {
-            if (!Operational())
-            {
-                return null;
-            }
-            try
-            {
-                Logger.DebugLog("Reading " + FileName(imageID) + " from texture cache.");
-                byte[] data = File.ReadAllBytes(FileName(imageID));
-                return data;
-            }
-            catch (Exception ex)
-            {
-                Logger.Log("Failed reading image from cache (" + ex.Message + ")", Helpers.LogLevel.Warning, Client);
-                return null;
-            }
-        }
-
-        /// <summary>
-        /// Returns ImageDownload object of the
-        /// image from the local image cache, null if it does not exist
-        /// </summary>
-        /// <param name="imageID">UUID of the image we want to get</param>
-        /// <returns>ImageDownload object containing the image, or null on failure</returns>
-        public ImageDownload GetCachedImage(UUID imageID)
-        {
-            if (!Operational())
-                return null;
-
-            byte[] imageData = GetCachedImageBytes(imageID);
-            if (imageData == null)
-                return null;
-            ImageDownload transfer = new ImageDownload();
-            transfer.AssetType = AssetType.Texture;
-            transfer.ID = imageID;
-            transfer.Simulator = Client.Network.CurrentSim;
-            transfer.Size = imageData.Length;
-            transfer.Success = true;
-            transfer.Transferred = imageData.Length;
-            transfer.AssetData = imageData;
-            return transfer;
-        }
-
-        /// <summary>
-        /// Constructs a file name of the cached image
-        /// </summary>
-        /// <param name="imageID">UUID of the image</param>
-        /// <returns>String with the file name of the cahced image</returns>
-        private string FileName(UUID imageID)
-        {
-            return Client.Settings.TEXTURE_CACHE_DIR + Path.DirectorySeparatorChar + imageID.ToString();
-        }
-
-        /// <summary>
-        /// Saves an image to the local cache
-        /// </summary>
-        /// <param name="imageID">UUID of the image</param>
-        /// <param name="imageData">Raw bytes the image consists of</param>
-        /// <returns>Weather the operation was successfull</returns>
-        public bool SaveImageToCache(UUID imageID, byte[] imageData)
-        {
-            if (!Operational())
-            {
-                return false;
-            }
-
-            try
-            {
-                Logger.DebugLog("Saving " + FileName(imageID) + " to texture cache.", Client);
-
-                if (!Directory.Exists(Client.Settings.TEXTURE_CACHE_DIR))
-                {
-                    Directory.CreateDirectory(Client.Settings.TEXTURE_CACHE_DIR);
-                }
-
-                File.WriteAllBytes(FileName(imageID), imageData);
-            }
-            catch (Exception ex)
-            {
-                Logger.Log("Failed saving image to cache (" + ex.Message + ")", Helpers.LogLevel.Warning, Client);
-                return false;
-            }
-
-            return true;
-        }
-
-        /// <summary>
-        /// Get the file name of the asset stored with gived UUID
-        /// </summary>
-        /// <param name="imageID">UUID of the image</param>
-        /// <returns>Null if we don't have that UUID cached on disk, file name if found in the cache folder</returns>
-        public string ImageFileName(UUID imageID)
-        {
-            if (!Operational())
-            {
-                return null;
-            }
-
-            string fileName = FileName(imageID);
-
-            if (File.Exists(fileName))
-                return fileName;
-            else
-                return null;
-        }
-
-        /// <summary>
-        /// Checks if the image exists in the local cache
-        /// </summary>
-        /// <param name="imageID">UUID of the image</param>
-        /// <returns>True is the image is stored in the cache, otherwise false</returns>
-        public bool HasImage(UUID imageID)
-        {
-            if (!Operational())
-                return false;
-            else
-                return File.Exists(FileName(imageID));
-        }
-
-        /// <summary>
-        /// Wipes out entire cache
-        /// </summary>
-        public void Clear()
-        {
-            string cacheDir = Client.Settings.TEXTURE_CACHE_DIR;
-            if (!Directory.Exists(cacheDir))
-            {
-                return;
-            }
-
-            DirectoryInfo di = new DirectoryInfo(cacheDir);
-            // We save file with UUID as file name, only delete those
-            FileInfo[] files = di.GetFiles("????????-????-????-????-????????????", SearchOption.TopDirectoryOnly);
-
-            int num = 0;
-            foreach (FileInfo file in files)
-            {
-                file.Delete();
-                ++num;
-            }
-
-            Logger.Log("Wiped out " + num + " files from the cache directory.", Helpers.LogLevel.Debug);
-        }
-
-        /// <summary>
-        /// Brings cache size to the 90% of the max size
-        /// </summary>
-        public void Prune()
-        {
-            string cacheDir = Client.Settings.TEXTURE_CACHE_DIR;
-            if (!Directory.Exists(cacheDir))
-            {
-                return;
-            }
-            DirectoryInfo di = new DirectoryInfo(cacheDir);
-            // We save file with UUID as file name, only count those
-            FileInfo[] files = di.GetFiles("????????-????-????-????-????????????", SearchOption.TopDirectoryOnly);
-
-            long size = GetFileSize(files);
-
-            if (size > Client.Settings.TEXTURE_CACHE_MAX_SIZE)
-            {
-                Array.Sort(files, new SortFilesByAccesTimeHelper());
-                long targetSize = (long)(Client.Settings.TEXTURE_CACHE_MAX_SIZE * 0.9);
-                int num = 0;
-                foreach (FileInfo file in files)
-                {
-                    ++num;
-                    size -= file.Length;
-                    file.Delete();
-                    if (size < targetSize)
-                    {
-                        break;
-                    }
-                }
-                Logger.Log(num + " files deleted from the cache, cache size now: " + NiceFileSize(size), Helpers.LogLevel.Debug);
-            }
-            else
-            {
-                Logger.Log("Cache size is " + NiceFileSize(size) + ", file deletion not needed", Helpers.LogLevel.Debug);
-            }
-
-        }
-
-        /// <summary>
-        /// Asynchronously brings cache size to the 90% of the max size
-        /// </summary>
-        public void BeginPrune()
-        {
-            // Check if the background cache cleaning thread is active first
-            if (cleanerThread != null && cleanerThread.IsAlive)
-            {
-                return;
-            }
-
-            lock (this)
-            {
-                cleanerThread = new Thread(new ThreadStart(this.Prune));
-                cleanerThread.IsBackground = true;
-                cleanerThread.Start();
-            }
-        }
-
-        /// <summary>
-        /// Adds up file sizes passes in a FileInfo array
-        /// </summary>
-        long GetFileSize(FileInfo[] files)
-        {
-            long ret = 0;
-            foreach (FileInfo file in files)
-            {
-                ret += file.Length;
-            }
-            return ret;
-        }
-
-        /// <summary>
-        /// Checks whether caching is enabled
-        /// </summary>
-        private bool Operational()
-        {
-            return Client.Settings.USE_TEXTURE_CACHE;
-        }
-
-        /// <summary>
-        /// Periodically prune the cache
-        /// </summary>
-        private void cleanerTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
-        {
-            BeginPrune();
-        }
-
-        /// <summary>
-        /// Nicely formats file sizes
-        /// </summary>
-        /// <param name="byteCount">Byte size we want to output</param>
-        /// <returns>String with humanly readable file size</returns>
-        private string NiceFileSize(long byteCount)
-        {
-            string size = "0 Bytes";
-            if (byteCount >= 1073741824)
-                size = String.Format("{0:##.##}", byteCount / 1073741824) + " GB";
-            else if (byteCount >= 1048576)
-                size = String.Format("{0:##.##}", byteCount / 1048576) + " MB";
-            else if (byteCount >= 1024)
-                size = String.Format("{0:##.##}", byteCount / 1024) + " KB";
-            else if (byteCount > 0 && byteCount < 1024)
-                size = byteCount.ToString() + " Bytes";
-
-            return size;
-        }
-
-        /// <summary>
-        /// Helper class for sorting files by their last accessed time
-        /// </summary>
-        private class SortFilesByAccesTimeHelper : IComparer<FileInfo>
-        {
-            int IComparer<FileInfo>.Compare(FileInfo f1, FileInfo f2)
-            {
-                if (f1.LastAccessTime > f2.LastAccessTime)
-                    return 1;
-                if (f1.LastAccessTime < f2.LastAccessTime)
-                    return -1;
-                else
-                    return 0;
-            }
-        }
-    }
-}
+/*
+ * Copyright (c) 2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Threading;
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// Class that handles the local image cache
+    /// </summary>
+    public class TextureCache
+    {
+        private GridClient Client;
+        private Thread cleanerThread;
+        private System.Timers.Timer cleanerTimer;
+        private double pruneInterval = 1000 * 60 * 5;
+
+        /// <summary>
+        /// Allows setting weather to periodicale prune the cache if it grows too big
+        /// Default is enabled, when caching is enabled
+        /// </summary>
+        public bool AutoPruneEnabled
+        {
+            set
+            {
+                if (!Operational())
+                {
+                    return;
+                }
+                else
+                {
+                    cleanerTimer.Enabled = value;
+                }
+            }
+            get { return cleanerTimer.Enabled; }
+        }
+
+        /// <summary>
+        /// How long (in ms) between cache checks (default is 5 min.) 
+        /// </summary>
+        public double AutoPruneInterval
+        {
+            get { return pruneInterval; }
+            set
+            {
+                pruneInterval = value;
+                cleanerTimer.Interval = pruneInterval;
+            }
+        }
+
+        /// <summary>
+        /// Default constructor
+        /// </summary>
+        /// <param name="client">A reference to the GridClient object</param>
+        public TextureCache(GridClient client)
+        {
+            Client = client;
+            cleanerTimer = new System.Timers.Timer(pruneInterval);
+            cleanerTimer.Elapsed += new System.Timers.ElapsedEventHandler(cleanerTimer_Elapsed);
+            if (Operational())
+            {
+                cleanerTimer.Enabled = true;
+            }
+            else
+            {
+                cleanerTimer.Enabled = false;
+            }
+        }
+
+        /// <summary>
+        /// Return bytes read from the local image cache, null if it does not exist
+        /// </summary>
+        /// <param name="imageID">UUID of the image we want to get</param>
+        /// <returns>Raw bytes of the image, or null on failure</returns>
+        public byte[] GetCachedImageBytes(UUID imageID)
+        {
+            if (!Operational())
+            {
+                return null;
+            }
+            try
+            {
+                Logger.DebugLog("Reading " + FileName(imageID) + " from texture cache.");
+                byte[] data = File.ReadAllBytes(FileName(imageID));
+                return data;
+            }
+            catch (Exception ex)
+            {
+                Logger.Log("Failed reading image from cache (" + ex.Message + ")", Helpers.LogLevel.Warning, Client);
+                return null;
+            }
+        }
+
+        /// <summary>
+        /// Returns ImageDownload object of the
+        /// image from the local image cache, null if it does not exist
+        /// </summary>
+        /// <param name="imageID">UUID of the image we want to get</param>
+        /// <returns>ImageDownload object containing the image, or null on failure</returns>
+        public ImageDownload GetCachedImage(UUID imageID)
+        {
+            if (!Operational())
+                return null;
+
+            byte[] imageData = GetCachedImageBytes(imageID);
+            if (imageData == null)
+                return null;
+            ImageDownload transfer = new ImageDownload();
+            transfer.AssetType = AssetType.Texture;
+            transfer.ID = imageID;
+            transfer.Simulator = Client.Network.CurrentSim;
+            transfer.Size = imageData.Length;
+            transfer.Success = true;
+            transfer.Transferred = imageData.Length;
+            transfer.AssetData = imageData;
+            return transfer;
+        }
+
+        /// <summary>
+        /// Constructs a file name of the cached image
+        /// </summary>
+        /// <param name="imageID">UUID of the image</param>
+        /// <returns>String with the file name of the cahced image</returns>
+        private string FileName(UUID imageID)
+        {
+            return Client.Settings.TEXTURE_CACHE_DIR + Path.DirectorySeparatorChar + imageID.ToString();
+        }
+
+        /// <summary>
+        /// Saves an image to the local cache
+        /// </summary>
+        /// <param name="imageID">UUID of the image</param>
+        /// <param name="imageData">Raw bytes the image consists of</param>
+        /// <returns>Weather the operation was successfull</returns>
+        public bool SaveImageToCache(UUID imageID, byte[] imageData)
+        {
+            if (!Operational())
+            {
+                return false;
+            }
+
+            try
+            {
+                Logger.DebugLog("Saving " + FileName(imageID) + " to texture cache.", Client);
+
+                if (!Directory.Exists(Client.Settings.TEXTURE_CACHE_DIR))
+                {
+                    Directory.CreateDirectory(Client.Settings.TEXTURE_CACHE_DIR);
+                }
+
+                File.WriteAllBytes(FileName(imageID), imageData);
+            }
+            catch (Exception ex)
+            {
+                Logger.Log("Failed saving image to cache (" + ex.Message + ")", Helpers.LogLevel.Warning, Client);
+                return false;
+            }
+
+            return true;
+        }
+
+        /// <summary>
+        /// Get the file name of the asset stored with gived UUID
+        /// </summary>
+        /// <param name="imageID">UUID of the image</param>
+        /// <returns>Null if we don't have that UUID cached on disk, file name if found in the cache folder</returns>
+        public string ImageFileName(UUID imageID)
+        {
+            if (!Operational())
+            {
+                return null;
+            }
+
+            string fileName = FileName(imageID);
+
+            if (File.Exists(fileName))
+                return fileName;
+            else
+                return null;
+        }
+
+        /// <summary>
+        /// Checks if the image exists in the local cache
+        /// </summary>
+        /// <param name="imageID">UUID of the image</param>
+        /// <returns>True is the image is stored in the cache, otherwise false</returns>
+        public bool HasImage(UUID imageID)
+        {
+            if (!Operational())
+                return false;
+            else
+                return File.Exists(FileName(imageID));
+        }
+
+        /// <summary>
+        /// Wipes out entire cache
+        /// </summary>
+        public void Clear()
+        {
+            string cacheDir = Client.Settings.TEXTURE_CACHE_DIR;
+            if (!Directory.Exists(cacheDir))
+            {
+                return;
+            }
+
+            DirectoryInfo di = new DirectoryInfo(cacheDir);
+            // We save file with UUID as file name, only delete those
+            FileInfo[] files = di.GetFiles("????????-????-????-????-????????????", SearchOption.TopDirectoryOnly);
+
+            int num = 0;
+            foreach (FileInfo file in files)
+            {
+                file.Delete();
+                ++num;
+            }
+
+            Logger.Log("Wiped out " + num + " files from the cache directory.", Helpers.LogLevel.Debug);
+        }
+
+        /// <summary>
+        /// Brings cache size to the 90% of the max size
+        /// </summary>
+        public void Prune()
+        {
+            string cacheDir = Client.Settings.TEXTURE_CACHE_DIR;
+            if (!Directory.Exists(cacheDir))
+            {
+                return;
+            }
+            DirectoryInfo di = new DirectoryInfo(cacheDir);
+            // We save file with UUID as file name, only count those
+            FileInfo[] files = di.GetFiles("????????-????-????-????-????????????", SearchOption.TopDirectoryOnly);
+
+            long size = GetFileSize(files);
+
+            if (size > Client.Settings.TEXTURE_CACHE_MAX_SIZE)
+            {
+                Array.Sort(files, new SortFilesByAccesTimeHelper());
+                long targetSize = (long)(Client.Settings.TEXTURE_CACHE_MAX_SIZE * 0.9);
+                int num = 0;
+                foreach (FileInfo file in files)
+                {
+                    ++num;
+                    size -= file.Length;
+                    file.Delete();
+                    if (size < targetSize)
+                    {
+                        break;
+                    }
+                }
+                Logger.Log(num + " files deleted from the cache, cache size now: " + NiceFileSize(size), Helpers.LogLevel.Debug);
+            }
+            else
+            {
+                Logger.Log("Cache size is " + NiceFileSize(size) + ", file deletion not needed", Helpers.LogLevel.Debug);
+            }
+
+        }
+
+        /// <summary>
+        /// Asynchronously brings cache size to the 90% of the max size
+        /// </summary>
+        public void BeginPrune()
+        {
+            // Check if the background cache cleaning thread is active first
+            if (cleanerThread != null && cleanerThread.IsAlive)
+            {
+                return;
+            }
+
+            lock (this)
+            {
+                cleanerThread = new Thread(new ThreadStart(this.Prune));
+                cleanerThread.IsBackground = true;
+                cleanerThread.Start();
+            }
+        }
+
+        /// <summary>
+        /// Adds up file sizes passes in a FileInfo array
+        /// </summary>
+        long GetFileSize(FileInfo[] files)
+        {
+            long ret = 0;
+            foreach (FileInfo file in files)
+            {
+                ret += file.Length;
+            }
+            return ret;
+        }
+
+        /// <summary>
+        /// Checks whether caching is enabled
+        /// </summary>
+        private bool Operational()
+        {
+            return Client.Settings.USE_TEXTURE_CACHE;
+        }
+
+        /// <summary>
+        /// Periodically prune the cache
+        /// </summary>
+        private void cleanerTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
+        {
+            BeginPrune();
+        }
+
+        /// <summary>
+        /// Nicely formats file sizes
+        /// </summary>
+        /// <param name="byteCount">Byte size we want to output</param>
+        /// <returns>String with humanly readable file size</returns>
+        private string NiceFileSize(long byteCount)
+        {
+            string size = "0 Bytes";
+            if (byteCount >= 1073741824)
+                size = String.Format("{0:##.##}", byteCount / 1073741824) + " GB";
+            else if (byteCount >= 1048576)
+                size = String.Format("{0:##.##}", byteCount / 1048576) + " MB";
+            else if (byteCount >= 1024)
+                size = String.Format("{0:##.##}", byteCount / 1024) + " KB";
+            else if (byteCount > 0 && byteCount < 1024)
+                size = byteCount.ToString() + " Bytes";
+
+            return size;
+        }
+
+        /// <summary>
+        /// Helper class for sorting files by their last accessed time
+        /// </summary>
+        private class SortFilesByAccesTimeHelper : IComparer<FileInfo>
+        {
+            int IComparer<FileInfo>.Compare(FileInfo f1, FileInfo f2)
+            {
+                if (f1.LastAccessTime > f2.LastAccessTime)
+                    return 1;
+                if (f1.LastAccessTime < f2.LastAccessTime)
+                    return -1;
+                else
+                    return 0;
+            }
+        }
+    }
+}
Index: Caps.cs
===================================================================
--- Caps.cs	(revision 2445)
+++ Caps.cs	(working copy)
@@ -1,204 +1,204 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-using System.Threading;
-using OpenMetaverse.StructuredData;
-using OpenMetaverse.Http;
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// Capabilities is the name of the bi-directional HTTP REST protocol
-    /// used to communicate non real-time transactions such as teleporting or
-    /// group messaging
-    /// </summary>
-    public class Caps
-    {
-        /// <summary>
-        /// Triggered when an event is received via the EventQueueGet 
-        /// capability
-        /// </summary>
-        /// <param name="message">Event name</param>
-        /// <param name="body">Decoded event data</param>
-        /// <param name="simulator">The simulator that generated the event</param>
-        public delegate void EventQueueCallback(string message, StructuredData.OSD body, Simulator simulator);
-
-        /// <summary>Reference to the simulator this system is connected to</summary>
-        public Simulator Simulator;
-
-        internal string _SeedCapsURI;
-        internal Dictionary<string, Uri> _Caps = new Dictionary<string, Uri>();
-
-        private CapsClient _SeedRequest;
-        private EventQueueClient _EventQueueCap = null;
-
-        /// <summary>Capabilities URI this system was initialized with</summary>
-        public string SeedCapsURI { get { return _SeedCapsURI; } }
-
-        /// <summary>Whether the capabilities event queue is connected and
-        /// listening for incoming events</summary>
-        public bool IsEventQueueRunning
-        {
-            get
-            {
-                if (_EventQueueCap != null)
-                    return _EventQueueCap.Running;
-                else
-                    return false;
-            }
-        }
-
-
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        /// <param name="simulator"></param>
-        /// <param name="seedcaps"></param>
-        internal Caps(Simulator simulator, string seedcaps)
-        {
-            Simulator = simulator;
-            _SeedCapsURI = seedcaps;
-
-            MakeSeedRequest();
-        }
-
-        public void Disconnect(bool immediate)
-        {
-            Logger.Log(String.Format("Caps system for {0} is {1}", Simulator,
-                (immediate ? "aborting" : "disconnecting")), Helpers.LogLevel.Info, Simulator.Client);
-
-            if (_SeedRequest != null)
-                _SeedRequest.Cancel();
-
-            if (_EventQueueCap != null)
-                _EventQueueCap.Stop(immediate);
-        }
-
-        /// <summary>
-        /// Request the URI of a named capability
-        /// </summary>
-        /// <param name="capability">Name of the capability to request</param>
-        /// <returns>The URI of the requested capability, or String.Empty if
-        /// the capability does not exist</returns>
-        public Uri CapabilityURI(string capability)
-        {
-            Uri cap;
-
-            if (_Caps.TryGetValue(capability, out cap))
-                return cap;
-            else
-                return null;
-        }
-
-        private void MakeSeedRequest()
-        {
-            if (Simulator == null || !Simulator.Client.Network.Connected)
-                return;
-
-            // Create a request list
-            OSDArray req = new OSDArray();
-            req.Add("ChatSessionRequest");
-            req.Add("CopyInventoryFromNotecard");
-            req.Add("DispatchRegionInfo");
-            req.Add("EstateChangeInfo");
-            req.Add("EventQueueGet");
-            req.Add("FetchInventoryDescendents");
-            req.Add("GroupProposalBallot");
-            req.Add("MapLayer");
-            req.Add("MapLayerGod");
-            req.Add("NewFileAgentInventory");
-            req.Add("ParcelPropertiesUpdate");
-            req.Add("ParcelVoiceInfoRequest");
-            req.Add("ProvisionVoiceAccountRequest");
-            req.Add("RemoteParcelRequest");
-            req.Add("RequestTextureDownload");
-            req.Add("SearchStatRequest");
-            req.Add("SearchStatTracking");
-            req.Add("SendPostcard");
-            req.Add("SendUserReport");
-            req.Add("SendUserReportWithScreenshot");
-            req.Add("ServerReleaseNotes");
-            req.Add("StartGroupProposal");
-            req.Add("UpdateGestureAgentInventory");
-            req.Add("UpdateNotecardAgentInventory");
-            req.Add("UpdateScriptAgent");
-            req.Add("UpdateGestureTaskInventory");
-            req.Add("UpdateNotecardTaskInventory");
-            req.Add("UpdateScriptTask");
-            req.Add("ViewerStartAuction");
-            req.Add("UntrustedSimulatorMessage");
-            req.Add("ViewerStats");
-
-            _SeedRequest = new CapsClient(new Uri(_SeedCapsURI));
-            _SeedRequest.OnComplete += new CapsClient.CompleteCallback(SeedRequestCompleteHandler);
-            _SeedRequest.StartRequest(req);
-        }
-
-        private void SeedRequestCompleteHandler(CapsClient client, OSD result, Exception error)
-        {
-            if (result != null && result.Type == OSDType.Map)
-            {
-                OSDMap respTable = (OSDMap)result;
-
-                foreach (string cap in respTable.Keys)
-                {
-                    _Caps[cap] = respTable[cap].AsUri();
-                }
-
-                if (_Caps.ContainsKey("EventQueueGet"))
-                {
-                    Logger.DebugLog("Starting event queue for " + Simulator.ToString(), Simulator.Client);
-
-                    _EventQueueCap = new EventQueueClient(_Caps["EventQueueGet"]);
-                    _EventQueueCap.OnConnected += EventQueueConnectedHandler;
-                    _EventQueueCap.OnEvent += EventQueueEventHandler;
-                    _EventQueueCap.Start();
-                }
-            }
-            else
-            {
-                // The initial CAPS connection failed, try again
-                MakeSeedRequest();
-            }
-        }
-
-        private void EventQueueConnectedHandler()
-        {
-            Simulator.Client.Network.RaiseConnectedEvent(Simulator);
-        }
-
-        private void EventQueueEventHandler(string eventName, OSDMap body)
-        {
-            if (Simulator.Client.Settings.SYNC_PACKETCALLBACKS)
-                Simulator.Client.Network.CapsEvents.RaiseEvent(eventName, body, Simulator);
-            else
-                Simulator.Client.Network.CapsEvents.BeginRaiseEvent(eventName, body, Simulator);
-        }
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Threading;
+using OpenMetaverse.StructuredData;
+using OpenMetaverse.Http;
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// Capabilities is the name of the bi-directional HTTP REST protocol
+    /// used to communicate non real-time transactions such as teleporting or
+    /// group messaging
+    /// </summary>
+    public class Caps
+    {
+        /// <summary>
+        /// Triggered when an event is received via the EventQueueGet 
+        /// capability
+        /// </summary>
+        /// <param name="message">Event name</param>
+        /// <param name="body">Decoded event data</param>
+        /// <param name="simulator">The simulator that generated the event</param>
+        public delegate void EventQueueCallback(string message, StructuredData.OSD body, Simulator simulator);
+
+        /// <summary>Reference to the simulator this system is connected to</summary>
+        public Simulator Simulator;
+
+        internal string _SeedCapsURI;
+        internal Dictionary<string, Uri> _Caps = new Dictionary<string, Uri>();
+
+        private CapsClient _SeedRequest;
+        private EventQueueClient _EventQueueCap = null;
+
+        /// <summary>Capabilities URI this system was initialized with</summary>
+        public string SeedCapsURI { get { return _SeedCapsURI; } }
+
+        /// <summary>Whether the capabilities event queue is connected and
+        /// listening for incoming events</summary>
+        public bool IsEventQueueRunning
+        {
+            get
+            {
+                if (_EventQueueCap != null)
+                    return _EventQueueCap.Running;
+                else
+                    return false;
+            }
+        }
+
+
+        /// <summary>
+        /// Default constructor
+        /// </summary>
+        /// <param name="simulator"></param>
+        /// <param name="seedcaps"></param>
+        internal Caps(Simulator simulator, string seedcaps)
+        {
+            Simulator = simulator;
+            _SeedCapsURI = seedcaps;
+
+            MakeSeedRequest();
+        }
+
+        public void Disconnect(bool immediate)
+        {
+            Logger.Log(String.Format("Caps system for {0} is {1}", Simulator,
+                (immediate ? "aborting" : "disconnecting")), Helpers.LogLevel.Info, Simulator.Client);
+
+            if (_SeedRequest != null)
+                _SeedRequest.Cancel();
+
+            if (_EventQueueCap != null)
+                _EventQueueCap.Stop(immediate);
+        }
+
+        /// <summary>
+        /// Request the URI of a named capability
+        /// </summary>
+        /// <param name="capability">Name of the capability to request</param>
+        /// <returns>The URI of the requested capability, or String.Empty if
+        /// the capability does not exist</returns>
+        public Uri CapabilityURI(string capability)
+        {
+            Uri cap;
+
+            if (_Caps.TryGetValue(capability, out cap))
+                return cap;
+            else
+                return null;
+        }
+
+        private void MakeSeedRequest()
+        {
+            if (Simulator == null || !Simulator.Client.Network.Connected)
+                return;
+
+            // Create a request list
+            OSDArray req = new OSDArray();
+            req.Add("ChatSessionRequest");
+            req.Add("CopyInventoryFromNotecard");
+            req.Add("DispatchRegionInfo");
+            req.Add("EstateChangeInfo");
+            req.Add("EventQueueGet");
+            req.Add("FetchInventoryDescendents");
+            req.Add("GroupProposalBallot");
+            req.Add("MapLayer");
+            req.Add("MapLayerGod");
+            req.Add("NewFileAgentInventory");
+            req.Add("ParcelPropertiesUpdate");
+            req.Add("ParcelVoiceInfoRequest");
+            req.Add("ProvisionVoiceAccountRequest");
+            req.Add("RemoteParcelRequest");
+            req.Add("RequestTextureDownload");
+            req.Add("SearchStatRequest");
+            req.Add("SearchStatTracking");
+            req.Add("SendPostcard");
+            req.Add("SendUserReport");
+            req.Add("SendUserReportWithScreenshot");
+            req.Add("ServerReleaseNotes");
+            req.Add("StartGroupProposal");
+            req.Add("UpdateGestureAgentInventory");
+            req.Add("UpdateNotecardAgentInventory");
+            req.Add("UpdateScriptAgent");
+            req.Add("UpdateGestureTaskInventory");
+            req.Add("UpdateNotecardTaskInventory");
+            req.Add("UpdateScriptTask");
+            req.Add("ViewerStartAuction");
+            req.Add("UntrustedSimulatorMessage");
+            req.Add("ViewerStats");
+
+            _SeedRequest = new CapsClient(new Uri(_SeedCapsURI));
+            _SeedRequest.OnComplete += new CapsClient.CompleteCallback(SeedRequestCompleteHandler);
+            _SeedRequest.StartRequest(req);
+        }
+
+        private void SeedRequestCompleteHandler(CapsClient client, OSD result, Exception error)
+        {
+            if (result != null && result.Type == OSDType.Map)
+            {
+                OSDMap respTable = (OSDMap)result;
+
+                foreach (string cap in respTable.Keys)
+                {
+                    _Caps[cap] = respTable[cap].AsUri();
+                }
+
+                if (_Caps.ContainsKey("EventQueueGet"))
+                {
+                    Logger.DebugLog("Starting event queue for " + Simulator.ToString(), Simulator.Client);
+
+                    _EventQueueCap = new EventQueueClient(_Caps["EventQueueGet"]);
+                    _EventQueueCap.OnConnected += EventQueueConnectedHandler;
+                    _EventQueueCap.OnEvent += EventQueueEventHandler;
+                    _EventQueueCap.Start();
+                }
+            }
+            else
+            {
+                // The initial CAPS connection failed, try again
+                MakeSeedRequest();
+            }
+        }
+
+        private void EventQueueConnectedHandler()
+        {
+            Simulator.Client.Network.RaiseConnectedEvent(Simulator);
+        }
+
+        private void EventQueueEventHandler(string eventName, OSDMap body)
+        {
+            if (Simulator.Client.Settings.SYNC_PACKETCALLBACKS)
+                Simulator.Client.Network.CapsEvents.RaiseEvent(eventName, body, Simulator);
+            else
+                Simulator.Client.Network.CapsEvents.BeginRaiseEvent(eventName, body, Simulator);
+        }
+    }
+}
Index: InventoryNodeDictionary.cs
===================================================================
--- InventoryNodeDictionary.cs	(revision 2445)
+++ InventoryNodeDictionary.cs	(working copy)
@@ -1,83 +1,83 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-
-namespace OpenMetaverse
-{
-    public class InventoryNodeDictionary
-    {
-        protected Dictionary<UUID, InventoryNode> Dictionary = new Dictionary<UUID, InventoryNode>();
-        protected InventoryNode parent;
-        protected object syncRoot = new object();
-
-        public InventoryNode Parent
-        {
-            get { return parent; }
-            set { parent = value; }
-        }
-
-        public object SyncRoot { get { return syncRoot; } }
-
-        public int Count { get { return Dictionary.Count; } }
-
-        public InventoryNodeDictionary(InventoryNode parentNode)
-        {
-            parent = parentNode;
-        }
-
-        public InventoryNode this[UUID key]
-        {
-            get { return (InventoryNode)this.Dictionary[key]; }
-            set
-            {
-                value.Parent = parent;
-                lock (syncRoot) this.Dictionary[key] = value;
-            }
-        }
-
-        public ICollection<UUID> Keys { get { return this.Dictionary.Keys; } }
-        public ICollection<InventoryNode> Values { get { return this.Dictionary.Values; } }
-
-        public void Add(UUID key, InventoryNode value)
-        {
-            value.Parent = parent;
-            lock (syncRoot) this.Dictionary.Add(key, value); 
-        }
-
-        public void Remove(UUID key)
-        {
-            lock (syncRoot) this.Dictionary.Remove(key);
-        }
-
-        public bool Contains(UUID key)
-        {
-            return this.Dictionary.ContainsKey(key);
-        }
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace OpenMetaverse
+{
+    public class InventoryNodeDictionary
+    {
+        protected Dictionary<UUID, InventoryNode> Dictionary = new Dictionary<UUID, InventoryNode>();
+        protected InventoryNode parent;
+        protected object syncRoot = new object();
+
+        public InventoryNode Parent
+        {
+            get { return parent; }
+            set { parent = value; }
+        }
+
+        public object SyncRoot { get { return syncRoot; } }
+
+        public int Count { get { return Dictionary.Count; } }
+
+        public InventoryNodeDictionary(InventoryNode parentNode)
+        {
+            parent = parentNode;
+        }
+
+        public InventoryNode this[UUID key]
+        {
+            get { return (InventoryNode)this.Dictionary[key]; }
+            set
+            {
+                value.Parent = parent;
+                lock (syncRoot) this.Dictionary[key] = value;
+            }
+        }
+
+        public ICollection<UUID> Keys { get { return this.Dictionary.Keys; } }
+        public ICollection<InventoryNode> Values { get { return this.Dictionary.Values; } }
+
+        public void Add(UUID key, InventoryNode value)
+        {
+            value.Parent = parent;
+            lock (syncRoot) this.Dictionary.Add(key, value); 
+        }
+
+        public void Remove(UUID key)
+        {
+            lock (syncRoot) this.Dictionary.Remove(key);
+        }
+
+        public bool Contains(UUID key)
+        {
+            return this.Dictionary.ContainsKey(key);
+        }
+    }
+}
Index: ObjectManager.cs
===================================================================
--- ObjectManager.cs	(revision 2445)
+++ ObjectManager.cs	(working copy)
@@ -1603,7 +1603,7 @@
 
                         Avatar avatar = GetAvatar(simulator, block.ID, block.FullID);
                         uint oldSeatID = avatar.ParentID;
-
+                        
                         avatar.ID = block.FullID;
                         avatar.LocalID = block.ID;
                         avatar.CollisionPlane = collisionPlane;
Index: EventDictionary.cs
===================================================================
--- EventDictionary.cs	(revision 2445)
+++ EventDictionary.cs	(working copy)
@@ -1,397 +1,397 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-using System.Threading;
-using OpenMetaverse.Packets;
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// Registers, unregisters, and fires events generated by incoming packets
-    /// </summary>
-    public class PacketEventDictionary
-    {
-        /// <summary>
-        /// Object that is passed to worker threads in the ThreadPool for
-        /// firing packet callbacks
-        /// </summary>
-        private struct PacketCallbackWrapper
-        {
-            /// <summary>Callback to fire for this packet</summary>
-            public NetworkManager.PacketCallback Callback;
-            /// <summary>Reference to the simulator that this packet came from</summary>
-            public Simulator Simulator;
-            /// <summary>The packet that needs to be processed</summary>
-            public Packet Packet;
-        }
-
-        /// <summary>Reference to the GridClient object</summary>
-        public GridClient Client;
-
-        private Dictionary<PacketType, NetworkManager.PacketCallback> _EventTable = 
-            new Dictionary<PacketType,NetworkManager.PacketCallback>();
-        private WaitCallback _ThreadPoolCallback;
-
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        /// <param name="client"></param>
-        public PacketEventDictionary(GridClient client)
-        {
-            Client = client;
-            _ThreadPoolCallback = new WaitCallback(ThreadPoolDelegate);
-        }
-
-        /// <summary>
-        /// Register an event handler
-        /// </summary>
-        /// <remarks>Use PacketType.Default to fire this event on every 
-        /// incoming packet</remarks>
-        /// <param name="packetType">Packet type to register the handler for</param>
-        /// <param name="eventHandler">Callback to be fired</param>
-        public void RegisterEvent(PacketType packetType, NetworkManager.PacketCallback eventHandler)
-        {
-            lock (_EventTable)
-            {
-                if (_EventTable.ContainsKey(packetType))
-                    _EventTable[packetType] += eventHandler;
-                else
-                    _EventTable[packetType] = eventHandler;
-            }
-        }
-
-        /// <summary>
-        /// Unregister an event handler
-        /// </summary>
-        /// <param name="packetType">Packet type to unregister the handler for</param>
-        /// <param name="eventHandler">Callback to be unregistered</param>
-        public void UnregisterEvent(PacketType packetType, NetworkManager.PacketCallback eventHandler)
-        {
-            lock (_EventTable)
-            {
-                if (_EventTable.ContainsKey(packetType) && _EventTable[packetType] != null)
-                    _EventTable[packetType] -= eventHandler;
-            }
-        }
-
-        /// <summary>
-        /// Fire the events registered for this packet type synchronously
-        /// </summary>
-        /// <param name="packetType">Incoming packet type</param>
-        /// <param name="packet">Incoming packet</param>
-        /// <param name="simulator">Simulator this packet was received from</param>
-        internal void RaiseEvent(PacketType packetType, Packet packet, Simulator simulator)
-        {
-            NetworkManager.PacketCallback callback;
-
-            // Default handler first, if one exists
-            if (_EventTable.TryGetValue(PacketType.Default, out callback))
-            {
-                try { callback(packet, simulator); }
-                catch (Exception ex)
-                {
-                    Logger.Log("Default packet event handler: " + ex.ToString(), Helpers.LogLevel.Error, Client);
-                }
-            }
-
-            if (_EventTable.TryGetValue(packetType, out callback))
-            {
-                try { callback(packet, simulator); }
-                catch (Exception ex)
-                {
-                    Logger.Log("Packet event handler: " + ex.ToString(), Helpers.LogLevel.Error, Client);
-                }
-
-                return;
-            }
-            
-            if (packetType != PacketType.Default && packetType != PacketType.PacketAck)
-            {
-                Logger.DebugLog("No handler registered for packet event " + packetType, Client);
-            }
-        }
-
-        /// <summary>
-        /// Fire the events registered for this packet type asynchronously
-        /// </summary>
-        /// <param name="packetType">Incoming packet type</param>
-        /// <param name="packet">Incoming packet</param>
-        /// <param name="simulator">Simulator this packet was received from</param>
-        internal void BeginRaiseEvent(PacketType packetType, Packet packet, Simulator simulator)
-        {
-            NetworkManager.PacketCallback callback;
-            PacketCallbackWrapper wrapper;
-
-            // Default handler first, if one exists
-            if (_EventTable.TryGetValue(PacketType.Default, out callback))
-            {
-                if (callback != null)
-                {
-                    wrapper.Callback = callback;
-                    wrapper.Packet = packet;
-                    wrapper.Simulator = simulator;
-                    ThreadPool.QueueUserWorkItem(_ThreadPoolCallback, wrapper);
-                }
-            }
-
-            if (_EventTable.TryGetValue(packetType, out callback))
-            {
-                if (callback != null)
-                {
-                    wrapper.Callback = callback;
-                    wrapper.Packet = packet;
-                    wrapper.Simulator = simulator;
-                    ThreadPool.QueueUserWorkItem(_ThreadPoolCallback, wrapper);
-
-                    return;
-                }
-            }
-
-            if (packetType != PacketType.Default && packetType != PacketType.PacketAck)
-            {
-                Logger.DebugLog("No handler registered for packet event " + packetType, Client);
-            }
-        }
-
-        private void ThreadPoolDelegate(Object state)
-        {
-            PacketCallbackWrapper wrapper = (PacketCallbackWrapper)state;
-
-            try
-            {
-                wrapper.Callback(wrapper.Packet, wrapper.Simulator);
-            }
-            catch (Exception ex)
-            {
-                Logger.Log("Async Packet Event Handler: " + ex.ToString(), Helpers.LogLevel.Error, Client);
-            }
-        }
-    }
-
-    /// <summary>
-    /// Registers, unregisters, and fires events generated by the Capabilities
-    /// event queue
-    /// </summary>
-    public class CapsEventDictionary
-    {
-        /// <summary>
-        /// Object that is passed to worker threads in the ThreadPool for
-        /// firing CAPS callbacks
-        /// </summary>
-        private struct CapsCallbackWrapper
-        {
-            /// <summary>Callback to fire for this packet</summary>
-            public Caps.EventQueueCallback Callback;
-            /// <summary>Name of the CAPS event</summary>
-            public string CapsEvent;
-            /// <summary>Decoded body of the CAPS event</summary>
-            public StructuredData.OSD Body;
-            /// <summary>Reference to the simulator that generated this event</summary>
-            public Simulator Simulator;
-        }
-
-        /// <summary>Reference to the GridClient object</summary>
-        public GridClient Client;
-
-        private Dictionary<string, Caps.EventQueueCallback> _EventTable =
-            new Dictionary<string, Caps.EventQueueCallback>();
-        private WaitCallback _ThreadPoolCallback;
-
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        /// <param name="client">Reference to the GridClient object</param>
-        public CapsEventDictionary(GridClient client)
-        {
-            Client = client;
-            _ThreadPoolCallback = new WaitCallback(ThreadPoolDelegate);
-        }
-
-        /// <summary>
-        /// Register an event handler
-        /// </summary>
-        /// <remarks>Use String.Empty to fire this event on every CAPS event</remarks>
-        /// <param name="capsEvent">Capability event name to register the 
-        /// handler for</param>
-        /// <param name="eventHandler">Callback to fire</param>
-        public void RegisterEvent(string capsEvent, Caps.EventQueueCallback eventHandler)
-        {
-            lock (_EventTable)
-            {
-                if (_EventTable.ContainsKey(capsEvent))
-                    _EventTable[capsEvent] += eventHandler;
-                else
-                    _EventTable[capsEvent] = eventHandler;
-            }
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="capsEvent">Capability event name unregister the 
-        /// handler for</param>
-        /// <param name="eventHandler">Callback to unregister</param>
-        public void UnregisterEvent(string capsEvent, Caps.EventQueueCallback eventHandler)
-        {
-            lock (_EventTable)
-            {
-                if (_EventTable.ContainsKey(capsEvent) && _EventTable[capsEvent] != null)
-                    _EventTable[capsEvent] -= eventHandler;
-            }
-        }
-
-        /// <summary>
-        /// Fire the events registered for this event type synchronously
-        /// </summary>
-        /// <param name="capsEvent">Capability name</param>
-        /// <param name="body">Decoded event body</param>
-        /// <param name="simulator">Reference to the simulator that 
-        /// generated this event</param>
-        internal void RaiseEvent(string capsEvent, StructuredData.OSD body, Simulator simulator)
-        {
-            bool specialHandler = false;
-            Caps.EventQueueCallback callback;
-
-            // Default handler first, if one exists
-            if (_EventTable.TryGetValue(capsEvent, out callback))
-            {
-                if (callback != null)
-                {
-                    try { callback(capsEvent, body, simulator); }
-                    catch (Exception ex) { Logger.Log("CAPS Event Handler: " + ex.ToString(), Helpers.LogLevel.Error, Client); }
-                }
-            }
-
-            // Generic parser next
-            if (body.Type == StructuredData.OSDType.Map)
-            {
-                StructuredData.OSDMap map = (StructuredData.OSDMap)body;
-                Packet packet = Packet.BuildPacket(capsEvent, map);
-                if (packet != null)
-                {
-                    NetworkManager.IncomingPacket incomingPacket;
-                    incomingPacket.Simulator = simulator;
-                    incomingPacket.Packet = packet;
-
-                    Logger.DebugLog("Serializing " + packet.Type.ToString() + " capability with generic handler", Client);
-
-                    Client.Network.PacketInbox.Enqueue(incomingPacket);
-                    specialHandler = true;
-                }
-            }
-
-            // Explicit handler next
-            if (_EventTable.TryGetValue(capsEvent, out callback) && callback != null)
-            {
-                try { callback(capsEvent, body, simulator); }
-                catch (Exception ex) { Logger.Log("CAPS Event Handler: " + ex.ToString(), Helpers.LogLevel.Error, Client); }
-
-                specialHandler = true;
-            }
-
-            if (!specialHandler)
-                Logger.Log("Unhandled CAPS event " + capsEvent, Helpers.LogLevel.Warning, Client);
-        }
-
-        /// <summary>
-        /// Fire the events registered for this event type asynchronously
-        /// </summary>
-        /// <param name="capsEvent">Capability name</param>
-        /// <param name="body">Decoded event body</param>
-        /// <param name="simulator">Reference to the simulator that 
-        /// generated this event</param>
-        internal void BeginRaiseEvent(string capsEvent, StructuredData.OSD body, Simulator simulator)
-        {
-            bool specialHandler = false;
-            Caps.EventQueueCallback callback;
-
-            // Default handler first, if one exists
-            if (_EventTable.TryGetValue(String.Empty, out callback))
-            {
-                if (callback != null)
-                {
-                    CapsCallbackWrapper wrapper;
-                    wrapper.Callback = callback;
-                    wrapper.CapsEvent = capsEvent;
-                    wrapper.Body = body;
-                    wrapper.Simulator = simulator;
-                    ThreadPool.QueueUserWorkItem(_ThreadPoolCallback, wrapper);
-                }
-            }
-
-            // Generic parser next, don't generic parse events we've manually registered for
-            if (body.Type == StructuredData.OSDType.Map && !_EventTable.ContainsKey(capsEvent))
-            {
-                StructuredData.OSDMap map = (StructuredData.OSDMap)body;
-                Packet packet = Packet.BuildPacket(capsEvent, map);
-                if (packet != null)
-                {
-                    NetworkManager.IncomingPacket incomingPacket;
-                    incomingPacket.Simulator = simulator;
-                    incomingPacket.Packet = packet;
-
-                    Logger.DebugLog("Serializing " + packet.Type.ToString() + " capability with generic handler", Client);
-
-                    Client.Network.PacketInbox.Enqueue(incomingPacket);
-                    specialHandler = true;
-                }
-            }
-            
-            // Explicit handler next
-            if (_EventTable.TryGetValue(capsEvent, out callback) && callback != null)
-            {
-                CapsCallbackWrapper wrapper;
-                wrapper.Callback = callback;
-                wrapper.CapsEvent = capsEvent;
-                wrapper.Body = body;
-                wrapper.Simulator = simulator;
-                ThreadPool.QueueUserWorkItem(_ThreadPoolCallback, wrapper);
-
-                specialHandler = true;
-            }
-
-            if (!specialHandler)
-                Logger.Log("Unhandled CAPS event " + capsEvent, Helpers.LogLevel.Warning, Client);
-        }
-
-        private void ThreadPoolDelegate(Object state)
-        {
-            CapsCallbackWrapper wrapper = (CapsCallbackWrapper)state;
-
-            try
-            {
-                wrapper.Callback(wrapper.CapsEvent, wrapper.Body, wrapper.Simulator);
-            }
-            catch (Exception ex)
-            {
-                Logger.Log("Async CAPS Event Handler: " + ex.ToString(), Helpers.LogLevel.Error, Client);
-            }
-        }
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Threading;
+using OpenMetaverse.Packets;
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// Registers, unregisters, and fires events generated by incoming packets
+    /// </summary>
+    public class PacketEventDictionary
+    {
+        /// <summary>
+        /// Object that is passed to worker threads in the ThreadPool for
+        /// firing packet callbacks
+        /// </summary>
+        private struct PacketCallbackWrapper
+        {
+            /// <summary>Callback to fire for this packet</summary>
+            public NetworkManager.PacketCallback Callback;
+            /// <summary>Reference to the simulator that this packet came from</summary>
+            public Simulator Simulator;
+            /// <summary>The packet that needs to be processed</summary>
+            public Packet Packet;
+        }
+
+        /// <summary>Reference to the GridClient object</summary>
+        public GridClient Client;
+
+        private Dictionary<PacketType, NetworkManager.PacketCallback> _EventTable = 
+            new Dictionary<PacketType,NetworkManager.PacketCallback>();
+        private WaitCallback _ThreadPoolCallback;
+
+        /// <summary>
+        /// Default constructor
+        /// </summary>
+        /// <param name="client"></param>
+        public PacketEventDictionary(GridClient client)
+        {
+            Client = client;
+            _ThreadPoolCallback = new WaitCallback(ThreadPoolDelegate);
+        }
+
+        /// <summary>
+        /// Register an event handler
+        /// </summary>
+        /// <remarks>Use PacketType.Default to fire this event on every 
+        /// incoming packet</remarks>
+        /// <param name="packetType">Packet type to register the handler for</param>
+        /// <param name="eventHandler">Callback to be fired</param>
+        public void RegisterEvent(PacketType packetType, NetworkManager.PacketCallback eventHandler)
+        {
+            lock (_EventTable)
+            {
+                if (_EventTable.ContainsKey(packetType))
+                    _EventTable[packetType] += eventHandler;
+                else
+                    _EventTable[packetType] = eventHandler;
+            }
+        }
+
+        /// <summary>
+        /// Unregister an event handler
+        /// </summary>
+        /// <param name="packetType">Packet type to unregister the handler for</param>
+        /// <param name="eventHandler">Callback to be unregistered</param>
+        public void UnregisterEvent(PacketType packetType, NetworkManager.PacketCallback eventHandler)
+        {
+            lock (_EventTable)
+            {
+                if (_EventTable.ContainsKey(packetType) && _EventTable[packetType] != null)
+                    _EventTable[packetType] -= eventHandler;
+            }
+        }
+
+        /// <summary>
+        /// Fire the events registered for this packet type synchronously
+        /// </summary>
+        /// <param name="packetType">Incoming packet type</param>
+        /// <param name="packet">Incoming packet</param>
+        /// <param name="simulator">Simulator this packet was received from</param>
+        internal void RaiseEvent(PacketType packetType, Packet packet, Simulator simulator)
+        {
+            NetworkManager.PacketCallback callback;
+
+            // Default handler first, if one exists
+            if (_EventTable.TryGetValue(PacketType.Default, out callback))
+            {
+                try { callback(packet, simulator); }
+                catch (Exception ex)
+                {
+                    Logger.Log("Default packet event handler: " + ex.ToString(), Helpers.LogLevel.Error, Client);
+                }
+            }
+
+            if (_EventTable.TryGetValue(packetType, out callback))
+            {
+                try { callback(packet, simulator); }
+                catch (Exception ex)
+                {
+                    Logger.Log("Packet event handler: " + ex.ToString(), Helpers.LogLevel.Error, Client);
+                }
+
+                return;
+            }
+            
+            if (packetType != PacketType.Default && packetType != PacketType.PacketAck)
+            {
+                Logger.DebugLog("No handler registered for packet event " + packetType, Client);
+            }
+        }
+
+        /// <summary>
+        /// Fire the events registered for this packet type asynchronously
+        /// </summary>
+        /// <param name="packetType">Incoming packet type</param>
+        /// <param name="packet">Incoming packet</param>
+        /// <param name="simulator">Simulator this packet was received from</param>
+        internal void BeginRaiseEvent(PacketType packetType, Packet packet, Simulator simulator)
+        {
+            NetworkManager.PacketCallback callback;
+            PacketCallbackWrapper wrapper;
+
+            // Default handler first, if one exists
+            if (_EventTable.TryGetValue(PacketType.Default, out callback))
+            {
+                if (callback != null)
+                {
+                    wrapper.Callback = callback;
+                    wrapper.Packet = packet;
+                    wrapper.Simulator = simulator;
+                    ThreadPool.QueueUserWorkItem(_ThreadPoolCallback, wrapper);
+                }
+            }
+
+            if (_EventTable.TryGetValue(packetType, out callback))
+            {
+                if (callback != null)
+                {
+                    wrapper.Callback = callback;
+                    wrapper.Packet = packet;
+                    wrapper.Simulator = simulator;
+                    ThreadPool.QueueUserWorkItem(_ThreadPoolCallback, wrapper);
+
+                    return;
+                }
+            }
+
+            if (packetType != PacketType.Default && packetType != PacketType.PacketAck)
+            {
+                Logger.DebugLog("No handler registered for packet event " + packetType, Client);
+            }
+        }
+
+        private void ThreadPoolDelegate(Object state)
+        {
+            PacketCallbackWrapper wrapper = (PacketCallbackWrapper)state;
+
+            try
+            {
+                wrapper.Callback(wrapper.Packet, wrapper.Simulator);
+            }
+            catch (Exception ex)
+            {
+                Logger.Log("Async Packet Event Handler: " + ex.ToString(), Helpers.LogLevel.Error, Client);
+            }
+        }
+    }
+
+    /// <summary>
+    /// Registers, unregisters, and fires events generated by the Capabilities
+    /// event queue
+    /// </summary>
+    public class CapsEventDictionary
+    {
+        /// <summary>
+        /// Object that is passed to worker threads in the ThreadPool for
+        /// firing CAPS callbacks
+        /// </summary>
+        private struct CapsCallbackWrapper
+        {
+            /// <summary>Callback to fire for this packet</summary>
+            public Caps.EventQueueCallback Callback;
+            /// <summary>Name of the CAPS event</summary>
+            public string CapsEvent;
+            /// <summary>Decoded body of the CAPS event</summary>
+            public StructuredData.OSD Body;
+            /// <summary>Reference to the simulator that generated this event</summary>
+            public Simulator Simulator;
+        }
+
+        /// <summary>Reference to the GridClient object</summary>
+        public GridClient Client;
+
+        private Dictionary<string, Caps.EventQueueCallback> _EventTable =
+            new Dictionary<string, Caps.EventQueueCallback>();
+        private WaitCallback _ThreadPoolCallback;
+
+        /// <summary>
+        /// Default constructor
+        /// </summary>
+        /// <param name="client">Reference to the GridClient object</param>
+        public CapsEventDictionary(GridClient client)
+        {
+            Client = client;
+            _ThreadPoolCallback = new WaitCallback(ThreadPoolDelegate);
+        }
+
+        /// <summary>
+        /// Register an event handler
+        /// </summary>
+        /// <remarks>Use String.Empty to fire this event on every CAPS event</remarks>
+        /// <param name="capsEvent">Capability event name to register the 
+        /// handler for</param>
+        /// <param name="eventHandler">Callback to fire</param>
+        public void RegisterEvent(string capsEvent, Caps.EventQueueCallback eventHandler)
+        {
+            lock (_EventTable)
+            {
+                if (_EventTable.ContainsKey(capsEvent))
+                    _EventTable[capsEvent] += eventHandler;
+                else
+                    _EventTable[capsEvent] = eventHandler;
+            }
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="capsEvent">Capability event name unregister the 
+        /// handler for</param>
+        /// <param name="eventHandler">Callback to unregister</param>
+        public void UnregisterEvent(string capsEvent, Caps.EventQueueCallback eventHandler)
+        {
+            lock (_EventTable)
+            {
+                if (_EventTable.ContainsKey(capsEvent) && _EventTable[capsEvent] != null)
+                    _EventTable[capsEvent] -= eventHandler;
+            }
+        }
+
+        /// <summary>
+        /// Fire the events registered for this event type synchronously
+        /// </summary>
+        /// <param name="capsEvent">Capability name</param>
+        /// <param name="body">Decoded event body</param>
+        /// <param name="simulator">Reference to the simulator that 
+        /// generated this event</param>
+        internal void RaiseEvent(string capsEvent, StructuredData.OSD body, Simulator simulator)
+        {
+            bool specialHandler = false;
+            Caps.EventQueueCallback callback;
+
+            // Default handler first, if one exists
+            if (_EventTable.TryGetValue(capsEvent, out callback))
+            {
+                if (callback != null)
+                {
+                    try { callback(capsEvent, body, simulator); }
+                    catch (Exception ex) { Logger.Log("CAPS Event Handler: " + ex.ToString(), Helpers.LogLevel.Error, Client); }
+                }
+            }
+
+            // Generic parser next
+            if (body.Type == StructuredData.OSDType.Map)
+            {
+                StructuredData.OSDMap map = (StructuredData.OSDMap)body;
+                Packet packet = Packet.BuildPacket(capsEvent, map);
+                if (packet != null)
+                {
+                    NetworkManager.IncomingPacket incomingPacket;
+                    incomingPacket.Simulator = simulator;
+                    incomingPacket.Packet = packet;
+
+                    Logger.DebugLog("Serializing " + packet.Type.ToString() + " capability with generic handler", Client);
+
+                    Client.Network.PacketInbox.Enqueue(incomingPacket);
+                    specialHandler = true;
+                }
+            }
+
+            // Explicit handler next
+            if (_EventTable.TryGetValue(capsEvent, out callback) && callback != null)
+            {
+                try { callback(capsEvent, body, simulator); }
+                catch (Exception ex) { Logger.Log("CAPS Event Handler: " + ex.ToString(), Helpers.LogLevel.Error, Client); }
+
+                specialHandler = true;
+            }
+
+            if (!specialHandler)
+                Logger.Log("Unhandled CAPS event " + capsEvent, Helpers.LogLevel.Warning, Client);
+        }
+
+        /// <summary>
+        /// Fire the events registered for this event type asynchronously
+        /// </summary>
+        /// <param name="capsEvent">Capability name</param>
+        /// <param name="body">Decoded event body</param>
+        /// <param name="simulator">Reference to the simulator that 
+        /// generated this event</param>
+        internal void BeginRaiseEvent(string capsEvent, StructuredData.OSD body, Simulator simulator)
+        {
+            bool specialHandler = false;
+            Caps.EventQueueCallback callback;
+
+            // Default handler first, if one exists
+            if (_EventTable.TryGetValue(String.Empty, out callback))
+            {
+                if (callback != null)
+                {
+                    CapsCallbackWrapper wrapper;
+                    wrapper.Callback = callback;
+                    wrapper.CapsEvent = capsEvent;
+                    wrapper.Body = body;
+                    wrapper.Simulator = simulator;
+                    ThreadPool.QueueUserWorkItem(_ThreadPoolCallback, wrapper);
+                }
+            }
+
+            // Generic parser next, don't generic parse events we've manually registered for
+            if (body.Type == StructuredData.OSDType.Map && !_EventTable.ContainsKey(capsEvent))
+            {
+                StructuredData.OSDMap map = (StructuredData.OSDMap)body;
+                Packet packet = Packet.BuildPacket(capsEvent, map);
+                if (packet != null)
+                {
+                    NetworkManager.IncomingPacket incomingPacket;
+                    incomingPacket.Simulator = simulator;
+                    incomingPacket.Packet = packet;
+
+                    Logger.DebugLog("Serializing " + packet.Type.ToString() + " capability with generic handler", Client);
+
+                    Client.Network.PacketInbox.Enqueue(incomingPacket);
+                    specialHandler = true;
+                }
+            }
+            
+            // Explicit handler next
+            if (_EventTable.TryGetValue(capsEvent, out callback) && callback != null)
+            {
+                CapsCallbackWrapper wrapper;
+                wrapper.Callback = callback;
+                wrapper.CapsEvent = capsEvent;
+                wrapper.Body = body;
+                wrapper.Simulator = simulator;
+                ThreadPool.QueueUserWorkItem(_ThreadPoolCallback, wrapper);
+
+                specialHandler = true;
+            }
+
+            if (!specialHandler)
+                Logger.Log("Unhandled CAPS event " + capsEvent, Helpers.LogLevel.Warning, Client);
+        }
+
+        private void ThreadPoolDelegate(Object state)
+        {
+            CapsCallbackWrapper wrapper = (CapsCallbackWrapper)state;
+
+            try
+            {
+                wrapper.Callback(wrapper.CapsEvent, wrapper.Body, wrapper.Simulator);
+            }
+            catch (Exception ex)
+            {
+                Logger.Log("Async CAPS Event Handler: " + ex.ToString(), Helpers.LogLevel.Error, Client);
+            }
+        }
+    }
+}
